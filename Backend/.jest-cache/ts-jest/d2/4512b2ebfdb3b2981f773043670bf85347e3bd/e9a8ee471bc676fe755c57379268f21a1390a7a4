[["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\jest.setup.ts",{"fileContent":"require(\"dotenv\").config({ path: \".env.test\" });\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\routes\\EventRoute.test.ts",{"fileContent":"import request from \"supertest\";\r\n//import { req } from \"../jest.setup\";\r\nimport { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  LoginResource,\r\n  addressResource,\r\n  categoryResource,\r\n  eventResource,\r\n  userResource,\r\n} from \"../../src/Resources\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\nimport app from \"../../server\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\n\r\nconst a: addressResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst JaneData: userResource = {\r\n  email: \"Jane@doe.com\",\r\n  name: {\r\n    first: \"Jane\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst eventService: EventService = new EventService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\nlet admin: userResource;\r\nlet AdminToken: string;\r\nlet jane: userResource;\r\nlet token: string;\r\nlet user: userResource;\r\nlet uToken: string;\r\nlet req = request(app);\r\n\r\ndescribe(\"EventRoute Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  beforeEach(async () => {\r\n    admin = await userService.createUser(u);\r\n    jane = await userService.createUser(JaneData);\r\n    user = await userService.createUser(u2);\r\n    const adminloginData = { email: \"John@doe.com\", password: \"12abcAB!\" };\r\n    const adminRes = await req.post(`/api/login`).send(adminloginData);\r\n    const AdminLoginResource = adminRes.body as LoginResource;\r\n    AdminToken = AdminLoginResource.access_token;\r\n\r\n    const janeLoginData = { email: \"Jane@doe.com\", password: \"12abcAB!\" };\r\n    const janeRes = await req.post(`/api/login`).send(janeLoginData);\r\n    const janeLoginResource = janeRes.body as LoginResource;\r\n    token = janeLoginResource.access_token;\r\n\r\n    const uLoginData = { email: \"test@mail.com\", password: \"12abcAB!\" };\r\n    const uRes = await req.post(`/api/login`).send(uLoginData);\r\n    const uLoginResource = uRes.body as LoginResource;\r\n    uToken = uLoginResource.access_token;\r\n  });\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => {\r\n    //closeServer(); // Close the server after all tests\r\n    await closeDatabase(); // Perform final cleanup after all tests\r\n  });\r\n\r\n  test(\"create event route\", async () => {\r\n    let res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(e)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    const event: eventResource = res.body;\r\n    expect(event.id).toBeDefined();\r\n    expect(event.name).toBe(\"Sample Event\");\r\n    expect(event.creator).toBe(jane.id);\r\n    expect(event.description).toBe(e.description);\r\n    expect(event.price).toBe(e.price);\r\n    expect(event.date).toBe(e.date.toISOString());\r\n    expect(event.address).toMatchObject(a);\r\n    expect(event.thumbnail).toBe(e.thumbnail);\r\n    expect(event.hashtags).toStrictEqual(e.hashtags);\r\n    expect(event.category).toHaveLength(2);\r\n    expect(event.chat).toBeDefined();\r\n    expect(event.participants).toHaveLength(1);\r\n    // create event as admin\r\n    res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(e)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    // duplicate event data should still work\r\n    const event1: eventResource = res.body;\r\n    expect(event1).toBeDefined();\r\n    expect(event1.id).not.toBe(event.id);\r\n    expect(event1.name).toBe(event.name);\r\n    expect(event1.creator).toBe(admin.id);\r\n    expect(event1.description).toBe(event.description);\r\n    expect(event1.price).toBe(event.price);\r\n    expect(event1.date).toBe(event.date);\r\n    expect(event1.thumbnail).toBe(event.thumbnail);\r\n    expect(event1.hashtags).toStrictEqual(event.hashtags);\r\n    expect(event1.chat).not.toBe(event.chat);\r\n    expect(event.participants.length).toBe(event.participants.length);\r\n    // invalid token/event data\r\n    res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(undefined)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(400);\r\n    expect(res.body.errors).toBeDefined();\r\n    res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(e)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    // get event as event creator\r\n    let res = await req\r\n      .get(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.name).toBe(\"Sample Event\");\r\n    // get event as user\r\n    res = await req\r\n      .get(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.name).toBe(\"Sample Event\");\r\n    // invalid id/token\r\n    res = await req\r\n      .get(`/api/events/${NON_EXISTING_ID}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n    res = await req\r\n      .get(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"join event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    // join event as user\r\n    let res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.message).toBe(\"User joined the event successfully\");\r\n    const ee = await eventService.getEvent(event.id);\r\n    expect(ee.participants).toHaveLength(2);\r\n    // user already participating\r\n    res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(409);\r\n    // join event as event creator should not work\r\n    res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(409);\r\n    // invalid id/token\r\n    res = await req\r\n      .post(`/api/events/${undefined}/join`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(500);\r\n    res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"cancel event participation route\", async () => {\r\n    let event = await eventService.createEvent(e, jane.id);\r\n    // invalid id/token\r\n    let res = await req\r\n      .delete(`/api/events/${undefined}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(500);\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n    // user not participating\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(409);\r\n    // cancel participation works correctly\r\n    await eventService.joinEvent(user.id, event.id);\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(204);\r\n    // cancel participation as event creator should not work\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(409);\r\n  });\r\n\r\n  test(\"get participants of event route\", async () => {\r\n    let event = await eventService.createEvent(e, jane.id);\r\n    await eventService.joinEvent(user.id, event.id);\r\n    // get participants as event creator\r\n    let res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.users).toHaveLength(2);\r\n    expect(res.body.users[0].email).toBe(\"Jane@doe.com\");\r\n    expect(res.body.users[1].email).toBe(\"test@mail.com\");\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.users).toHaveLength(2);\r\n    // get participants as user should not work\r\n    res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(404);\r\n    // invalid id/token\r\n    res = await req\r\n      .get(`/api/events/${undefined}/participants`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n    res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get created events route\", async () => {\r\n    await eventService.createEvent(e, jane.id);\r\n    await eventService.createEvent(e1, jane.id);\r\n    await eventService.createEvent(e2, jane.id);\r\n    // get created events as event creator\r\n    let res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    expect(res.body.events[0].name).toBe(\"Sample Event\");\r\n    expect(res.body.events[1].name).toBe(\"Sample Event 1\");\r\n    expect(res.body.events[2].name).toBe(\"Sample Event 2\");\r\n    // get created events of user with no events\r\n    res = await req\r\n      .get(`/api/events/creator/${user.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(204);\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    // get created events as user shoud not work\r\n    res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(403);\r\n    // invalid id/token\r\n    res = await req\r\n      .get(`/api/events/creator/${undefined}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n    res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get joined events route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    const event1 = await eventService.createEvent(e1, jane.id);\r\n    const event2 = await eventService.createEvent(e2, jane.id);\r\n    await eventService.joinEvent(user.id, event.id);\r\n    await eventService.joinEvent(user.id, event1.id);\r\n    await eventService.joinEvent(user.id, event2.id);\r\n    // 3 events created no events joined\r\n    let res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    // no events created 3 events joined\r\n    res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    // no events created no events joined\r\n    res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(204);\r\n    expect(res.body.events).toBeUndefined();\r\n    // invalid token\r\n    res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get all events route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    const event1 = await eventService.createEvent(e1, user.id);\r\n    const event2 = await eventService.createEvent(e2, admin.id);\r\n    // get all events as registered user\r\n    let res = await req\r\n      .get(`/api/events/`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    // get all events as guest user\r\n    res = await req.get(`/api/events/`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n  });\r\n\r\n  test(\"search events route\", async () => {\r\n    await eventService.createEvent(e, jane.id);\r\n    await eventService.createEvent(e1, user.id);\r\n    await eventService.createEvent(e2, admin.id);\r\n    // search by event name\r\n    let res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"sAmPle eVeNt\" })\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"event 2\" })\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(1);\r\n    res = await req.get(\"/api/events/search\").query({ query: \"EVENT SAMPLE\" });\r\n    expect(res.status).toBe(204);\r\n    expect(res.body.events).toBeUndefined();\r\n    // search by description\r\n    res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"this is my\" })\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(2);\r\n    // search by hashtags\r\n    res = await req.get(\"/api/events/search\").query({ query: \"SPORT\" });\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(1);\r\n    res = await req.get(\"/api/events/search\").query({ query: \"freizeit\" });\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(2);\r\n    res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"Sport Freizeit\" });\r\n    expect(res.status).toBe(204);\r\n    expect(res.body.events).toBeUndefined();\r\n  });\r\n\r\n  test(\"delete event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    const event1 = await eventService.createEvent(e1, user.id);\r\n    // user can not delete event of another event creator\r\n    let res = await req\r\n      .delete(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(404);\r\n    expect(await eventService.getEvent(event.id)).toBeDefined();\r\n    // event creator can delete own event correctly\r\n    res = await req\r\n      .delete(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(204);\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n    // invalid id/token\r\n    res = await req\r\n      .delete(`/api/events/${undefined}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(404);\r\n    expect(await eventService.getEvent(event1.id)).toBeDefined();\r\n    res = await req\r\n      .delete(`/api/events/${event1.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n    expect(await eventService.getEvent(event1.id)).toBeDefined();\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .delete(`/api/events/${event1.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(204);\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"update event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    // user can not update event of another event creator\r\n    let res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .send(e1)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(404);\r\n    // no updated event data sent should still work\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.name).toBe(event.name);\r\n    // invalid id/token\r\n    res = await req\r\n      .put(`/api/events/${undefined}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(400);\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n    // event creator should update event correctly\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .send(e1)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    // eventresource returned correctly\r\n    expect(res.body.id).toBe(event.id);\r\n    expect(res.body.name).toBe(e1.name);\r\n    expect(res.body.creator).toBe(event.creator);\r\n    expect(res.body.description).toBe(e1.description);\r\n    expect(res.body.price).toBe(e1.price);\r\n    expect(res.body.date).toStrictEqual(e1.date.toISOString());\r\n    expect(res.body.address).toMatchObject(a);\r\n    expect(res.body.thumbnail).toBe(event.thumbnail);\r\n    expect(res.body.hashtags).toStrictEqual(event.hashtags);\r\n    expect(res.body.category.length).toBe(1);\r\n    expect(res.body.chat).toBe(event.chat);\r\n    expect(res.body.participants).toStrictEqual(event.participants);\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .send(e1)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    const newevent = await eventService.getEvent(event.id);\r\n    expect(newevent.id).toBe(event.id);\r\n    expect(newevent.name).toBe(\"Sample Event 1\");\r\n    expect(newevent.creator).toBe(event.creator);\r\n    expect(newevent.description).toBe(e1.description);\r\n    expect(newevent.price).toBe(e1.price);\r\n    expect(newevent.date).toStrictEqual(e1.date);\r\n    expect(newevent.address).toMatchObject(a);\r\n    expect(newevent.thumbnail).toBe(event.thumbnail);\r\n    expect(newevent.hashtags).toStrictEqual(event.hashtags);\r\n    expect(newevent.category.length).toBe(1);\r\n    expect(newevent.chat).toBe(event.chat);\r\n    expect(newevent.participants).toStrictEqual(event.participants);\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/server.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\database\\db.ts",{"fileContent":"// Copyright: This script is taken from: https://codesandbox.io/s/typescript-forked-8vscow?file=/src/db.ts\r\nimport mongoose from \"mongoose\";\r\nimport { MongoMemoryServer } from \"mongodb-memory-server\";\r\n\r\nlet mongod: any;\r\n\r\nexport const connect = async () => {\r\n  mongod = await MongoMemoryServer.create();\r\n  const uri = mongod.getUri();\r\n  await mongoose\r\n    .connect(uri, { dbName: \"ConnectAndExplore\" })\r\n    .then((_result) => console.log(\"connected....\"))\r\n    .catch((err) => console.log(`Cannot connect => ${err}`));\r\n};\r\n\r\n/**\r\n * Close db connection\r\n */\r\nexport const closeDatabase = async () => {\r\n  await mongoose.connection.dropDatabase();\r\n  await mongoose.connection.close();\r\n  await mongod.stop();\r\n};\r\n\r\n/**\r\n * Delete db collections\r\n */\r\nexport const clearDatabase = async () => {\r\n  const collections = mongoose.connection.collections;\r\n\r\n  for (const key in collections) {\r\n    const collection = collections[key];\r\n    await collection.deleteMany({});\r\n  }\r\n};\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\EventService.ts",{"fileContent":"import { Types } from \"mongoose\";\r\nimport { eventResource, eventsResource, usersResource } from \"../Resources\";\r\nimport { Event } from \"../model/EventModel\";\r\nimport { User } from \"../model/UserModel\";\r\n\r\nexport class EventService {\r\n  /**\r\n   * Event erstellen\r\n   */\r\n  async createEvent(\r\n    eventResource: eventResource,\r\n    creatorID: string\r\n  ): Promise<eventResource> {\r\n    try {\r\n      const creator = await User.findById(creatorID);\r\n      const event = await Event.create({\r\n        name: eventResource.name,\r\n        creator: creator.id,\r\n        description: eventResource.description,\r\n        price: eventResource.price,\r\n        date: eventResource.date,\r\n        address: eventResource.address,\r\n        thumbnail: eventResource.thumbnail,\r\n        hashtags: eventResource.hashtags,\r\n        category: eventResource.category,\r\n        chat: new Types.ObjectId(),\r\n        participants: [creatorID],\r\n      });\r\n      return {\r\n        id: event.id,\r\n        name: event.name,\r\n        creator: event.creator.toString(),\r\n        description: event.description,\r\n        price: event.price,\r\n        date: event.date,\r\n        address: event.address,\r\n        thumbnail: event.thumbnail,\r\n        hashtags: event.hashtags,\r\n        category: event.category,\r\n        chat: event.chat.toString(),\r\n        participants: event.participants.map((participantId) =>\r\n          participantId.toString()\r\n        ),\r\n      };\r\n    } catch (err) {\r\n      throw new Error(\"Event creation failed\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ein bestimmtes Event abrufen\r\n   */\r\n  async getEvent(eventID: string): Promise<eventResource> {\r\n    try {\r\n      const event = await Event.findById(eventID).exec();\r\n      if (!event) {\r\n        throw new Error(\"Event not found\");\r\n      }\r\n      return {\r\n        id: event.id,\r\n        name: event.name,\r\n        creator: event.creator.toString(),\r\n        description: event.description,\r\n        price: event.price,\r\n        date: event.date,\r\n        address: event.address,\r\n        thumbnail: event.thumbnail,\r\n        hashtags: event.hashtags,\r\n        category: event.category,\r\n        chat: event.chat.toString(),\r\n        participants: event.participants.map((participantId) =>\r\n          participantId.toString()\r\n        ),\r\n      };\r\n    } catch (error) {\r\n      throw new Error(\"Error getting event\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle erstellten Events abrufen ( Event Manager / Admin )\r\n   */\r\n  async getEvents(userID: string): Promise<eventsResource> {\r\n    if (!userID) {\r\n      throw new Error(\"Can not get creator, userID is invalid\");\r\n    }\r\n    try {\r\n      const events = await Event.find({ creator: userID }).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString(),\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle Events abrufen\r\n   */\r\n  async getAllEvents(): Promise<eventsResource> {\r\n    try {\r\n      const events = await Event.find({}).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString(),\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Events filtern / Event suchen\r\n   */\r\n  async searchEvents(query: string): Promise<eventsResource> {\r\n    if (!query || query.trim().length === 0) return this.getAllEvents();\r\n    try {\r\n      const events = await Event.find({\r\n        $or: [\r\n          { name: { $regex: new RegExp(query, \"i\") } },\r\n          { description: { $regex: new RegExp(query, \"i\") } },\r\n          { hashtags: { $in: [new RegExp(query, \"i\")] } },\r\n        ],\r\n      }).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString(),\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error searching events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Am Event teilnehmen ( Event Teilnehmer )\r\n   */\r\n  async joinEvent(userID: string, eventID: string): Promise<boolean> {\r\n    if (!userID) throw new Error(`User ID: ${userID} is invalid.`);\r\n    if (!eventID) throw new Error(`Event ID: ${eventID} is invalid.`);\r\n    const user = await User.findById(userID).exec();\r\n    const event = await Event.findById(eventID).exec();\r\n    if (!user) throw new Error(\"User not found\");\r\n    if (!event) throw new Error(\"Event not found\");\r\n    if (event.participants.includes(user._id)) {\r\n      throw new Error(\"User is already participating in the event\");\r\n    }\r\n    try {\r\n      event.participants.push(user._id);\r\n      await event.save();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle teilgenommenen Events abrufen ( Event Teilnehmer )\r\n   */\r\n  async getJoinedEvents(userID: string): Promise<eventsResource> {\r\n    try {\r\n      const events = await Event.find({ participants: userID }).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString(),\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Teilnahme am Event absagen ( Event Teilnehmer )\r\n   */\r\n  async cancelEvent(userID: string, eventID: string): Promise<boolean> {\r\n    if (!userID) throw new Error(`User ID: ${userID} is invalid.`);\r\n    if (!eventID) throw new Error(`Event ID: ${eventID} is invalid.`);\r\n    const event = await Event.findById(eventID).exec();\r\n    if (!event) throw new Error(\"Event not found\");\r\n    if (event.creator && event.creator.toString() === userID)\r\n      throw new Error(\"Can not cancel participation as event manager\");\r\n    const index = event.participants.findIndex((participant) => {\r\n      return participant.equals(new Types.ObjectId(userID));\r\n    });\r\n    if (index === -1) {\r\n      throw new Error(\"User is not participating in the event\");\r\n    }\r\n    try {\r\n      event.participants.splice(index, 1);\r\n      await event.save();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle Teilnehmer vom Event abrufen ( Event Manager / Admin )\r\n   */\r\n  async getParticipants(\r\n    eventID: string,\r\n    creatorID: string,\r\n  ): Promise<usersResource> {\r\n    try {\r\n      const event = await Event.findById(eventID).exec();\r\n      if (!event) throw new Error(\"Event not found\");\r\n      const creator = await User.findById(event.creator).exec();\r\n      const user = await User.findById(creatorID);\r\n      if (\r\n        !creator ||\r\n        !user ||\r\n        (creator.id !== creatorID && !user.isAdministrator)\r\n      ) {\r\n        throw new Error(\"Invalid authorization\");\r\n      }\r\n      const participantIDs = event.participants;\r\n      const participants = await User.find({\r\n        _id: { $in: participantIDs },\r\n      }).exec();\r\n      const result: usersResource = {\r\n        users: participants.map((user) => ({\r\n          id: user.id,\r\n          name: user.name,\r\n          email: user.email,\r\n          isAdministrator: user.isAdministrator,\r\n          address: user.address,\r\n          profilePicture: user.profilePicture,\r\n          birthDate: user.birthDate,\r\n          gender: user.gender,\r\n          socialMediaUrls: user.socialMediaUrls,\r\n          isActive: user.isActive,\r\n        })),\r\n      };\r\n      return result;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting participants\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event bearbeiten ( Event Manager / Admin )\r\n   */\r\n  async updateEvent(\r\n    eventID: string,\r\n    eventResource: eventResource,\r\n    userID: string\r\n  ): Promise<eventResource> {\r\n    const event = await Event.findById(eventID).exec();\r\n    if (!event) throw new Error(\"Event not found\");\r\n    const creator = await User.findById(event.creator).exec();\r\n    const user = await User.findById(userID).exec();\r\n    if (\r\n      !creator ||\r\n      !user ||\r\n      (creator._id.toString() !== userID && !user.isAdministrator)\r\n    ) {\r\n      throw new Error(\"Invalid authorization\");\r\n    }\r\n    if (eventResource.name) event.name = eventResource.name;\r\n    if (eventResource.description)\r\n      event.description = eventResource.description;\r\n    if (eventResource.price !== undefined) {\r\n      if (eventResource.price < 0) {\r\n        throw new Error(\"Event price cannot be less than 0\");\r\n      } else if (eventResource.price === 0) {\r\n        event.price = 0;\r\n      } else {\r\n        event.price = eventResource.price;\r\n      }\r\n    }\r\n    if (eventResource.date) event.date = eventResource.date;\r\n    if (eventResource.address) event.address = eventResource.address;\r\n    if (eventResource.thumbnail) event.thumbnail = eventResource.thumbnail;\r\n    if (eventResource.hashtags) event.hashtags = eventResource.hashtags;\r\n    if (eventResource.category) event.category = eventResource.category;\r\n    const savedEvent = await event.save();\r\n    return {\r\n      id: savedEvent.id,\r\n      name: savedEvent.name,\r\n      creator: savedEvent.creator.toString(),\r\n      description: savedEvent.description,\r\n      price: savedEvent.price,\r\n      date: savedEvent.date,\r\n      address: savedEvent.address,\r\n      thumbnail: savedEvent.thumbnail,\r\n      hashtags: savedEvent.hashtags,\r\n      category: savedEvent.category,\r\n      chat: savedEvent.chat.toString(),\r\n      participants: savedEvent.participants.map((participantId) =>\r\n        participantId.toString()\r\n      ),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Event löschen ( Event Manager / Admin )\r\n   */\r\n  async deleteEvent(eventID: string, userID: string): Promise<boolean> {\r\n    try {\r\n      const event = await Event.findById(eventID).exec();\r\n      if (!event) throw new Error(\"Event not found\");\r\n      const creator = await User.findById(event.creator).exec();\r\n      const user = await User.findById(userID).exec();\r\n      if (\r\n        !creator ||\r\n        !user ||\r\n        (creator._id.toString() !== userID && !user.isAdministrator)\r\n      ) {\r\n        throw new Error(\"Invalid authorization\");\r\n      }\r\n      const result = await Event.deleteOne({ _id: eventID }).exec();\r\n      return result.deletedCount == 1;\r\n    } catch (error) {\r\n      throw new Error(\"Error deleting event\");\r\n    }\r\n  }\r\n}\r\n\r\nexport default new EventService();\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\model\\EventModel.ts",{"fileContent":"import { Model, Schema, Types, model } from \"mongoose\";\r\nimport { IAddress, addressSchema } from \"./UserModel\";\r\n\r\nexport interface IEvent {\r\n  name: string;\r\n  creator: Types.ObjectId;\r\n  description: string;\r\n  price: number;\r\n  date: Date;\r\n  address: IAddress;\r\n  thumbnail?: string;\r\n  hashtags?: string[];\r\n  category: ICategory[];\r\n  chat: Types.ObjectId;\r\n  participants: Types.ObjectId[];\r\n}\r\n\r\nexport interface ICategory {\r\n  name: string;\r\n  description: string;\r\n}\r\n\r\nconst categorySchema = new Schema<ICategory>({\r\n  name: { type: String, required: true/* , unique: true */ },\r\n  description: { type: String },\r\n});\r\n\r\ntype EventModel = Model<IEvent, {}>;\r\ntype CategoryModel = Model<ICategory, {}>;\r\n\r\nconst eventSchema = new Schema<IEvent>({\r\n  name: { type: String, required: true },\r\n  creator: { type: Schema.Types.ObjectId, ref: \"User\", required: true },\r\n  description: { type: String, required: true },\r\n  price: { type: Number, required: true, min: 0 },\r\n  date: { type: Date, required: true },\r\n  address: addressSchema,\r\n  thumbnail: { type: String },\r\n  hashtags: [{ type: String }],\r\n  category: [categorySchema],\r\n  chat: { type: Schema.Types.ObjectId, ref: \"Chat\", required: true },\r\n  participants: [{ type: Schema.Types.ObjectId, ref: \"User\", required: true }],\r\n});\r\n\r\n/* \r\nZu implementieren?:\r\nMiddleware-Methode, die sicherstellt, dass nach Bearbeitung eines Events, alle Teilnehmer benachrichtigt werden\r\n\r\neventSchema.post('updateOne', async function (result, next) {\r\n    try {\r\n        //Funktion zur Benachrichtigung aller Teilnehmer\r\n    } catch (error) {\r\n        //throw new Error()\r\n    }\r\n    next();\r\n}); */\r\n\r\nexport const Event = model<IEvent, EventModel>(\"Event\", eventSchema);\r\nexport const Categoty = model<ICategory, CategoryModel>(\r\n  \"Category\",\r\n  categorySchema,\r\n);\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\model\\UserModel.ts",{"fileContent":"import mongoose, { Model, model, Schema, Query } from \"mongoose\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nexport interface IUser {\r\n  email: string;\r\n  name: {\r\n    first: string;\r\n    last: string;\r\n  };\r\n  password: string;\r\n  isAdministrator: Boolean;\r\n  address: IAddress;\r\n  profilePicture?: string;\r\n  birthDate: Date;\r\n  gender: string;\r\n  socialMediaUrls?: {\r\n    facebook?: string;\r\n    instagram?: string;\r\n  };\r\n  isActive: boolean;\r\n}\r\n\r\nexport interface IAddress {\r\n  street: String;\r\n  houseNumber: String;\r\n  apartmentNumber?: String;\r\n  postalCode: String;\r\n  city: String;\r\n  stateOrRegion?: String;\r\n  country: String;\r\n}\r\n\r\nexport enum userRole {\r\n  User = \"u\",\r\n  Admin = \"a\",\r\n}\r\ninterface IUserMethods {\r\n  isCorrectPassword(password: string): Promise<boolean>;\r\n}\r\ntype UserModel = Model<IUser, {}, IUserMethods>;\r\n\r\n/**\r\n * Adressen werden später in das UserSchema eingefügt und als teil eines Users in mongoDB gespeichert\r\n */\r\nexport const addressSchema = new Schema({\r\n  street: { type: String, required: true },\r\n  houseNumber: { type: String, required: true },\r\n  apartmentNumber: String,\r\n  postalCode: { type: String, required: true },\r\n  city: { type: String, required: true },\r\n  stateOrRegion: String,\r\n  country: { type: String, required: true },\r\n});\r\n\r\nconst userSchema = new Schema<IUser, UserModel>({\r\n  email: { type: String, required: true, unique: true },\r\n  name: {\r\n    first: { type: String, required: true },\r\n    last: { type: String, required: true },\r\n  },\r\n  password: { type: String, required: true },\r\n  isAdministrator: { type: Boolean, default: false },\r\n  address: addressSchema,\r\n  profilePicture: String,\r\n  birthDate: { type: Date, required: true },\r\n  gender: { type: String, required: true },\r\n  socialMediaUrls: {\r\n    facebook: String,\r\n    instagram: String,\r\n  },\r\n  isActive: { type: Boolean, default: true },\r\n});\r\n\r\nuserSchema.pre(\"save\", async function () {\r\n  if (this.isModified(\"password\")) {\r\n    const hashedPassword = await bcrypt.hash(this.password, 10);\r\n    this.password = hashedPassword;\r\n  }\r\n});\r\n\r\nuserSchema.pre(\r\n  \"updateOne\",\r\n  { document: false, query: true },\r\n  async function () {\r\n    const update = this.getUpdate() as\r\n      | (Query<any, IUser> & { password?: string })\r\n      | null;\r\n    if (update?.password != null) {\r\n      const hashedPassword = await bcrypt.hash(update.password, 10);\r\n      update.password = hashedPassword;\r\n    }\r\n  },\r\n);\r\n\r\nuserSchema.method(\r\n  \"isCorrectPassword\",\r\n  async function (password: string): Promise<boolean> {\r\n    const isPW = await bcrypt.compare(password, this.password);\r\n    return isPW;\r\n  },\r\n);\r\n\r\nexport const User = model<IUser, UserModel>(\"User\", userSchema);\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\server.ts",{"fileContent":"import express, { Express, Request, Response } from \"express\";\r\nconst bodyParser = require(\"body-parser\");\r\nconst fs = require(\"fs\");\r\nconst cors = require(\"cors\");\r\nconst key = fs.readFileSync(\"./certificates/key.pem\");\r\nconst cert = fs.readFileSync(\"./certificates/cert.pem\");\r\nimport { connect } from \"./database/db\";\r\nimport createAdminUser from \"./src/utils/CreateAdminUser\";\r\nimport https from \"https\";\r\nconst http = require(\"http\");\r\nimport swaggerDocs from \"./src/utils/swagger\";\r\nimport UserRoute from \"./src/routes/UserRoute\";\r\nimport UsersRouter from \"./src/routes/UsersRouter\";\r\nimport loginRouter from \"./src/routes/login\";\r\nimport EventRouter from \"./src/routes/EventRoute\";\r\nconst app: Express = express();\r\nconst port = process.env.PORT || 443;\r\n/* Routes */\r\napp.use(\"*\", cors());\r\n\r\napp.use(function (req, res, next) {\r\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\r\n  res.header(\r\n    \"Access-Control-Allow-Headers\",\r\n    \"Origin, X-Requested-With, Content-Type, Accept\"\r\n  );\r\n  res.header(\"Access-Control-Expose-Headers\", \"Authorization\");\r\n  next();\r\n});\r\n\r\napp.use(bodyParser.json());\r\napp.use(express.urlencoded({ extended: true }));\r\napp.use(express.static(__dirname));\r\napp.use(\"/api/users\", UserRoute);\r\napp.use(\"/api\", UsersRouter);\r\napp.use(\"/api/login\", loginRouter);\r\napp.use(\"/api/events\", EventRouter);\r\nswaggerDocs(app, +port);\r\napp.use((req, res, next) => {\r\n  res.status(404).json(\"Not Found\");\r\n});\r\n\r\nconnect()\r\n  .then(async () => {\r\n    // Create admin user after connecting to the database\r\n    await createAdminUser();\r\n    let server = https.createServer({ key, cert }, app);\r\n    server.listen(port, () => {\r\n      console.log(\"Listening on port 443\");\r\n    });\r\n  })\r\n  .catch((err) => {\r\n    console.error(\"Failed to connect to the database:\", err);\r\n  });\r\n\r\nexport default app;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/package.json","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/FileUpload.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/Helpers.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\CreateAdminUser.ts",{"fileContent":"import { User, IAddress, IUser } from \"../model/UserModel\";\r\n\r\nconst createAdminUser = async () => {\r\n  const a: IAddress = {\r\n    street: \"Street\",\r\n    houseNumber: \"1\",\r\n    postalCode: \"12345\",\r\n    city: \"Berlin\",\r\n    country: \"Germany\",\r\n  };\r\n\r\n  let u: IUser = {\r\n    email: \"admin.team@connectandexplore.com\",\r\n    name: {\r\n      first: \"admin\",\r\n      last: \"team\",\r\n    },\r\n    password: \"k.9MSn#JJh+§3F3a\",\r\n    isAdministrator: true,\r\n    address: a,\r\n    birthDate: new Date(),\r\n    gender: \"male\",\r\n    isActive: true,\r\n    socialMediaUrls: {\r\n      facebook: \"facebook.com\",\r\n      instagram: \"instagram.com\",\r\n    },\r\n  };\r\n\r\n  try {\r\n    const user = await User.create(u);\r\n  } catch (error) {\r\n    console.error(\"Error creating admin user:\", error);\r\n  }\r\n};\r\nexport default createAdminUser;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\swagger.ts",{"fileContent":"// Copyrights Code: https://github.com/TomDoesTech/REST-API-Tutorial-Updated/blob/main/src/utils/swagger.ts\r\n\r\nimport { Express, Request, Response } from \"express\";\r\nimport swaggerJsdoc from \"swagger-jsdoc\";\r\nimport swaggerUi from \"swagger-ui-express\";\r\nimport { version } from \"../../package.json\";\r\n\r\nconst options: swaggerJsdoc.Options = {\r\n  definition: {\r\n    openapi: \"3.1.0\",\r\n    info: {\r\n      title: \"Explore and Connect REST API Docs\",\r\n      version,\r\n    },\r\n    components: {\r\n      securitySchemes: {\r\n        bearerAuth: {\r\n          type: \"http\",\r\n          scheme: \"bearer\",\r\n          bearerFormat: \"JWT\",\r\n        },\r\n      },\r\n      schemas: {\r\n        IAddress: {\r\n          type: \"object\",\r\n          properties: {\r\n            street: {\r\n              type: \"string\",\r\n            },\r\n            houseNumber: {\r\n              type: \"string\",\r\n            },\r\n            apartmentNumber: {\r\n              type: \"string\",\r\n            },\r\n            postalCode: {\r\n              type: \"string\",\r\n            },\r\n            city: {\r\n              type: \"string\",\r\n            },\r\n            stateOrRegion: {\r\n              type: \"string\",\r\n            },\r\n            country: {\r\n              type: \"string\",\r\n            },\r\n          },\r\n        },\r\n        ICategory: {\r\n          type: \"object\",\r\n          properties: {\r\n            name: {\r\n              type: \"string\",\r\n            },\r\n            description: {\r\n              type: \"string\",\r\n            },\r\n          },\r\n        },\r\n        IChat: {\r\n          type: \"object\",\r\n          properties: {\r\n            // Define IChat properties\r\n          },\r\n        },\r\n        IUser: {\r\n          type: \"object\",\r\n          properties: {\r\n            email: {\r\n              type: \"string\",\r\n            },\r\n            name: {\r\n              type: \"object\",\r\n              properties: {\r\n                first: {\r\n                  type: \"string\",\r\n                },\r\n                last: {\r\n                  type: \"string\",\r\n                },\r\n              },\r\n            },\r\n            password: {\r\n              type: \"string\",\r\n            },\r\n            isAdministrator: {\r\n              type: \"boolean\",\r\n            },\r\n            address: {\r\n              $ref: \"#/components/schemas/IAddress\",\r\n            },\r\n            profilePicture: {\r\n              type: \"string\",\r\n            },\r\n            birthDate: {\r\n              type: \"date\",\r\n              format: \"date\",\r\n            },\r\n            gender: {\r\n              type: \"string\",\r\n            },\r\n            socialMediaUrls: {\r\n              type: \"object\",\r\n              properties: {\r\n                facebook: {\r\n                  type: \"string\",\r\n                },\r\n                instagram: {\r\n                  type: \"string\",\r\n                },\r\n              },\r\n            },\r\n            isActive: {\r\n              type: \"boolean\",\r\n            },\r\n          },\r\n        },\r\n        IEvent: {\r\n          type: \"object\",\r\n          properties: {\r\n            name: {\r\n              type: \"string\",\r\n            },\r\n            creator: {\r\n              $ref: \"#/components/schemas/IUser\", // Reference to IUser schema\r\n            },\r\n            description: {\r\n              type: \"string\",\r\n            },\r\n            price: {\r\n              type: \"number\",\r\n              minimum: 0,\r\n            },\r\n            date: {\r\n              type: \"string\", // Date represented as string in ISO 8601 format\r\n              format: \"date-time\",\r\n            },\r\n            address: {\r\n              $ref: \"#/components/schemas/IAddress\",\r\n            },\r\n            thumbnail: {\r\n              type: \"string\",\r\n            },\r\n            hashtags: {\r\n              type: \"array\",\r\n              items: {\r\n                type: \"string\",\r\n              },\r\n            },\r\n            category: {\r\n              type: \"array\",\r\n              items: {\r\n                $ref: \"#/components/schemas/ICategory\",\r\n              },\r\n            },\r\n            chat: {\r\n              $ref: \"#/components/schemas/IChat\", // Reference to IChat schema\r\n            },\r\n            participants: {\r\n              type: \"array\",\r\n              items: {\r\n                type: \"string\", // Assuming participants are represented by strings (e.g., ObjectId as strings)\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n    security: [\r\n      {\r\n        bearerAuth: [],\r\n      },\r\n    ],\r\n  },\r\n  apis: [\"./src/routes/*.ts\", \"./src/model/*.ts\"],\r\n};\r\n\r\nconst swaggerSpec = swaggerJsdoc(options);\r\n\r\nfunction swaggerDocs(app: Express, port: number) {\r\n  // Swagger page\r\n  app.use(\"/swagger/docs\", swaggerUi.serve, swaggerUi.setup(swaggerSpec));\r\n\r\n  // Docs in JSON format\r\n  app.get(\"/docs.json\", (req: Request, res: Response) => {\r\n    res.setHeader(\"Content-Type\", \"application/json\");\r\n    res.send(swaggerSpec);\r\n  });\r\n\r\n  console.log(`Docs available at https://localhost:${port}/swagger/docs`);\r\n}\r\n\r\nexport default swaggerDocs;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/package.json"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\UserRoute.ts",{"fileContent":"import express from \"express\";\r\nimport fs from \"fs\";\r\nimport {\r\n  body,\r\n  check,\r\n  matchedData,\r\n  param,\r\n  validationResult,\r\n} from \"express-validator\";\r\nimport { UserService } from \"../services/UserService\";\r\nimport { upload, deleteProfilePicture } from \"../utils/FileUpload\";\r\nimport { validate } from \"../utils/Helpers\";\r\nimport { requiresAuthentication } from \"./authentication\";\r\nimport { userResource } from \"../Resources\";\r\nconst UserRouter = express.Router();\r\nconst userService = new UserService();\r\n\r\n/**\r\n * @swagger\r\n * /api/users/register:\r\n *   post:\r\n *     summary: Register a new user\r\n *     description: Register a new user with user data and an optional profile picture.\r\n *     tags:\r\n *       - User\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         multipart/form-data:\r\n *           schema:\r\n *              type: object\r\n *              properties:\r\n *                profilePicture:\r\n *                  type: string\r\n *                  example: []\r\n *                  format: binary\r\n *                email:\r\n *                  type: string\r\n *                  example: \"John@doe.com\"\r\n *                name[first]:\r\n *                  type: string\r\n *                  example: \"Test\"\r\n *                name[last]:\r\n *                  type: string\r\n *                  example: \"User\"\r\n *                password:\r\n *                  type: string\r\n *                  example: \"12abcAB!\"\r\n *                birthDate:\r\n *                  type: string\r\n *                  example: \"2000-01-01\"\r\n *                gender:\r\n *                  type: string\r\n *                  example: \"Male\"\r\n *                address[street]:\r\n *                  type: string\r\n *                  example: \"123 Test Street\"\r\n *                address[houseNumber]:\r\n *                  type: string\r\n *                  example: \"1\"\r\n *                address[apartmentNumber]:\r\n *                  type: string\r\n *                  example: \"123\"\r\n *                address[postalCode]:\r\n *                  type: string\r\n *                  example: \"12345\"\r\n *                address[city]:\r\n *                  type: string\r\n *                  example: \"Berlin\"\r\n *                address[stateOrRegion]:\r\n *                  type: string\r\n *                  example: \"Berlin\"\r\n *                address[country]:\r\n *                  type: string\r\n *                  example: \"DE\"\r\n *              required:\r\n *                - email\r\n *                - password\r\n *                - gender\r\n *                - birthDate\r\n *                - name[first]\r\n *                - name[last]\r\n *                - address[street]\r\n *                - address[houseNumber]\r\n *                - address[postalCode]\r\n *                - address[city]\r\n *                - address[country]\r\n *     responses:\r\n *       201:\r\n *         description: User registered successfully\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IUser'\r\n *       409:\r\n *         description: User already exists\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: User already exists\r\n *       500:\r\n *         description: Registration failed\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Registration failed\r\n */\r\nUserRouter.post(\r\n  \"/register\",\r\n  upload.single(\"profilePicture\"),\r\n  [\r\n    body(\"email\").isEmail(),\r\n    body(\"name.first\")\r\n      .isString()\r\n      .isLength({ min: 3, max: 100 })\r\n      .withMessage(\"First name is required.\"),\r\n    body(\"name.last\")\r\n      .isString()\r\n      .isLength({ min: 3, max: 100 })\r\n      .withMessage(\"Last name is required.\"),\r\n    body(\"password\").isStrongPassword(),\r\n    body(\"isAdministrator\").optional().isBoolean(),\r\n    body(\"address.street\")\r\n      .notEmpty()\r\n      .withMessage(\"Street address is required.\"),\r\n    body(\"address.houseNumber\")\r\n      .notEmpty()\r\n      .withMessage(\"House number is required.\"),\r\n    body(\"address.postalCode\")\r\n      .notEmpty()\r\n      .withMessage(\"Postal code is required.\"),\r\n    body(\"address.city\").notEmpty().withMessage(\"City is required.\"),\r\n    body(\"address.country\").notEmpty().withMessage(\"Country is required.\"),\r\n    body(\"address.stateOrRegion\")\r\n      .optional()\r\n      .isString()\r\n      .withMessage(\"Invalid State or Region.\"),\r\n    body(\"address.apartmentNumber\")\r\n      .optional()\r\n      .isString()\r\n      .withMessage(\"Invalid Apartment number.\"),\r\n    body(\"profilePicture\").optional().isString(),\r\n    body(\"birthDate\").isDate(),\r\n    body(\"gender\").isString().notEmpty(),\r\n    body(\"socialMediaUrls.facebook\").optional().isString(),\r\n    body(\"socialMediaUrls.instagram\").optional().isString(),\r\n  ],\r\n  async (req, res) => {\r\n    try {\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        if (req.file) {\r\n          // Delete the file\r\n          deleteProfilePicture(req.file.path);\r\n        }\r\n        return res.status(400).json({ errors: errors.array() });\r\n      } else {\r\n        if (req.file) {\r\n          req.body.profilePicture = `/uploads/${req.file.filename}`;\r\n        }\r\n        const newUser = await userService.registerUser(req.body);\r\n        return res.status(201).json(newUser);\r\n      }\r\n    } catch (error) {\r\n      if (error.message === \"User already exists\") {\r\n        return res.status(409).json({ Error: \"User already exists\" });\r\n      } else {\r\n        return res.status(500).json({ Error: \"Registration failed\" });\r\n      }\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/users/{userid}:\r\n *   get:\r\n *     summary: \"Get User\"\r\n *     deprecated: false\r\n *     description: \"Retrieve a user by ID\"\r\n *     tags:\r\n *       - \"User\"\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user to retrieve\"\r\n *     responses:\r\n *       \"200\":\r\n *         description: \"OK\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"403\":\r\n *         description: \"Forbidden - Invalid authorization\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Invalid authorization, cannot get User.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Invalid userID\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"No user with this ID exists.\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nUserRouter.get(\r\n  \"/:userid\",\r\n  requiresAuthentication,\r\n  param(\"userid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    const userid = req.params.userid;\r\n    if (req.role !== \"a\" && userid !== req.userId) {\r\n      res.status(403);\r\n      next(new Error(\"Invalid authorization, can not get User.\"));\r\n    } else {\r\n      try {\r\n        const user: userResource = await userService.getUser(userid);\r\n        res.status(200).json(user);\r\n      } catch (err) {\r\n        res.status(404);\r\n        next(err);\r\n      }\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/users/{userid}:\r\n *   put:\r\n *     summary: Update user details\r\n *     description: Update user details for a specific user.\r\n *     tags:\r\n *       - User\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user to update\"\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         multipart/form-data:\r\n *           schema:\r\n *             type: object\r\n *             properties:\r\n *               profilePicture:\r\n *                 type: string\r\n *                 example: []\r\n *                 format: binary\r\n *               email:\r\n *                 type: string\r\n *                 example: \"John@doe.com\"\r\n *               name[first]:\r\n *                     type: string\r\n *                     example: \"Test\"\r\n *               name[last]:\r\n *                     type: string\r\n *                     example: \"User\"\r\n *               password:\r\n *                 type: string\r\n *                 example: \"12abcAB!12abcAB!\"\r\n *               oldPassword:\r\n *                 type: string\r\n *                 example: \"12abcAB!\"\r\n *               birthDate:\r\n *                 type: string\r\n *                 example: \"2000-01-01\"\r\n *               gender:\r\n *                 type: string\r\n *                 example: \"Male\"\r\n *               address[street]:\r\n *                 type: string\r\n *                 example: \"123 Test Street\"\r\n *               address[houseNumber]:\r\n *                 type: string\r\n *                 example: \"1\"\r\n *               address[postalCode]:\r\n *                 type: string\r\n *                 example: \"12345\"\r\n *               address[city]:\r\n *                 type: string\r\n *                 example: \"Berlin\"\r\n *               address[country]:\r\n *                 type: string\r\n *                 example: \"DE\"\r\n *     responses:\r\n *       200:\r\n *         description: User details updated successfully\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IUser'\r\n *       403:\r\n *         description: Invalid authorization\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Invalid authorization, cannot update user\r\n *       404:\r\n *         description: User not found\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: User not found\r\n *       500:\r\n *         description: Update failed\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Update failed\r\n */\r\nUserRouter.put(\r\n  \"/:userid\",\r\n  requiresAuthentication,\r\n  upload.single(\"profilePicture\"),\r\n  [param(\"userid\").isMongoId()],\r\n  validate,\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      if (req.file) {\r\n        // Delete the file\r\n        deleteProfilePicture(req.file.path);\r\n      }\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    const userid = req.params.userid;\r\n    if (req.role === \"a\" || userid === req.userId) {\r\n      const user: userResource = await userService.getUser(userid);\r\n      try {\r\n        if (req.file) {\r\n          req.body.profilePicture = `/uploads/${req.file.filename}`;\r\n          if (user.profilePicture) {\r\n            deleteProfilePicture(user.profilePicture);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        deleteProfilePicture(req.body.profilePicture);\r\n        res.status(404).json({\r\n          Error: \"Can not delete Profile picture - no such file or directory\",\r\n        });\r\n      }\r\n    }\r\n    //req.body.name = JSON.parse(req.body.name);\r\n    const userResource = req.body as userResource; //matchedData(req) as userResource;\r\n    userResource.id = userid;\r\n    if (req.role === \"a\") {\r\n      try {\r\n        const updatedUser: userResource =\r\n          await userService.updateUserWithAdmin(userResource);\r\n        res.status(200).send(updatedUser);\r\n      } catch (err) {\r\n        res.status(404);\r\n        next(err);\r\n      }\r\n    } else {\r\n      if (req.userId !== userid) {\r\n        res.status(403);\r\n        next(new Error(\"Invalid authorization, can not update user.\"));\r\n      } else {\r\n        try {\r\n          let oldPw!: string;\r\n          if (req.body.oldPassword) {\r\n            oldPw = req.body.oldPassword;\r\n          }\r\n\r\n          const updatedUser = await userService.updateUserWithPw(\r\n            userResource,\r\n            oldPw,\r\n          );\r\n          res.status(200).send(updatedUser);\r\n        } catch (err) {\r\n          res.status(403);\r\n          next(new Error(\"Invalid authorization, probably invalid password.\"));\r\n        }\r\n      }\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/users/{userid}:\r\n *   delete:\r\n *     summary: \"Delete User\"\r\n *     deprecated: false\r\n *     description: \"Delete a user by ID\"\r\n *     tags:\r\n *       - \"User\"\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user to delete\"\r\n *     responses:\r\n *       \"204\":\r\n *         description: \"OK\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"403\":\r\n *         description: \"Forbidden - Invalid authorization\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Invalid authorization, cannot delete user.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Probably invalid userid\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Probably invalid userid, cannot delete user.\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\n\r\nUserRouter.delete(\r\n  \"/:userid\",\r\n  requiresAuthentication,\r\n  param(\"userid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const userid = req.params.userid;\r\n    try {\r\n      if (req.role === \"a\") {\r\n        const user: userResource = await userService.getUser(userid);\r\n        const isDeleted: boolean = await userService.deleteUser(userid, false);\r\n        try {\r\n          if (user.profilePicture) {\r\n            deleteProfilePicture(user.profilePicture);\r\n          }\r\n        } catch (err) {\r\n          res.status(404).json({\r\n            Error: \"Can not delete Profile picture - no such file or directory\",\r\n          });\r\n        }\r\n        res.status(204).send(isDeleted);\r\n      } else {\r\n        if (req.userId === userid) {\r\n          const user: userResource = await userService.getUser(userid);\r\n          const isDeleted: boolean = await userService.deleteUser(userid, true);\r\n          try {\r\n            if (user.profilePicture) {\r\n              deleteProfilePicture(user.profilePicture);\r\n            }\r\n          } catch (err) {\r\n            res.status(404).json({\r\n              Error:\r\n                \"Can not delete Profile picture - no such file or directory\",\r\n            });\r\n          }\r\n          res.status(204).send(isDeleted);\r\n        } else {\r\n          res.send(403);\r\n          next(new Error(\"Invalid authorization, can not delete user.\"));\r\n        }\r\n      }\r\n    } catch (err) {\r\n      res.send(404);\r\n      next(new Error(\"Probably invalid userid, can not delete user.\"));\r\n    }\r\n  },\r\n);\r\nexport default UserRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/FileUpload.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/Helpers.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\UserService.ts",{"fileContent":"import { User } from \"../model/UserModel\";\r\nimport { usersResource, userResource } from \"../Resources\";\r\nexport class UserService {\r\n  async registerUser(user: any) {\r\n    if (!user || typeof user !== \"object\") {\r\n      throw new Error(\"Invalid user data\");\r\n    }\r\n    // Check if the user already exists in the database\r\n    const { email } = user;\r\n    const existingUser = await User.findOne({ email });\r\n\r\n    if (existingUser) {\r\n      throw new Error(\"User already exists\");\r\n    }\r\n    // Create a new user\r\n    try {\r\n      const newUser = await User.create(user);\r\n      return newUser;\r\n    } catch (error) {\r\n      throw new Error(\"Registration failed\");\r\n    }\r\n  }\r\n\r\n  async getUsers(): Promise<usersResource> {\r\n    const users = await User.find({}).exec();\r\n    const usersResource: usersResource = {\r\n      users: users.map((user) => ({\r\n        id: user.id,\r\n        name: user.name,\r\n        email: user.email,\r\n        isAdministrator: user.isAdministrator,\r\n        address: user.address,\r\n        profilePicture: user.profilePicture,\r\n        birthDate: user.birthDate,\r\n        gender: user.gender,\r\n        socialMediaUrls: user.socialMediaUrls,\r\n        isActive: user.isActive,\r\n      })),\r\n    };\r\n    return usersResource;\r\n  }\r\n\r\n  async getUser(userID: string): Promise<userResource> {\r\n    if (!userID) {\r\n      throw new Error(\"Can not get user, userID is invalid\");\r\n    }\r\n    const user = await User.findOne({ _id: userID, isActive: true }).exec();\r\n    if (!user) {\r\n      throw new Error(`No user with id: ${userID} exists.`);\r\n    }\r\n    return {\r\n      id: user.id,\r\n      name: user.name,\r\n      email: user.email,\r\n      isAdministrator: user.isAdministrator,\r\n      address: user.address,\r\n      profilePicture: user.profilePicture,\r\n      birthDate: user.birthDate,\r\n      gender: user.gender,\r\n      socialMediaUrls: user.socialMediaUrls,\r\n      isActive: user.isActive,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * used to prefill db with standard admin user. Therefore this servicemethod does not need an endpoint.\r\n   * @param userResource\r\n   * @returns userResource\r\n   */\r\n  async createUser(userResource: userResource): Promise<userResource> {\r\n    const user = await User.create({\r\n      name: userResource.name,\r\n      email: userResource.email,\r\n      isAdministrator: userResource.isAdministrator,\r\n      address: userResource.address,\r\n      password: userResource.password,\r\n      profilePicture: userResource.profilePicture,\r\n      birthDate: userResource.birthDate,\r\n      gender: userResource.gender,\r\n      socialMediaUrls: userResource.socialMediaUrls,\r\n    });\r\n\r\n    return {\r\n      id: user.id,\r\n      name: user.name,\r\n      email: user.email,\r\n      isAdministrator: user.isAdministrator,\r\n      address: user.address,\r\n      profilePicture: user.profilePicture,\r\n      birthDate: user.birthDate,\r\n      gender: user.gender,\r\n      socialMediaUrls: user.socialMediaUrls,\r\n      isActive: user.isActive,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Admin function to update userdata. can update password & isAdministrator.\r\n   * @param userResource\r\n   * @returns userResource of updated user.\r\n   */\r\n  async updateUserWithAdmin(userResource: userResource): Promise<userResource> {\r\n    if (!userResource.id) {\r\n      throw new Error(\"User id is missing, cannot update User.\");\r\n    }\r\n    const user = await User.findById(userResource.id).exec();\r\n    if (!user) {\r\n      throw new Error(\r\n        `No user with id: ${userResource.id} found, cannot update`,\r\n      );\r\n    }\r\n    if (userResource.name) user.name = userResource.name;\r\n    if (userResource.email) {\r\n      userResource.email = userResource.email;\r\n      if (userResource.email !== user.email) {\r\n        const c = await User.count({ email: userResource.email }).exec();\r\n        if (c > 0) {\r\n          throw new Error(`Duplicate email`);\r\n        }\r\n      }\r\n      user.email = userResource.email;\r\n    }\r\n    if (userResource.password) user.password = userResource.password;\r\n    if (userResource.isAdministrator)\r\n      user.isAdministrator = userResource.isAdministrator;\r\n    if (userResource.address) user.address = userResource.address;\r\n    if (userResource.birthDate) user.birthDate = userResource.birthDate;\r\n    if (userResource.gender) user.gender = userResource.gender;\r\n    if (userResource.profilePicture)\r\n      user.profilePicture = userResource.profilePicture;\r\n    if (userResource.socialMediaUrls)\r\n      user.socialMediaUrls = userResource.socialMediaUrls;\r\n    if (userResource.isActive) user.isActive = userResource.isActive;\r\n    const savedUser = await user.save();\r\n    return {\r\n      id: savedUser.id,\r\n      name: savedUser.name,\r\n      email: savedUser.email,\r\n      address: savedUser.address,\r\n      isAdministrator: savedUser.isAdministrator,\r\n      birthDate: savedUser.birthDate,\r\n      gender: savedUser.gender,\r\n      socialMediaUrls: savedUser.socialMediaUrls,\r\n      isActive: savedUser.isActive,\r\n      profilePicture: savedUser.profilePicture,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * only admins can change isAdministrator:\r\n   * authorization to change isAdministrator is done in userRouter ->\r\n   * isAdministratorfield = null if user in req is not an admin\r\n   * @param userResource\r\n   * @param oldPw\r\n   * @returns userResource\r\n   */\r\n  async updateUserWithPw(\r\n    userResource: userResource,\r\n    oldPw?: string,\r\n  ): Promise<userResource> {\r\n    if (!userResource.id) {\r\n      throw new Error(\"User id is missing, cannot update User.\");\r\n    }\r\n    const user = await User.findById(userResource.id).exec();\r\n    if (!user) {\r\n      throw new Error(\r\n        `No user with id: ${userResource.id} found, cannot update`,\r\n      );\r\n    }\r\n    if (oldPw) {\r\n      const res = await user.isCorrectPassword(oldPw);\r\n      if (!res) {\r\n        throw new Error(\"invalid oldPassword, can not update User!\");\r\n      }\r\n      if (userResource.password) user.password = userResource.password;\r\n    }\r\n    if (userResource.name?.first) user.name.first = userResource.name.first;\r\n    if (userResource.name?.last) user.name.last = userResource.name.last;\r\n    if (userResource.email) {\r\n      userResource.email = userResource.email;\r\n      if (userResource.email !== user.email) {\r\n        const c = await User.count({ email: userResource.email }).exec();\r\n        if (c > 0) {\r\n          throw new Error(`Duplicate email`);\r\n        }\r\n      }\r\n      user.email = userResource.email;\r\n    }\r\n    if (userResource.address) user.address = userResource.address;\r\n    if (userResource.birthDate) user.birthDate = userResource.birthDate;\r\n    if (userResource.gender) user.gender = userResource.gender;\r\n    if (userResource.profilePicture)\r\n      user.profilePicture = userResource.profilePicture;\r\n    if (userResource.socialMediaUrls)\r\n      user.socialMediaUrls = userResource.socialMediaUrls;\r\n    const savedUser = await user.save();\r\n    return {\r\n      id: savedUser.id,\r\n      name: savedUser.name,\r\n      email: savedUser.email,\r\n      address: savedUser.address,\r\n      isAdministrator: savedUser.isAdministrator,\r\n      birthDate: savedUser.birthDate,\r\n      gender: savedUser.gender,\r\n      socialMediaUrls: savedUser.socialMediaUrls,\r\n      isActive: user.isActive,\r\n      profilePicture: savedUser.profilePicture,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This function is used to either disable a user account or to delete the account from the database.\r\n   * If the logged-in user is an admin (role in req.role === \"a\") and performs the \"delete\" endpoint request,\r\n   * inactivateAccount is set to false, and the user is deleted from the database.\r\n   * Otherwise, the user himself deactivates his account, and inactivateAccount is set to true.\r\n   * @param userID The ID of the user to be deactivated or deleted.\r\n   * @param inactivateAccount If true, user.isActive is set to false and the user object remains in the database; otherwise, the admin deletes the user from the database.\r\n   * @returns true if the user was deleted or inactivated, false if no user was deleted.\r\n   */\r\n  async deleteUser(\r\n    userID: string,\r\n    inactivateAccount: boolean,\r\n  ): Promise<boolean> {\r\n    if (!userID) {\r\n      throw new Error(\"invalid userID, can not delete/inactivate account\");\r\n    }\r\n    const u = await User.findOne({ _id: userID }).exec();\r\n    if (!u) {\r\n      throw new Error(\r\n        \"User not found, probably invalid userID or user is already deleted\",\r\n      );\r\n    }\r\n    if (inactivateAccount) {\r\n      u.isActive = false;\r\n      const user = await u.save();\r\n      return !user.isActive;\r\n    } else {\r\n      const res = await User.deleteOne({ _id: userID });\r\n      return res.deletedCount == 1;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new UserService();\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\FileUpload.ts",{"fileContent":"import multer from \"multer\";\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n//Copyright of script: https://medium.com/@bviveksingh96/uploading-images-files-with-multer-in-node-js-f942e9319600\r\nconst storage = multer.diskStorage({\r\n  destination: function (req, file, cb) {\r\n    cb(null, path.join(__dirname, \"/uploads/\"));\r\n  },\r\n\r\n  filename: function (req: any, file: any, cb: any) {\r\n    const uniqueFilename = `${uuidv4()}-${file.originalname}`;\r\n    cb(null, uniqueFilename);\r\n  },\r\n});\r\nconst fileFilter = (req: any, file: any, cb: any) => {\r\n  if (\r\n    file.mimetype === \"image/jpg\" ||\r\n    file.mimetype === \"image/jpeg\" ||\r\n    file.mimetype === \"image/png\"\r\n  ) {\r\n    cb(null, true);\r\n  } else {\r\n    cb(new Error(\"Image uploaded is not of type jpg/jpeg or png\"), false);\r\n  }\r\n};\r\nexport function deleteProfilePicture(filename: string): void {\r\n  try {\r\n    const filePath = path.join(__dirname, filename);\r\n    fs.unlinkSync(filePath);\r\n  } catch (error) {\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport function deleteEventThumbnail(filename: string): void {\r\n  /* try {\r\n    const filePath = path.join(__dirname, filename);\r\n    fs.unlinkSync(filePath);\r\n    console.log(`Deleted event thumbnail: ${filename}`);\r\n  } catch (error) {\r\n    console.error(`Error deleting event thumbnail: ${filename}`, error);\r\n    throw error;\r\n  } */\r\n}\r\n\r\n// file size : 10 MB limit\r\nexport const upload = multer({\r\n  storage: storage,\r\n  fileFilter: fileFilter,\r\n  limits: { fileSize: 10 * 1024 * 1024 },\r\n});\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\Helpers.ts",{"fileContent":"import { IUser } from \"../model/UserModel\";\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport { validationResult, body } from \"express-validator\";\r\n\r\nconst validateIfPresent = (field: string, validators: any) => {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    // Check if the field exists in the request body and has a value\r\n    // && req.body[field] !== \"\"\r\n    if (req.body[field] !== undefined) {\r\n      return validators(req, res, next);\r\n    }\r\n    // If the field is absent or empty, skip the validation\r\n    return next();\r\n  };\r\n};\r\n\r\n// Validation middleware\r\nexport const validate = [\r\n  validateIfPresent(\"email\", body(\"email\").isEmail()),\r\n  validateIfPresent(\"name.first\", body(\"name.first\").isString()),\r\n  validateIfPresent(\"name.last\", body(\"name.last\").isString()),\r\n  validateIfPresent(\"password\", body(\"password\").isStrongPassword()),\r\n  validateIfPresent(\"isAdministrator\", body(\"isAdministrator\").isBoolean()),\r\n\r\n  //validateIfPresent(\"oldPassword\", body(\"oldPassword\").isStrongPassword()),\r\n  validateIfPresent(\"address.street\", body(\"address.street\").isString()),\r\n  validateIfPresent(\r\n    \"address.houseNumber\",\r\n    body(\"address.houseNumber\")\r\n      .isNumeric()\r\n      .withMessage(\"houseNumber is required.\")\r\n  ),\r\n  validateIfPresent(\r\n    \"address.postalCode\",\r\n    body(\"address.postalCode\")\r\n      .isNumeric()\r\n      .withMessage(\"Postal code is required.\")\r\n  ),\r\n  validateIfPresent(\r\n    \"address.city\",\r\n    body(\"address.city\").isString().withMessage(\"City is required.\")\r\n  ),\r\n  validateIfPresent(\r\n    \"address.country\",\r\n    body(\"address.country\").isString().withMessage(\"Country is required.\")\r\n  ),\r\n  validateIfPresent(\r\n    \"address.stateOrRegion\",\r\n    body(\"address.stateOrRegion\")\r\n      .isString()\r\n      .withMessage(\"invalid State or Region.\"),\r\n  ),\r\n  validateIfPresent(\r\n    \"address.appartmentNumber\",\r\n    body(\"address.appartmentNumber\")\r\n      .isString()\r\n      .withMessage(\"invalid Appartmentnumber.\"),\r\n  ),\r\n  validateIfPresent(\"profilePicture\", body(\"profilePicture\").isString()),\r\n  validateIfPresent(\"birthDate\", body(\"birthDate\").isString()),\r\n  validateIfPresent(\"gender\", body(\"gender\").isString()),\r\n  validateIfPresent(\r\n    \"socialMediaUrls.facebook\",\r\n    body(\"socialMediaUrls.facebook\").isString(),\r\n  ),\r\n  validateIfPresent(\r\n    'socialMediaUrls.instagram\"',\r\n    body(\"socialMediaUrls.instagram\").isString(),\r\n  ),\r\n];\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\authentication.ts",{"fileContent":"import { NextFunction, Request, Response } from \"express\";\r\nimport { verifyJWT } from \"../services/JWTService\";\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    /**\r\n     * Wir erweitern das Interface `Request` um die Felder `userId` und `role`.\r\n     */\r\n    export interface Request {\r\n      /**\r\n       * Mongo-ID of currently logged in user; or undefined, if user is a guest.\r\n       */\r\n      userId?: string;\r\n      role: \"u\" | \"a\";\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Prüft Authentifizierung und schreibt `userId` mit Mongo-ID des Users und `role` mit Kürzel der Rolle in den Request.\r\n * Falls Authentifizierung fehlschlägt, wird ein Fehler (401) erzeugt.\r\n */\r\nexport async function requiresAuthentication(\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction,\r\n) {\r\n  try {\r\n    const authorization = req.headers.authorization;\r\n    if (authorization && authorization.startsWith(\"Bearer \")) {\r\n      const token = authorization.substring(\"Bearer \".length);\r\n      const { userId, role } = verifyJWT(token);\r\n      if (!userId || !role) {\r\n        res.status(401);\r\n        return next(new Error(\"Authentication Failed\"));\r\n      }\r\n      req.userId = userId;\r\n      req.role = role;\r\n      next();\r\n    } else {\r\n      res.status(401);\r\n      res.setHeader(\"WWW-Authenticate\", [\"Bearer\", 'realm=\"app\"']);\r\n      next(new Error(\"authentication required!\"));\r\n    }\r\n  } catch (err) {\r\n    res.status(401);\r\n    res.setHeader(\"WWW-Authenticate\", [\r\n      \"Bearer\",\r\n      'realm=\"app\"',\r\n      'error=\"invalid_token\"',\r\n    ]);\r\n    next(err);\r\n  }\r\n}\r\n\r\n/**\r\n * Prüft Authentifizierung und schreibt `userId` mit Mongo-ID des Users und `role` mit Kürzel der Rolle in den Request.\r\n * Falls kein JSON-Web-Token im Request-Header vorhanden ist, wird kein Fehler erzeugt (und auch nichts in den Request geschrieben).\r\n * Falls Authentifizierung fehlschlägt, wird ein Fehler (401) erzeugt.\r\n */\r\nexport async function optionalAuthentication(\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction,\r\n) {\r\n  const authorization = req.headers.authorization;\r\n  if (authorization) {\r\n    try {\r\n      const token = authorization.split(\" \")[1];\r\n      const { userId, role } = verifyJWT(token);\r\n      if (!userId || !role) {\r\n        res.status(401);\r\n        return next(new Error(\"Authentication Failed\"));\r\n      }\r\n      req.userId = userId;\r\n      req.role = role;\r\n      next();\r\n    } catch (err) {\r\n      res.status(401);\r\n      next(err);\r\n    }\r\n  } else {\r\n    next();\r\n  }\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\JWTService.ts",{"fileContent":"import { JwtPayload, sign, verify } from \"jsonwebtoken\";\r\nimport { User } from \"../model/UserModel\";\r\nimport dotenv from \"dotenv\";\r\ndotenv.config();\r\n/**\r\n * @param email E-Mail-Adresse des Users\r\n * @param password Das Passwort des Users\r\n * @returns JWT als String, im JWT ist sub gesetzt mit der Mongo-ID des Users als String sowie role mit \"u\" oder \"a\" (User oder Admin);\r\n *      oder undefined wenn Authentifizierung fehlschlägt.\r\n */\r\nexport async function verifyPasswordAndCreateJWT(\r\n  email: string,\r\n  password: string,\r\n): Promise<string | undefined> {\r\n  const users = await User.find({ email: email, isActive: true }).exec();\r\n  if (!users || users.length != 1) {\r\n    return undefined;\r\n  }\r\n  const user = users[0];\r\n  if (!(await user.isCorrectPassword(password))) {\r\n    return undefined;\r\n  }\r\n\r\n  const secret = process.env.JWT_SECRET;\r\n  if (!secret) {\r\n    throw new Error(\"JWT_SECRET not set\");\r\n  }\r\n  const timeInSec = Math.floor(Date.now() / 1000);\r\n\r\n  const ttl = process.env.JWT_TTL;\r\n  if (!ttl) {\r\n    throw new Error(\"TTL not set\");\r\n  }\r\n\r\n  const exp = timeInSec + parseInt(ttl);\r\n  const role = user.isAdministrator ? \"a\" : \"u\";\r\n\r\n  const payload: JwtPayload = {\r\n    sub: user.id,\r\n    iat: timeInSec,\r\n    exp: exp,\r\n    role: role,\r\n  };\r\n  const jwtString = sign(payload, secret, { algorithm: \"HS256\" });\r\n  return jwtString;\r\n}\r\n\r\n/**\r\n * Gibt user id (Mongo-ID) und ein Kürzel der Rolle zurück, falls Verifizierung erfolgreich, sonst wird ein Error geworfen.\r\n *\r\n * Die zur Prüfung der Signatur notwendige Passphrase wird aus der Umgebungsvariable `JWT_SECRET` gelesen,\r\n * falls diese nicht gesetzt ist, wird ein Fehler geworfen.\r\n *\r\n * @param jwtString das JWT\r\n * @return user id des Users (Mongo ID als String) und Rolle (u oder a) des Benutzers;\r\n *      niemals undefined (bei Fehler wird ein Error geworfen)\r\n */\r\nexport function verifyJWT(jwtString: string | undefined): {\r\n  userId: string;\r\n  role: \"u\" | \"a\";\r\n} {\r\n  if (!jwtString) {\r\n    throw new Error(\"No JWT-string\");\r\n  }\r\n  const secret = process.env.JWT_SECRET;\r\n  if (!secret) {\r\n    throw new Error(\"JWT_SECRET not set\");\r\n  }\r\n  try {\r\n    const payload = verify(jwtString, secret);\r\n    if (typeof payload === \"object\" && \"sub\" in payload && payload.sub) {\r\n      const result = { userId: payload.sub?.toString()!, role: payload.role };\r\n      return result;\r\n    }\r\n  } catch (err) {\r\n    throw new Error(\"verify_error\");\r\n  }\r\n  throw new Error(\"invalid_token\");\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\UsersRouter.ts",{"fileContent":"import express from \"express\";\r\nimport { UserService } from \"../services/UserService\";\r\nimport { requiresAuthentication } from \"./authentication\";\r\nimport { usersResource } from \"../Resources\";\r\n\r\nconst UsersRouter = express.Router();\r\nconst userService = new UserService();\r\n/**\r\n * @swagger\r\n * /api/users/:\r\n *   get:\r\n *     summary: \"Get Users\"\r\n *     deprecated: false\r\n *     description: \"Retrieve all users\"\r\n *     tags:\r\n *       - \"User\"\r\n *     responses:\r\n *       \"200\":\r\n *         description: \"OK\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"403\":\r\n *         description: \"Forbidden - Invalid authorization\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Invalid authorization.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Users not found\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Users not found.\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nUsersRouter.get(\"/users\", requiresAuthentication, async (req, res, next) => {\r\n  if (req.role !== \"a\") {\r\n    res.status(403);\r\n    next(new Error(\"Invalid authorization\"));\r\n  } else {\r\n    try {\r\n      const users: usersResource = await userService.getUsers();\r\n      res.status(200).send(users);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n});\r\n\r\nexport default UsersRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\login.ts",{"fileContent":"import express from \"express\";\r\nimport { body, matchedData, validationResult } from \"express-validator\";\r\nimport { LoginResource } from \"../Resources\";\r\nimport { verifyPasswordAndCreateJWT } from \"../services/JWTService\";\r\n\r\nconst loginRouter = express.Router();\r\n/**\r\n * @swagger\r\n * /api/login/:\r\n *  \"post\":\r\n *    \"summary\": \"Login user\"\r\n *    \"description\": \"Endpoint to log in a user\"\r\n *    \"tags\": [\r\n *      \"User\"\r\n *    ]\r\n *    \"parameters\": []\r\n *    \"requestBody\":\r\n *      \"content\":\r\n *        \"application/json\":\r\n *          \"schema\":\r\n *            \"type\": \"object\"\r\n *            \"properties\":\r\n *              \"email\":\r\n *                \"type\": \"string\"\r\n *              \"password\":\r\n *                \"type\": \"string\"\r\n *            \"required\":\r\n *              - \"email\"\r\n *              - \"password\"\r\n *          \"example\":\r\n *            \"email\": \"John@doe.com\"\r\n *            \"password\": \"12abcAB!\"\r\n *    \"responses\":\r\n *      \"200\":\r\n *        \"description\": \"OK\"\r\n *        \"content\":\r\n *          \"application/json\":\r\n *            \"schema\":\r\n *              \"type\": \"object\"\r\n *              \"properties\": {}\r\n *      \"400\":\r\n *        \"description\": \"Bad Request - Validation Error\"\r\n *        \"content\":\r\n *          \"application/json\":\r\n *            \"schema\":\r\n *              \"type\": \"object\"\r\n *              \"properties\":\r\n *                \"error\":\r\n *                  \"type\": \"string\"\r\n *                  \"example\": \"Validation failed: Please provide a valid email and password.\"\r\n *      \"401\":\r\n *        \"description\": \"Unauthorized - Missing JWT\"\r\n *        \"content\":\r\n *          \"application/json\":\r\n *            \"schema\":\r\n *              \"type\": \"object\"\r\n *              \"properties\":\r\n *                \"error\":\r\n *                  \"type\": \"string\"\r\n *                  \"example\": \"Unauthorized: No JWT token provided.\"\r\n *    \"security\":\r\n *      - \"bearerAuth\": []\r\n */\r\n/**\r\n * Diese Funktion bitte noch nicht implementieren, sie steht hier als Platzhalter.\r\n * Wir benötigen dafür Authentifizierungsinformationen, die wir später in einem JSW speichern.\r\n */\r\nloginRouter.post(\r\n  \"/\",\r\n  body(\"email\").isEmail(),\r\n  body(\"password\").isStrongPassword(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    //const loginResource = matchedData(req) as LoginResource;\r\n    const resource = matchedData(req);\r\n    const jwtstring = await verifyPasswordAndCreateJWT(\r\n      resource.email,\r\n      resource.password,\r\n    );\r\n    if (!jwtstring) {\r\n      res.status(401);\r\n      next(new Error(\"no jwtstring\"));\r\n    }\r\n    const result: LoginResource = {\r\n      access_token: jwtstring!,\r\n      token_type: \"Bearer\",\r\n    };\r\n    res.send(result);\r\n  },\r\n);\r\n\r\nexport default loginRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\EventRoute.ts",{"fileContent":"import express from \"express\";\r\nimport { EventService } from \"../services/EventService\";\r\nimport {\r\n  optionalAuthentication,\r\n  requiresAuthentication,\r\n} from \"./authentication\";\r\nimport { eventResource, eventsResource } from \"../Resources\";\r\nimport {\r\n  body,\r\n  matchedData,\r\n  param,\r\n  query,\r\n  validationResult,\r\n} from \"express-validator\";\r\nimport { deleteEventThumbnail, upload } from \"../utils/FileUpload\";\r\n\r\nconst EventRouter = express.Router();\r\nconst eventService = new EventService();\r\n\r\n/**\r\n * @swagger\r\n * /api/events/search:\r\n *   get:\r\n *     summary: \"Search for events\"\r\n *     description: \"Search events based on a query string\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"query\"\r\n *         in: \"query\"\r\n *         required: true\r\n *         schema:\r\n *           type: \"string\"\r\n *         description: \"The query string to search for events\"\r\n *     responses:\r\n *       200:\r\n *         description: \"Successful response\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: \"#/components/schemas/IEvent\"\r\n *       204:\r\n *         description: \"No events found matching the query\"\r\n *       400:\r\n *         description: \"Bad request. Validation error in the query string\"\r\n *       404:\r\n *         description: \"Not found. The requested resource does not exist\"\r\n *       500:\r\n *         description: \"Internal server error\"\r\n */\r\nEventRouter.get(\r\n  \"/search\",\r\n  optionalAuthentication,\r\n  [query(\"query\").isString().notEmpty()],\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    try {\r\n      const term = req.query.query as string;\r\n      const events: eventsResource = await eventService.searchEvents(term);\r\n      if (events.events.length === 0) {\r\n        return res\r\n          .status(204)\r\n          .json({ message: \"No events found matching the query.\" });\r\n      }\r\n      res.status(200).send(events);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n\r\n/**\r\n * @swagger\r\n * paths:\r\n *  /api/events/create:\r\n *    post:\r\n *     summary: Create a new event\r\n *     description: Register a new event with event data and an optional event pictures.\r\n *     tags:\r\n *       - Event\r\n *     security:\r\n *       - bearerAuth: []\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         application/json:\r\n *           schema:\r\n *              type: object\r\n *              properties:\r\n *                name:\r\n *                  type: string\r\n *                  example: \"Test Event\"\r\n *                price:\r\n *                  type: number\r\n *                  example: 0\r\n *                description:\r\n *                  type: string\r\n *                  example: \"Test Event description\"\r\n *                date:\r\n *                  type: string\r\n *                  format: date\r\n *                  example: \"2000-01-01\"\r\n *                address[street]:\r\n *                  type: string\r\n *                  example: \"123 Test Street\"\r\n *                address[houseNumber]:\r\n *                  type: string\r\n *                  example: \"1\"\r\n *                address[apartmentNumber]:\r\n *                  type: string\r\n *                  example: \"123\"\r\n *                address[postalCode]:\r\n *                  type: string\r\n *                  example: \"12345\"\r\n *                address[city]:\r\n *                  type: string\r\n *                  example: \"Berlin\"\r\n *                address[stateOrRegion]:\r\n *                  type: string\r\n *                  example: \"Berlin\"\r\n *                address[country]:\r\n *                  type: string\r\n *                  example: \"DE\"\r\n *                thumbnail:\r\n *                  type: string\r\n *                  example: []\r\n *                  format: binary\r\n *                hashtags:\r\n *                  type: array\r\n *                  items:\r\n *                    type: string\r\n *                  example: [\"sport\", \"freizeit\"]\r\n *                category:\r\n *                  type: array\r\n *                  items:\r\n *                    type: object\r\n *                    properties:\r\n *                      name:\r\n *                        type: string\r\n *                        example: \"Hobbys\"\r\n *                      description:\r\n *                        type: string\r\n *                        example: \"persönliche Interessen, Freizeit\"\r\n *              required:\r\n *                - name\r\n *                - price\r\n *                - description\r\n *                - date\r\n *                - name[first]\r\n *                - name[last]\r\n *                - address[street]\r\n *                - address[houseNumber]\r\n *                - address[postalCode]\r\n *                - address[city]\r\n *                - address[country]\r\n *                - category\r\n *     responses:\r\n *       201:\r\n *         description: Event created successfully\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IEvent'\r\n *       400:\r\n *         description: Bad request, validation error\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Bad request, validation error\r\n *       500:\r\n *         description: Internal server error\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Creating new event failed\r\n */\r\n\r\nEventRouter.post(\r\n  \"/create\",\r\n  requiresAuthentication,\r\n  upload.single(\"thumbnail\"),\r\n  [\r\n    body(\"name\").isString().notEmpty().withMessage(\"Event name is required.\"),\r\n    //body(\"creator\").isString().notEmpty(),\r\n    body(\"price\").isNumeric().notEmpty(),\r\n    body(\"description\")\r\n      .isString()\r\n      .notEmpty()\r\n      .withMessage(\"Description is required.\"),\r\n    body(\"date\") /* .isDate() */\r\n      .notEmpty(),\r\n    body(\"address.street\")\r\n      .notEmpty()\r\n      .withMessage(\"Street address is required.\"),\r\n    body(\"address.houseNumber\")\r\n      .notEmpty()\r\n      .withMessage(\"House number is required.\"),\r\n    body(\"address.postalCode\")\r\n      .notEmpty()\r\n      .withMessage(\"Postal code is required.\"),\r\n    body(\"address.city\").notEmpty().withMessage(\"City is required.\"),\r\n    body(\"address.country\").notEmpty().withMessage(\"Country is required.\"),\r\n    body(\"address.stateOrRegion\")\r\n      .optional()\r\n      .isString()\r\n      .withMessage(\"Invalid State or Region.\"),\r\n    body(\"address.apartmentNumber\")\r\n      .optional()\r\n      .isString()\r\n      .withMessage(\"Invalid Apartment number.\"),\r\n    body(\"thumbnail\").optional().isString(),\r\n    body(\"hashtags\").optional().isArray(),\r\n    body(\"category\")\r\n      .isArray()\r\n      .notEmpty()\r\n      .withMessage(\"Categories are required.\"),\r\n    //body(\"chat\").isString().notEmpty(),\r\n  ],\r\n  async (req, res) => {\r\n    try {\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        if (req.file) {\r\n          // Delete the file\r\n          deleteEventThumbnail(req.file.path);\r\n        }\r\n        return res.status(400).json({ errors: errors.array() });\r\n      } else {\r\n        if (req.file) {\r\n          req.body.thumbnail = `/uploads/${req.file.filename}`;\r\n        }\r\n        const newEvent = await eventService.createEvent(req.body, req.userId);\r\n        return res.status(201).send(newEvent);\r\n      }\r\n    } catch (err) {\r\n      return res.status(500).json({ Error: \"Event creation failed\" });\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}/join:\r\n *   post:\r\n *     summary: \"Join an event\"\r\n *     deprecated: false\r\n *     description: \"The User can join event\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to join\"\r\n *     responses:\r\n *       \"200\":\r\n *         description: \"User joined the event successfully\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"409\":\r\n *         description: \"User is already participating in the event\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"User is already participating in the event.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Invalid userID\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"No user or event with this ID exists.\"\r\n *       \"500\":\r\n *         description: \"Joining event failed\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Joining event failed\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.post(\r\n  \"/:eventid/join\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      await eventService.joinEvent(req.userId, req.params.eventid);\r\n      res.status(200).json({ message: \"User joined the event successfully\" });\r\n    } catch (err) {\r\n      if (err.message === \"User not found\") {\r\n        return res.status(404).json({ Error: err.message });\r\n      } else if (err.message === \"Event not found\") {\r\n        return res.status(404).json({ Error: err.message });\r\n      } else if (err.message === \"User is already participating in the event\") {\r\n        return res.status(409).json({ Error: err.message });\r\n      } else {\r\n        return res.status(500).json({ Error: \"Joining event failed\" });\r\n      }\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}/cancel:\r\n *   delete:\r\n *     summary: \"Cancel participating in event\"\r\n *     deprecated: false\r\n *     description: \"Canceling of participating in event\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to cancel participating in\"\r\n *     responses:\r\n *       \"204\":\r\n *         description: \"User canceled the participating in the event successfully\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"409\":\r\n *         description: \"User is not participating in the event or Can not cancel participation as event manager\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"User is not participating in the event or Can not cancel participation as event manager\"\r\n *       \"500\":\r\n *         description: \"Canceling event failed\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Canceling event failed\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.delete(\r\n  \"/:eventid/cancel\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      await eventService.cancelEvent(req.userId, req.params.eventid);\r\n      res.status(204).send();\r\n    } catch (err) {\r\n      if (\r\n        err.message === \"User is not participating in the event\" ||\r\n        err.message === \"Can not cancel participation as event manager\"\r\n      ) {\r\n        return res.status(409).json({ Error: err.message });\r\n      } else {\r\n        return res.status(500).json({ Error: \"Canceling event failed\" });\r\n      }\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/joined:\r\n *   get:\r\n *     summary: \"Get all joined events\"\r\n *     deprecated: false\r\n *     description: \"Retrieve all participated events ( Event participant )\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     responses:\r\n *       '200':\r\n *         description: Returns all joined events\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 events:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/IEvent'\r\n *       '204':\r\n *         description: No events found\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 message:\r\n *                   type: string\r\n *       '404':\r\n *         description: Not found\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.get(\"/joined\", requiresAuthentication, async (req, res, next) => {\r\n  try {\r\n    const events: eventsResource = await eventService.getJoinedEvents(\r\n      req.userId\r\n    );\r\n    if (events.events.length === 0) {\r\n      return res.status(204).json({ message: \"No events found.\" });\r\n    }\r\n    res.status(200).send(events);\r\n  } catch (err) {\r\n    res.status(404);\r\n    next(err);\r\n  }\r\n});\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}/participants:\r\n *   get:\r\n *     summary: \"Retrieve all participants in event\"\r\n *     deprecated: false\r\n *     description: \"Retrieve a list of all participants in event\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to cancel participating in\"\r\n *     responses:\r\n *       200:\r\n *         description: \"Successful response\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"array\"\r\n *               items:\r\n *                 type: \"string\"\r\n *                 description: \"User ID of a participant\"\r\n *       404:\r\n *         description: \"Event not found or no participants found for the specified event\"\r\n *       500:\r\n *         description: \"Internal server error\"\r\n */\r\nEventRouter.get(\r\n  \"/:eventid/participants\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const participants = await eventService.getParticipants(\r\n        req.params.eventid,\r\n        req.userId,\r\n      );\r\n      res.status(200).send(participants);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}:\r\n *   get:\r\n *     summary: \"Retrieve information of an event\"\r\n *     deprecated: false\r\n *     description: \"Retrieve all data of Event with eventid\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to retrieve the event data\"\r\n *     responses:\r\n *       200:\r\n *         description: \"Successful response\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *               $ref: '#/components/schemas/IEvent'\r\n *       400:\r\n *         description: \"Validation error\"\r\n *       404:\r\n *         description: \"Event not found for the specified event\"\r\n *       500:\r\n *         description: \"Internal server error\"\r\n */\r\nEventRouter.get(\r\n  \"/:eventid\",\r\n  optionalAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    try {\r\n      const event = await eventService.getEvent(req.params.eventid);\r\n      res.status(200).send(event);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n\r\nEventRouter.put(\r\n  \"/:eventid\",\r\n  requiresAuthentication,\r\n  upload.single(\"thumbnail\"),\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      if (req.file) {\r\n        // Delete the file\r\n        deleteEventThumbnail(req.file.path);\r\n      }\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    try {\r\n      const event = await eventService.getEvent(req.params.eventid);\r\n      if (req.file) {\r\n        req.body.thumbnail = `/uploads/${req.file.filename}`;\r\n        if (event.thumbnail) deleteEventThumbnail(event.thumbnail);\r\n      }\r\n      const eventResource = req.body as eventResource;\r\n      const updatedEvent = await eventService.updateEvent(\r\n        req.params.eventid,\r\n        eventResource,\r\n        req.userId\r\n      );\r\n      res.status(200).send(updatedEvent);\r\n    } catch (err) {\r\n      deleteEventThumbnail(req.body.thumbnail);\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}:\r\n *   delete:\r\n *     summary: \"Delete event\"\r\n *     deprecated: false\r\n *     description: \"Deleting event with eventID as an event manager or admin\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to delete\"\r\n *     responses:\r\n *       \"204\":\r\n *         description: \"Event successfully deleted\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"405\":\r\n *         description: \"Event could not be deleted\"\r\n *       \"404\":\r\n *         description: \"Event not found\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.delete(\r\n  \"/:eventid\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const event = await eventService.getEvent(req.params.eventid);\r\n      const deleted = await eventService.deleteEvent(\r\n        req.params.eventid,\r\n        req.userId,\r\n      );\r\n      if (event.thumbnail) deleteEventThumbnail(event.thumbnail);\r\n      if (deleted) {\r\n        res.status(204).json({ message: \"Event successfully deleted\" });\r\n      } else {\r\n        res.status(405).json({ error: \"Event could not be deleted\" });\r\n      }\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/creator/{userid}:\r\n *   get:\r\n *     summary: Get all created events of a user\r\n *     deprecated: false\r\n *     description: \"Retrieve all events created by a user where the user is an admin or retrieve events associated with the authenticated user.\"\r\n *     tags:\r\n *       - Event\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user\"\r\n *     security:\r\n *       - bearerAuth: []\r\n *     responses:\r\n *       '200':\r\n *         description: Returns all created events\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 events:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/IEvent'\r\n *       '204':\r\n *         description: No events found\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 message:\r\n *                   type: string\r\n *       '403':\r\n *         description: Invalid authorization\r\n *       '404':\r\n *         description: Not found\r\n */\r\nEventRouter.get(\r\n  \"/creator/:userid\",\r\n  requiresAuthentication,\r\n  param(\"userid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    if (req.role === \"a\" || req.params.userid === req.userId) {\r\n      try {\r\n        const userID = req.params.userid;\r\n        const events: eventsResource = await eventService.getEvents(userID);\r\n        if (events.events.length === 0) {\r\n          return res.status(204).json({ message: \"No events found.\" });\r\n        }\r\n        res.status(200).send(events);\r\n      } catch (err) {\r\n        res.status(404);\r\n        next(err);\r\n      }\r\n    } else {\r\n      res.status(403);\r\n      next(new Error(\"Invalid authorization\"));\r\n    }\r\n  },\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/:\r\n *   get:\r\n *     summary: Get all events\r\n *     tags:\r\n *       - Event\r\n *     security:\r\n *       - bearerAuth: []\r\n *     responses:\r\n *       '200':\r\n *         description: Returns all events\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 events:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/IEvent'\r\n *       '204':\r\n *         description: No events found\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 message:\r\n *                   type: string\r\n *       '404':\r\n *         description: Not found\r\n */\r\nEventRouter.get(\"/\", optionalAuthentication, async (req, res, next) => {\r\n  try {\r\n    const events: eventsResource = await eventService.getAllEvents();\r\n    if (events.events.length === 0) {\r\n      return res.status(204).json({ message: \"No events found.\" });\r\n    }\r\n    res.status(200).send(events);\r\n  } catch (err) {\r\n    res.status(404);\r\n    next(err);\r\n  }\r\n});\r\n\r\nexport default EventRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/FileUpload.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\routes\\UserRoute.test.ts",{"fileContent":"import mongoose from \"mongoose\";\r\nimport { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport app from \"../../server\";\r\n//import { req } from \"../jest.setup\";\r\nimport { IAddress, User } from \"../../src/model/UserModel\";\r\nimport {\r\n  LoginResource,\r\n  userResource,\r\n  usersResource,\r\n} from \"../../src/Resources\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\nimport request from \"supertest\";\r\nconst a: IAddress = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  //profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst JaneData: userResource = {\r\n  email: \"Jane@doe.com\",\r\n  name: {\r\n    first: \"Jane\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  // profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\nlet admin: userResource;\r\nlet AdminToken: string;\r\nlet jane: userResource;\r\nlet token: string;\r\nlet req = request(app);\r\ndescribe(\"userRoute test\", () => {\r\n  beforeAll(async () => await connect());\r\n  beforeEach(async () => {\r\n    admin = await userService.createUser(u);\r\n    jane = await userService.createUser(JaneData);\r\n    //const req = request(app);\r\n    const adminloginData = { email: \"John@doe.com\", password: \"12abcAB!\" };\r\n    const adminRes = await req.post(`/api/login`).send(adminloginData);\r\n    const AdminLoginResource = adminRes.body as LoginResource;\r\n    AdminToken = AdminLoginResource.access_token;\r\n\r\n    const janeLoginData = { email: \"Jane@doe.com\", password: \"12abcAB!\" };\r\n    const janeRes = await req.post(`/api/login`).send(janeLoginData);\r\n    const janeLoginResource = janeRes.body as LoginResource;\r\n    token = janeLoginResource.access_token;\r\n  });\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => {\r\n    await mongoose.connection.close(); // Perform final cleanup after all tests\r\n  });\r\n\r\n  test(\"getUsers\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(\"/api/users\")\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(200);\r\n    const users: usersResource = response.body;\r\n    expect(users.users.length).toBe(3);\r\n    let userPos: number;\r\n    if (users.users[0].name.first === u.name.first) {\r\n      userPos = 0;\r\n    } else if (users.users[1].name.first === u.name.first) {\r\n      userPos = 1;\r\n    } else if (users.users[2].name.first === u.name.first) {\r\n      userPos = 2;\r\n    }\r\n    expect(users.users[userPos].id).toBeDefined();\r\n    expect(users.users[userPos].name.first).toBe(u.name.first);\r\n    expect(users.users[userPos].name.last).toBe(u.name.last);\r\n    expect(users.users[userPos].email).toBe(u.email);\r\n    expect(users.users[userPos].password).toBeUndefined();\r\n    expect(users.users[userPos].address).toMatchObject(a);\r\n    //expect(users.users[0].birthDate).toBe(u.birthDate);\r\n    expect(users.users[userPos].gender).toBe(u.gender);\r\n    expect(users.users[userPos].isActive).toBeTruthy();\r\n    //expect(users.users[0].profilePicture).toBe(u.profilePicture);\r\n    expect(users.users[userPos].socialMediaUrls).toMatchObject(\r\n      u.socialMediaUrls\r\n    );\r\n  });\r\n\r\n  test(\"getUsers fails on request by non-admin\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(\"/api/users\")\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(response.statusCode).toBe(403);\r\n  });\r\n\r\n  test(\"get User request responses with 404 on invalid userID\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(`/api/users/${NON_EXISTING_ID}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n\r\n    expect(response.statusCode).toBe(404);\r\n  });\r\n\r\n  test(\"get User request responses with 400 on undefined userID\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(`/api/users/invalidID`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n\r\n    expect(response.statusCode).toBe(400);\r\n    expect(response.body.errors).toBeDefined();\r\n  });\r\n\r\n  test(\"get User returns any user when performed by an admin and returns user when performed by non-admin\", async () => {\r\n    const response = await req\r\n      .get(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(200);\r\n    expect(response.body.name.first).toBe(jane.name.first);\r\n\r\n    const res = await req\r\n      .get(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(200);\r\n    expect(res.body.name.first).toBe(jane.name.first);\r\n  });\r\n\r\n  test(\"put user successfully updates user in db and returns updated user information\", async () => {\r\n    const newName = \"newName\";\r\n    jane.name.last = newName;\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(jane)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(200);\r\n    expect(res.body.name.last).toBe(newName);\r\n\r\n    const janeDataFromDB = await User.findById(jane.id).exec();\r\n    expect(janeDataFromDB.name.last).toBe(newName);\r\n\r\n    const updatedName = \"newName-adminUpdate\";\r\n    jane.name.last = updatedName;\r\n    const response = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(jane)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.body.name.last).toBe(updatedName);\r\n\r\n    const janeDataFromDBAdminUpdate = await User.findById(jane.id).exec();\r\n    expect(janeDataFromDBAdminUpdate.name.last).toBe(updatedName);\r\n  });\r\n\r\n  test(\"should return error on updating email to duplicate email\", async () => {\r\n    jane.email = admin.email;\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(jane)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.statusCode).toBe(404);\r\n  });\r\n\r\n  test(\"should return error on trying to update other users as non-admin\", async () => {\r\n    admin.name.first = \"newName\";\r\n    const res = await req\r\n      .put(`/api/users/${admin.id}`)\r\n      .send(admin)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(403);\r\n  });\r\n\r\n  test(\"testing for validation errors on put user route\", async () => {\r\n    const invalidUserResource: userResource = {\r\n      email: \"\",\r\n      name: {\r\n        first: \"\",\r\n        last: \"\",\r\n      },\r\n      isAdministrator: false,\r\n      address: a,\r\n      birthDate: jane.birthDate,\r\n      gender: \"\",\r\n      isActive: true,\r\n    };\r\n\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(invalidUserResource)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(400);\r\n    expect(res.body.errors).toBeDefined();\r\n  });\r\n\r\n  test(\"put user with invalid old password returns error\", async () => {\r\n    const requestData = jane;\r\n    requestData.oldPassword = \"invalidPW123!\";\r\n    requestData.password = \"newStrongPassword123!\";\r\n\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(requestData)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(403);\r\n\r\n    const dbJane = await User.findById(jane.id).exec();\r\n    expect(await dbJane.isCorrectPassword(\"newPassowrd\")).toBeFalsy();\r\n  });\r\n\r\n  test(\"should allow an admin to delete any user\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(204);\r\n  });\r\n\r\n  test(\"should allow a user to inactivate their own account\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(response.statusCode).toBe(204);\r\n  });\r\n\r\n  test(\"should prevent a non-admin user from deleting another user\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${admin.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(response.statusCode).toBe(403);\r\n  });\r\n\r\n  test(\"should return an error for an invalid user ID\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${NON_EXISTING_ID}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(404);\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/server.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\services\\EventService.test.ts",{"fileContent":"import { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  addressResource,\r\n  categoryResource,\r\n  eventResource,\r\n  eventsResource,\r\n  userResource,\r\n  usersResource,\r\n} from \"../../src/Resources\";\r\nimport { Event } from \"../../src/model/EventModel\";\r\nimport { User } from \"../../src/model/UserModel\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\n\r\nconst a: addressResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst eventService: EventService = new EventService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\n\r\ndescribe(\"EventService Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create event\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    expect(event.id).toBeDefined();\r\n    expect(event.name).toBe(e.name);\r\n    expect(event.creator).toBeDefined;\r\n    expect(event.description).toBe(e.description);\r\n    expect(event.price).toBe(e.price);\r\n    expect(event.date).toBe(e.date);\r\n    expect(event.address).toMatchObject(a);\r\n    expect(event.thumbnail).toBe(e.thumbnail);\r\n    expect(event.hashtags).toStrictEqual(e.hashtags);\r\n    expect(event.category.map((c) => c.name)).toContain(\"Hobbys\");\r\n    expect(event.chat).toBeDefined();\r\n    expect(event.participants.length).toBe(1);\r\n    // identical event data should still work\r\n    const event1 = await eventService.createEvent(e, user.id);\r\n    expect(event1).toBeDefined();\r\n    expect(event1.id).not.toBe(event.id);\r\n    expect(event1.name).toBe(event.name);\r\n    expect(event1.creator).toBe(event.creator);\r\n    expect(event1.description).toBe(event.description);\r\n    expect(event1.price).toBe(event.price);\r\n    expect(event1.date).toBe(event.date);\r\n    expect(event1.thumbnail).toBe(event.thumbnail);\r\n    expect(event1.hashtags).toStrictEqual(event.hashtags);\r\n    expect(event1.chat).not.toBe(event.chat);\r\n    expect(event.participants.length).toBe(event.participants.length);\r\n  });\r\n\r\n  test(\"get event\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    await expect(eventService.getEvent(undefined)).rejects.toThrow();\r\n    await expect(eventService.getEvent(NON_EXISTING_ID)).rejects.toThrow();\r\n    const er = await eventService.getEvent(event.id);\r\n    const em = await Event.findById(event.id);\r\n    expect(er.id).toBe(em.id);\r\n    expect(er.name).toBe(em.name);\r\n    expect(er.creator).toBeDefined();\r\n    expect(er.description).toBe(em.description);\r\n    expect(er.price).toBe(em.price);\r\n    expect(er.date).toStrictEqual(em.date);\r\n    expect(er.address).toMatchObject(a);\r\n    expect(er.thumbnail).toBe(em.thumbnail);\r\n    expect(er.hashtags).toStrictEqual(em.hashtags);\r\n    expect(er.category.map((c) => c.name)).toContain(\"Hobbys\");\r\n    expect(er.chat).toBeDefined;\r\n    expect(er.participants.length).toBe(1);\r\n  });\r\n\r\n  test(\"get created events\", async () => {\r\n    await expect(eventService.getEvents(undefined)).rejects.toThrow();\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    await eventService.createEvent(e, user1.id);\r\n    await eventService.createEvent(e1, user1.id);\r\n    await eventService.createEvent(e2, user2.id);\r\n    const events = await eventService.getEvents(user1.id);\r\n    expect(events.events.length).toBe(2);\r\n    expect(events.events[0].name).toBe(\"Sample Event\");\r\n    expect(events.events[1].name).toBe(\"Sample Event 1\");\r\n  });\r\n\r\n  test(\"get all events\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    await eventService.createEvent(e, user1.id);\r\n    await eventService.createEvent(e1, user1.id);\r\n    await eventService.createEvent(e2, user2.id);\r\n    const events = await eventService.getAllEvents();\r\n    expect(events.events.length).toBe(3);\r\n    expect(events.events[0].name).toBe(\"Sample Event\");\r\n    expect(events.events[1].name).toBe(\"Sample Event 1\");\r\n    expect(events.events[2].name).toBe(\"Sample Event 2\");\r\n  });\r\n\r\n  test(\"search events\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    await eventService.createEvent(e, user1.id);\r\n    await eventService.createEvent(e1, user1.id);\r\n    await eventService.createEvent(e2, user2.id);\r\n    let events: eventsResource;\r\n    // search events by name\r\n    events = await eventService.searchEvents(\"sample event\");\r\n    expect(events.events.length).toBe(3);\r\n    expect(events.events[0].name).toBe(\"Sample Event\");\r\n    expect(events.events[1].name).toBe(\"Sample Event 1\");\r\n    expect(events.events[2].name).toBe(\"Sample Event 2\");\r\n    events = await eventService.searchEvents(\"Sample Event 2\");\r\n    expect(events.events.length).toBe(1);\r\n    expect(events.events[0].name).toBe(\"Sample Event 2\");\r\n    events = await eventService.searchEvents(\"event sample\");\r\n    expect(events.events.length).toBe(0);\r\n    events = await eventService.searchEvents(\"\");\r\n    expect(events.events.length).toBe(3);\r\n    events = await eventService.searchEvents(undefined);\r\n    expect(events.events.length).toBe(3);\r\n    // search events by description\r\n    events = await eventService.searchEvents(\"this is my\");\r\n    expect(events.events.length).toBe(2);\r\n    expect(events.events[0].description).toBe(\"This is my first event\");\r\n    expect(events.events[1].description).toBe(\"this is my second gym party\");\r\n    events = await eventService.searchEvents(\"for anyone\");\r\n    expect(events.events.length).toBe(1);\r\n    expect(events.events[0].description).toBe(\"for anyone interested\");\r\n    events = await eventService.searchEvents(\"this is my third event\");\r\n    expect(events.events.length).toBe(0);\r\n    // search events by hashtags\r\n    events = await eventService.searchEvents(\"sport\");\r\n    expect(events.events.length).toBe(1);\r\n    expect(events.events[0].hashtags[0]).toBe(\"sport\");\r\n    events = await eventService.searchEvents(\"freizeit\");\r\n    expect(events.events.length).toBe(2);\r\n    expect(events.events[0].hashtags[1]).toBe(\"freizeit\");\r\n    expect(events.events[1].hashtags[0]).toBe(\"freizeit\");\r\n    events = await eventService.searchEvents(\"sport freizeit\");\r\n    expect(events.events.length).toBe(0);\r\n  });\r\n\r\n  test(\"join event\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const event2 = await eventService.createEvent(e2, user2.id);\r\n    let result: eventResource;\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(1);\r\n    expect(result.participants[0]).toBe(user2.id);\r\n    expect(await eventService.joinEvent(user1.id, event2.id)).toBeTruthy();\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    expect(result.participants[0]).toBe(user2.id);\r\n    expect(result.participants[1]).toBe(user1.id);\r\n    expect(await eventService.joinEvent(user2.id, event1.id)).toBeTruthy();\r\n    result = await eventService.getEvent(event1.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    // invalid/no id\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.joinEvent(user1.id, id)).rejects.toThrow(\r\n      \"Event not found\"\r\n    );\r\n    await expect(eventService.joinEvent(id, event1.id)).rejects.toThrow(\r\n      \"User not found\"\r\n    );\r\n    result = await eventService.getEvent(event1.id);\r\n    await expect(result.participants).toHaveLength(2);\r\n    await expect(\r\n      eventService.joinEvent(undefined, undefined)\r\n    ).rejects.toThrow();\r\n    // user already participating\r\n    await expect(eventService.joinEvent(user1.id, event2.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    await expect(eventService.joinEvent(user1.id, event1.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    await expect(eventService.joinEvent(user2.id, event1.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    await expect(eventService.joinEvent(user2.id, event2.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    result = await eventService.getEvent(event1.id);\r\n    expect(result.participants).toHaveLength(2);\r\n  });\r\n\r\n  test(\"get joined events\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    const user3 = await User.create(u2);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const event2 = await eventService.createEvent(e2, user1.id);\r\n    await eventService.joinEvent(user2.id, event1.id);\r\n    await eventService.joinEvent(user2.id, event2.id);\r\n    let result: eventsResource;\r\n    result = await eventService.getJoinedEvents(user2.id);\r\n    expect(result.events).toHaveLength(2);\r\n    expect(result.events[0].name).toBe(\"Sample Event 1\");\r\n    expect(result.events[1].name).toBe(\"Sample Event 2\");\r\n    result = await eventService.getJoinedEvents(user3.id);\r\n    expect(result.events).toHaveLength(0);\r\n  });\r\n\r\n  test(\"cancel event\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    const user3 = await User.create(u2);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const event2 = await eventService.createEvent(e2, user2.id);\r\n    let result: eventResource;\r\n    await eventService.joinEvent(user1.id, event2.id);\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    // invalid/no id\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.cancelEvent(user1.id, id)).rejects.toThrow(\r\n      \"Event not found\"\r\n    );\r\n    await expect(eventService.cancelEvent(id, event1.id)).rejects.toThrow();\r\n    await expect(\r\n      eventService.cancelEvent(undefined, undefined)\r\n    ).rejects.toThrow();\r\n    // user not participating\r\n    await expect(eventService.cancelEvent(user3.id, event2.id)).rejects.toThrow(\r\n      \"User is not participating in the event\"\r\n    );\r\n    // cancel participation works correctly\r\n    expect(await eventService.cancelEvent(user1.id, event2.id)).toBeTruthy();\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(1);\r\n    // cancel participation as event creator should not work\r\n    await expect(eventService.cancelEvent(user1.id, event1.id)).rejects.toThrow(\r\n      \"Can not cancel participation as event manager\"\r\n    );\r\n    result = await eventService.getEvent(event1.id);\r\n    expect(result.participants).toHaveLength(1);\r\n    expect(result.creator).toBe(user1.id);\r\n  });\r\n\r\n  test(\"get participants of event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    let participants: usersResource;\r\n    // as event creator\r\n    participants = await eventService.getParticipants(event.id, user.id);\r\n    expect(participants.users).toHaveLength(1);\r\n    expect(participants.users[0].id).toBe(user.id);\r\n    await eventService.joinEvent(user1.id, event.id);\r\n    await eventService.joinEvent(user2.id, event.id);\r\n    participants = await eventService.getParticipants(event.id, user.id);\r\n    expect(participants.users).toHaveLength(3);\r\n    expect(participants.users[1].id).toBe(user1.id);\r\n    expect(participants.users[2].id).toBe(user2.id);\r\n    // not event creator but admin should work\r\n    participants = await eventService.getParticipants(event.id, user1.id);\r\n    expect(participants.users).toHaveLength(3);\r\n    // invalid authorization\r\n    await expect(\r\n      eventService.getParticipants(event.id, user2.id)\r\n    ).rejects.toThrow();\r\n    // participant count decreases after cancel participation\r\n    await eventService.cancelEvent(user1.id, event.id);\r\n    await eventService.cancelEvent(user2.id, event.id);\r\n    participants = await eventService.getParticipants(event.id, user.id);\r\n    expect(participants.users).toHaveLength(1);\r\n    expect(participants.users[0].id).toBe(user.id);\r\n  });\r\n\r\n  test(\"delete event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    let event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    let result: boolean;\r\n    result = await eventService.deleteEvent(event.id, user.id);\r\n    expect(result).toBeTruthy();\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n    // invalid/no id\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.deleteEvent(id, undefined)).rejects.toThrow();\r\n    await expect(eventService.deleteEvent(undefined, id)).rejects.toThrow();\r\n    // not event creator but admin should work\r\n    event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    result = await eventService.deleteEvent(event.id, user1.id);\r\n    expect(result).toBeTruthy();\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n    // invalid authorization\r\n    event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    await expect(\r\n      eventService.deleteEvent(event.id, user2.id)\r\n    ).rejects.toThrow();\r\n    expect(await eventService.getEvent(event.id)).toBeDefined();\r\n  });\r\n\r\n  test(\"update event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    expect(event.name).toBe(\"Sample Event\");\r\n    await eventService.updateEvent(event.id, e1, user.id);\r\n    const newevent = await eventService.getEvent(event.id);\r\n    // event updated correctly\r\n    expect(newevent).toBeDefined();\r\n    expect(newevent.id).toBe(event.id);\r\n    expect(newevent.name).toBe(\"Sample Event 1\");\r\n    expect(newevent.creator).toBe(event.creator);\r\n    expect(newevent.description).toBe(e1.description);\r\n    expect(newevent.price).toBe(e1.price);\r\n    expect(newevent.date).toStrictEqual(e1.date);\r\n    expect(newevent.address).toMatchObject(a);\r\n    expect(newevent.thumbnail).toBe(event.thumbnail);\r\n    expect(newevent.hashtags).toStrictEqual(event.hashtags);\r\n    expect(newevent.category.length).toBe(1);\r\n    expect(newevent.chat).toBe(event.chat);\r\n    expect(newevent.participants).toStrictEqual(event.participants);\r\n    // invalid/no data/ids\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.updateEvent(id, e1, user.id)).rejects.toThrow();\r\n    await expect(eventService.updateEvent(event.id, e1, id)).rejects.toThrow();\r\n    await expect(\r\n      eventService.updateEvent(event.id, undefined, user.id)\r\n    ).rejects.toThrow();\r\n    await expect(\r\n      eventService.updateEvent(undefined, undefined, undefined)\r\n    ).rejects.toThrow();\r\n    // not event creator but admin should work\r\n    const result = await eventService.updateEvent(event.id, e2, user1.id);\r\n    // eventresource returned correctly\r\n    expect(result).toBeDefined();\r\n    expect(result.id).toBe(event.id);\r\n    expect(result.name).toBe(\"Sample Event 2\");\r\n    expect(result.creator).toBe(event.creator);\r\n    expect(result.description).toBe(e2.description);\r\n    expect(result.price).toBe(e2.price);\r\n    expect(result.date).toStrictEqual(e2.date);\r\n    expect(result.address).toMatchObject(a);\r\n    expect(result.thumbnail).toBe(event.thumbnail);\r\n    expect(result.hashtags[0]).toBe(\"freizeit\");\r\n    expect(result.category.length).toBe(1);\r\n    expect(result.chat).toBe(event.chat);\r\n    expect(result.participants).toStrictEqual(event.participants);\r\n    // invalid authorization\r\n    await expect(\r\n      eventService.updateEvent(event.id, e2, user2.id)\r\n    ).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\services\\UserService.test.ts",{"fileContent":"import { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport { userResource } from \"../../src/Resources\";\r\nimport { IAddress, IUser, User } from \"../../src/model/UserModel\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\n\r\nconst a: IAddress = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\ndescribe(\"userModel test\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"createUser function\", async () => {\r\n    const user = await userService.createUser(u);\r\n    expect(user.id).toBeDefined();\r\n    expect(user.name.first).toBe(u.name.first);\r\n    expect(user.name.last).toBe(u.name.last);\r\n    expect(user.email).toBe(u.email);\r\n    expect(user.password).toBeUndefined();\r\n    const res = await User.findById(user.id);\r\n    expect(await res.isCorrectPassword(\"12abcAB!\")).toBeTruthy();\r\n    expect(user.address).toMatchObject(a);\r\n    expect(user.birthDate).toBe(u.birthDate);\r\n    expect(user.gender).toBe(u.gender);\r\n    expect(user.isActive).toBeTruthy();\r\n    expect(user.profilePicture).toBe(u.profilePicture);\r\n    expect(user.socialMediaUrls).toMatchObject(u.socialMediaUrls);\r\n  });\r\n\r\n  test(\"getUser works and returns user without password\", async () => {\r\n    const user = await userService.createUser(u);\r\n    await expect(userService.getUser(undefined)).rejects.toThrow(\r\n      \"Can not get user, userID is invalid\",\r\n    );\r\n    await expect(userService.getUser(NON_EXISTING_ID)).rejects.toThrow(\r\n      `No user with id: ${NON_EXISTING_ID} exists.`,\r\n    );\r\n    const res: userResource = await userService.getUser(user.id);\r\n    expect(user.id).toBeDefined();\r\n    expect(user.name.first).toBe(u.name.first);\r\n    expect(user.name.last).toBe(u.name.last);\r\n    expect(user.email).toBe(u.email);\r\n    expect(user.password).toBeUndefined();\r\n    const r = await User.findById(user.id);\r\n    expect(await r.isCorrectPassword(\"12abcAB!\")).toBeTruthy();\r\n    expect(user.address).toMatchObject(a);\r\n    expect(user.birthDate).toBe(u.birthDate);\r\n    expect(user.gender).toBe(u.gender);\r\n    expect(user.isActive).toBeTruthy();\r\n    expect(user.profilePicture).toBe(u.profilePicture);\r\n    expect(user.socialMediaUrls).toMatchObject(u.socialMediaUrls);\r\n  });\r\n\r\n  test(\"get all users also returns inactive users, getUser(userID) throws error at inactive user.\", async () => {\r\n    const u1 = await userService.createUser(u);\r\n    const user1: userResource = {\r\n      id: u1.id,\r\n      email: u1.email,\r\n      name: {\r\n        first: u1.name.first,\r\n        last: u1.name.last,\r\n      },\r\n      isAdministrator: u1.isAdministrator,\r\n      address: u1.address,\r\n      birthDate: u1.birthDate,\r\n      gender: u1.gender,\r\n      isActive: u1.isActive,\r\n    };\r\n    u.isActive = false;\r\n    u.email = \"Jane@doe.com\";\r\n    u.name.first = \"Jane\";\r\n    const u2 = await User.create(u);\r\n    const user2: userResource = {\r\n      id: u2.id,\r\n      email: u2.email,\r\n      name: {\r\n        first: u2.name.first,\r\n        last: u2.name.last,\r\n      },\r\n      isAdministrator: u2.isAdministrator,\r\n      address: u2.address,\r\n      birthDate: u2.birthDate,\r\n      gender: u2.gender,\r\n      isActive: u2.isActive,\r\n    };\r\n    await expect(userService.getUser(u2.id)).rejects.toThrow(\r\n      `No user with id: ${u2.id} exists.`,\r\n    );\r\n    const users = await userService.getUsers();\r\n    expect(users.users.length).toBe(2);\r\n    expect(users.users[0].isActive).toBe(user1.isActive);\r\n    expect(users.users[1].isActive).toBe(user2.isActive);\r\n  });\r\n\r\n  test(\"updateUserWithAdmin user update validations\", async () => {\r\n    const user = await userService.createUser(u);\r\n    const existingUserId = user.id;\r\n    const updatedUser = {\r\n      ...u,\r\n      id: existingUserId,\r\n      email: \"newemail@example.com\",\r\n    };\r\n    const result = await userService.updateUserWithAdmin(updatedUser);\r\n    expect(result.id).toBeDefined();\r\n    expect(result.name.first).toBe(updatedUser.name.first);\r\n    expect(result.name.last).toBe(updatedUser.name.last);\r\n    expect(result.email).toBe(updatedUser.email);\r\n    expect(result.password).toBeUndefined();\r\n    expect(result.address).toMatchObject(updatedUser.address);\r\n    expect(result.birthDate).toBe(updatedUser.birthDate);\r\n    expect(result.gender).toBe(updatedUser.gender);\r\n    expect(result.isActive).toBeTruthy();\r\n    expect(result.profilePicture).toBe(updatedUser.profilePicture);\r\n    expect(result.socialMediaUrls).toMatchObject(updatedUser.socialMediaUrls);\r\n\r\n    //Test for missing userID\r\n    const userWithNoId = { ...u, id: undefined };\r\n    await expect(userService.updateUserWithAdmin(userWithNoId)).rejects.toThrow(\r\n      \"User id is missing, cannot update User.\",\r\n    );\r\n\r\n    //Test for non-existing userID\r\n    const nonExistingUser = { ...u, id: NON_EXISTING_ID };\r\n    await expect(\r\n      userService.updateUserWithAdmin(nonExistingUser),\r\n    ).rejects.toThrow(\r\n      `No user with id: ${NON_EXISTING_ID} found, cannot update`,\r\n    );\r\n  });\r\n\r\n  test(\"updateUserWithAdmin duplicate email check\", async () => {\r\n    const user = await userService.createUser(u);\r\n    await userService.createUser({ ...u, email: \"duplicate@example.com\" });\r\n    //Create another user with a different ID but same email for duplicate check\r\n    const userWithDuplicateEmail = { ...user, email: \"duplicate@example.com\" };\r\n    await expect(\r\n      userService.updateUserWithAdmin(userWithDuplicateEmail),\r\n    ).rejects.toThrow(\"Duplicate email\");\r\n  });\r\n\r\n  test(\"updateUserWithPw update with old password to update password\", async () => {\r\n    const oldPw: string = u.password;\r\n    const user: userResource = await userService.createUser(u);\r\n\r\n    user.name.first = \"Jane\";\r\n    user.password = \"newPassword123!\";\r\n    const updatedUser: userResource = await userService.updateUserWithPw(\r\n      user,\r\n      oldPw,\r\n    );\r\n    expect(updatedUser.name.first).toBe(\"Jane\");\r\n    const Jane = await User.findById(user.id).exec();\r\n    expect(Jane.password).toBeDefined();\r\n    expect(await Jane.isCorrectPassword(\"newPassword123!\")).toBeTruthy();\r\n\r\n    //Test if user does not update Password on wrong old password.\r\n    await expect(\r\n      userService.updateUserWithPw(user, \"wrongPassword\"),\r\n    ).rejects.toThrow(\"invalid oldPassword, can not update User!\");\r\n  });\r\n\r\n  test(\"updateUserWithPw throws errors on invalid userdata\", async () => {\r\n    const user: userResource = await userService.createUser(u);\r\n    user.id = undefined;\r\n    user.name.first = \"Jane\";\r\n    await expect(userService.updateUserWithPw(user)).rejects.toThrow(\r\n      \"User id is missing, cannot update User.\",\r\n    );\r\n    user.id = NON_EXISTING_ID;\r\n    await expect(userService.updateUserWithPw(user)).rejects.toThrow(\r\n      `No user with id: ${NON_EXISTING_ID} found, cannot update`,\r\n    );\r\n  });\r\n\r\n  test(\"updateUserWithPw duplicate email check\", async () => {\r\n    const user = await userService.createUser(u);\r\n    await userService.createUser({ ...u, email: \"duplicate@example.com\" });\r\n    //Create another user with a different ID but same email for duplicate check\r\n    const userWithDuplicateEmail = { ...user, email: \"duplicate@example.com\" };\r\n    await expect(\r\n      userService.updateUserWithPw(userWithDuplicateEmail),\r\n    ).rejects.toThrow(\"Duplicate email\");\r\n  });\r\n\r\n  test(\"updateUserWithPw can not change isActive status of user\", async () => {\r\n    const user = await userService.createUser(u);\r\n    user.isActive = false;\r\n    user.name.first = \"Jane\";\r\n    const res = await userService.updateUserWithPw(user);\r\n    expect(res.isActive).toBeTruthy();\r\n    expect(res.name.first).toBe(\"Jane\");\r\n  });\r\n\r\n  test(\"deleteUser deletes user from database (when performed by an admin)\", async () => {\r\n    const user = await userService.createUser(u);\r\n    const res = await userService.deleteUser(user.id, false);\r\n    expect(res).toBeTruthy();\r\n    const noUserFound = await User.findById(user.id);\r\n    expect(noUserFound).toBeNull();\r\n\r\n    await expect(\r\n      userService.deleteUser(NON_EXISTING_ID, false),\r\n    ).rejects.toThrow(\r\n      \"User not found, probably invalid userID or user is already deleted\",\r\n    );\r\n    await expect(userService.deleteUser(\"\", false)).rejects.toThrow(\r\n      \"invalid userID, can not delete/inactivate account\",\r\n    );\r\n  });\r\n\r\n  test(\"deleteUser inactivates acc when inactivateAccount = true\", async () => {\r\n    const user = await userService.createUser(u);\r\n    const res = await userService.deleteUser(user.id, true);\r\n    expect(res).toBeTruthy();\r\n    const inactiveUser = await User.findById(user.id);\r\n    expect(inactiveUser.isActive).toBeFalsy();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\model\\UserModel.test.ts",{"fileContent":"import { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport { IAddress, IUser, User } from \"../../src/model/UserModel\";\r\n\r\nconst a: IAddress = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\nlet u: IUser = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"123\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\ndescribe(\"userModel test\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create User\", async () => {\r\n    const user = await User.create(u);\r\n    expect(user.id).toBeDefined();\r\n    expect(user.name.first).toBe(u.name.first);\r\n    expect(user.name.last).toBe(u.name.last);\r\n    expect(user.email).toBe(u.email);\r\n    expect(user.password).not.toBe(u.password);\r\n    expect(user.password).toBeDefined();\r\n    expect(await user.isCorrectPassword(\"123\")).toBeTruthy();\r\n    expect(user.address).toMatchObject(a);\r\n    expect(user.birthDate).toBe(u.birthDate);\r\n    expect(user.gender).toBe(u.gender);\r\n    expect(user.isActive).toBeTruthy();\r\n    expect(user.profilePicture).toBe(u.profilePicture);\r\n    expect(user.socialMediaUrls).toMatchObject(u.socialMediaUrls);\r\n  });\r\n\r\n  test(\"updated user password middleware\", async () => {\r\n    const user = await User.create(u);\r\n    user.password = \"456\";\r\n    user.email = \"John@some-host.de\";\r\n    await user.save();\r\n    const res = await User.findById(user.id);\r\n    expect(res.password).not.toBe(\"456\");\r\n    expect(res.password).not.toBe(\"123\");\r\n    expect(res.password).toBeDefined();\r\n    expect(await res.isCorrectPassword(\"456\")).toBeTruthy();\r\n    expect(res.email).toBe(\"John@some-host.de\");\r\n    expect(await User.findOne({ email: \"John@doe.com\" })).toBeNull();\r\n  });\r\n\r\n  test(\"rejects on duplicate email\", async () => {\r\n    await User.create(u);\r\n    u.name.first = \"Jane\";\r\n    await expect(User.create(u)).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\model\\EventModel.test.ts",{"fileContent":"import { Types } from \"mongoose\";\r\nimport { Event, ICategory, IEvent } from \"../../src/model/EventModel\";\r\nimport { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport { IAddress } from \"../../src/model/UserModel\";\r\n\r\nconst a: IAddress = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: ICategory = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\ndescribe(\"Event Model Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create event\", async () => {\r\n    const eventData: IEvent = {\r\n      name: \"Test Event\",\r\n      creator: new Types.ObjectId(),\r\n      description: \"A test event\",\r\n      price: 10,\r\n      date: new Date(),\r\n      address: a,\r\n      category: [c],\r\n      chat: new Types.ObjectId(),\r\n      participants: [],\r\n    };\r\n    const createdEvent = await Event.create(eventData);\r\n    expect(createdEvent).toBeDefined();\r\n    expect(createdEvent.name).toBe(eventData.name);\r\n    expect(createdEvent.creator).toBe(eventData.creator);\r\n    expect(createdEvent.description).toBe(eventData.description);\r\n    expect(createdEvent.price).toBe(eventData.price);\r\n    expect(createdEvent.date).toBe(eventData.date);\r\n    expect(createdEvent.address).toMatchObject(a);\r\n    expect(createdEvent.category.map(c => c.name)).toContain(\"Hobbys\");\r\n    expect(createdEvent.chat).toBe(eventData.chat);\r\n    expect(createdEvent.participants).toStrictEqual(eventData.participants);\r\n  });\r\n\r\n  test(\"empty eventdata\", async () => {\r\n    const eventData: IEvent = {\r\n      name: \"\",\r\n      creator: new Types.ObjectId(),\r\n      description: \"\",\r\n      price: 0,\r\n      date: undefined,\r\n      address: undefined,\r\n      category: [],\r\n      chat: new Types.ObjectId(),\r\n      participants: [],\r\n    };\r\n    await expect(Event.create(eventData)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"negative price\", async () => {\r\n    const eventData: IEvent = {\r\n      name: \"Test Event\",\r\n      creator: new Types.ObjectId(),\r\n      description: \"A test event\",\r\n      price: -1,\r\n      date: new Date(),\r\n      address: a,\r\n      category: [c],\r\n      chat: new Types.ObjectId(),\r\n      participants: [],\r\n    };\r\n    await expect(Event.create(eventData)).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}]]