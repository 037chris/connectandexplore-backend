[["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\jest.setup.ts",{"fileContent":"require(\"dotenv\").config({ path: \".env.test\" });\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\routes\\EventRoute.test.ts",{"fileContent":"import request from \"supertest\";\r\n//import { req } from \"../jest.setup\";\r\nimport { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  LoginResource,\r\n  addressEResource,\r\n  categoryResource,\r\n  eventResource,\r\n  userResource,\r\n} from \"../../src/Resources\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\nimport app from \"../../server\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\nimport mongoose from \"mongoose\";\r\n\r\nconst a: addressEResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst JaneData: userResource = {\r\n  email: \"Jane@doe.com\",\r\n  name: {\r\n    first: \"Jane\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst eventService: EventService = new EventService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\nlet admin: userResource;\r\nlet AdminToken: string;\r\nlet jane: userResource;\r\nlet token: string;\r\nlet user: userResource;\r\nlet uToken: string;\r\nlet req = request(app);\r\n\r\ndescribe(\"EventRoute Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  beforeEach(async () => {\r\n    admin = await userService.createUser(u);\r\n    jane = await userService.createUser(JaneData);\r\n    user = await userService.createUser(u2);\r\n    const adminloginData = { email: \"John@doe.com\", password: \"12abcAB!\" };\r\n    const adminRes = await req.post(`/api/login`).send(adminloginData);\r\n    const AdminLoginResource = adminRes.body as LoginResource;\r\n    AdminToken = AdminLoginResource.access_token;\r\n\r\n    const janeLoginData = { email: \"Jane@doe.com\", password: \"12abcAB!\" };\r\n    const janeRes = await req.post(`/api/login`).send(janeLoginData);\r\n    const janeLoginResource = janeRes.body as LoginResource;\r\n    token = janeLoginResource.access_token;\r\n\r\n    const uLoginData = { email: \"test@mail.com\", password: \"12abcAB!\" };\r\n    const uRes = await req.post(`/api/login`).send(uLoginData);\r\n    const uLoginResource = uRes.body as LoginResource;\r\n    uToken = uLoginResource.access_token;\r\n  });\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => {\r\n    //closeServer(); // Close the server after all tests\r\n    await mongoose.connection.close(); // Perform final cleanup after all tests\r\n  });\r\n\r\n  test(\"create event route\", async () => {\r\n    let res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(e)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    const event: eventResource = res.body;\r\n    expect(event.id).toBeDefined();\r\n    expect(event.name).toBe(\"Sample Event\");\r\n    expect(event.creator).toBe(jane.id);\r\n    expect(event.description).toBe(e.description);\r\n    expect(event.price).toBe(e.price);\r\n    expect(event.date).toBe(e.date.toISOString());\r\n    expect(event.address).toMatchObject(a);\r\n    expect(event.thumbnail).toBe(e.thumbnail);\r\n    expect(event.hashtags).toStrictEqual(e.hashtags);\r\n    expect(event.category).toHaveLength(2);\r\n    expect(event.chat).toBeDefined();\r\n    expect(event.participants).toHaveLength(1);\r\n    // create event as admin\r\n    res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(e)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    // duplicate event data should still work\r\n    const event1: eventResource = res.body;\r\n    expect(event1).toBeDefined();\r\n    expect(event1.id).not.toBe(event.id);\r\n    expect(event1.name).toBe(event.name);\r\n    expect(event1.creator).toBe(admin.id);\r\n    expect(event1.description).toBe(event.description);\r\n    expect(event1.price).toBe(event.price);\r\n    expect(event1.date).toBe(event.date);\r\n    expect(event1.thumbnail).toBe(event.thumbnail);\r\n    expect(event1.hashtags).toStrictEqual(event.hashtags);\r\n    expect(event1.chat).not.toBe(event.chat);\r\n    expect(event.participants.length).toBe(event.participants.length);\r\n    // invalid token/event data\r\n    res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(undefined)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(400);\r\n    expect(res.body.errors).toBeDefined();\r\n    res = await req\r\n      .post(\"/api/events/create\")\r\n      .send(e)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    // get event as event creator\r\n    let res = await req\r\n      .get(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.name).toBe(\"Sample Event\");\r\n    // get event as user\r\n    res = await req\r\n      .get(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.name).toBe(\"Sample Event\");\r\n    // invalid id/token\r\n    res = await req\r\n      .get(`/api/events/${NON_EXISTING_ID}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n    res = await req\r\n      .get(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"join event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    // join event as user\r\n    let res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.message).toBe(\"User joined the event successfully\");\r\n    const ee = await eventService.getEvent(event.id);\r\n    expect(ee.participants).toHaveLength(2);\r\n    // user already participating\r\n    res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(409);\r\n    // join event as event creator should not work\r\n    res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(409);\r\n    // invalid id/token\r\n    res = await req\r\n      .post(`/api/events/${undefined}/join`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(500);\r\n    res = await req\r\n      .post(`/api/events/${event.id}/join`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"cancel event participation route\", async () => {\r\n    let event = await eventService.createEvent(e, jane.id);\r\n    // invalid id/token\r\n    let res = await req\r\n      .delete(`/api/events/${undefined}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(500);\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n    // user not participating\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(409);\r\n    // cancel participation works correctly\r\n    await eventService.joinEvent(user.id, event.id);\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(204);\r\n    // cancel participation as event creator should not work\r\n    res = await req\r\n      .delete(`/api/events/${event.id}/cancel`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(409);\r\n  });\r\n\r\n  test(\"get participants of event route\", async () => {\r\n    let event = await eventService.createEvent(e, jane.id);\r\n    await eventService.joinEvent(user.id, event.id);\r\n    // get participants as event creator\r\n    let res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.users).toHaveLength(2);\r\n    expect(res.body.users[0].email).toBe(\"Jane@doe.com\");\r\n    expect(res.body.users[1].email).toBe(\"test@mail.com\");\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.users).toHaveLength(2);\r\n    // get participants as user should not work\r\n    res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(404);\r\n    // invalid id/token\r\n    res = await req\r\n      .get(`/api/events/${undefined}/participants`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n    res = await req\r\n      .get(`/api/events/${event.id}/participants`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get created events route\", async () => {\r\n    await eventService.createEvent(e, jane.id);\r\n    await eventService.createEvent(e1, jane.id);\r\n    await eventService.createEvent(e2, jane.id);\r\n    // get created events as event creator\r\n    let res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    expect(res.body.events[0].name).toBe(\"Sample Event\");\r\n    expect(res.body.events[1].name).toBe(\"Sample Event 1\");\r\n    expect(res.body.events[2].name).toBe(\"Sample Event 2\");\r\n    // get created events of user with no events\r\n    res = await req\r\n      .get(`/api/events/creator/${user.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(204);\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    // get created events as user shoud not work\r\n    res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(403);\r\n    // invalid id/token\r\n    res = await req\r\n      .get(`/api/events/creator/${undefined}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n    res = await req\r\n      .get(`/api/events/creator/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get joined events route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    const event1 = await eventService.createEvent(e1, jane.id);\r\n    const event2 = await eventService.createEvent(e2, jane.id);\r\n    await eventService.joinEvent(user.id, event.id);\r\n    await eventService.joinEvent(user.id, event1.id);\r\n    await eventService.joinEvent(user.id, event2.id);\r\n    // 3 events created no events joined\r\n    let res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    // no events created 3 events joined\r\n    res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    // no events created no events joined\r\n    res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(204);\r\n    expect(res.body.events).toBeUndefined();\r\n    // invalid token\r\n    res = await req\r\n      .get(`/api/events/joined`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n  });\r\n\r\n  test(\"get all events route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    const event1 = await eventService.createEvent(e1, user.id);\r\n    const event2 = await eventService.createEvent(e2, admin.id);\r\n    // get all events as registered user\r\n    let res = await req\r\n      .get(`/api/events/`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    // get all events as guest user\r\n    res = await req.get(`/api/events/`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n  });\r\n\r\n  test(\"search events route\", async () => {\r\n    await eventService.createEvent(e, jane.id);\r\n    await eventService.createEvent(e1, user.id);\r\n    await eventService.createEvent(e2, admin.id);\r\n    // search by event name\r\n    let res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"sAmPle eVeNt\" })\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(3);\r\n    res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"event 2\" })\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(1);\r\n    res = await req.get(\"/api/events/search\").query({ query: \"EVENT SAMPLE\" });\r\n    expect(res.status).toBe(204);\r\n    expect(res.body.events).toBeUndefined();\r\n    // search by description\r\n    res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"this is my\" })\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(2);\r\n    // search by hashtags\r\n    res = await req.get(\"/api/events/search\").query({ query: \"SPORT\" });\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(1);\r\n    res = await req.get(\"/api/events/search\").query({ query: \"freizeit\" });\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.events).toHaveLength(2);\r\n    res = await req\r\n      .get(\"/api/events/search\")\r\n      .query({ query: \"Sport Freizeit\" });\r\n    expect(res.status).toBe(204);\r\n    expect(res.body.events).toBeUndefined();\r\n  });\r\n\r\n  test(\"delete event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    const event1 = await eventService.createEvent(e1, user.id);\r\n    // user can not delete event of another event creator\r\n    let res = await req\r\n      .delete(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(404);\r\n    expect(await eventService.getEvent(event.id)).toBeDefined();\r\n    // event creator can delete own event correctly\r\n    res = await req\r\n      .delete(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(204);\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n    // invalid id/token\r\n    res = await req\r\n      .delete(`/api/events/${undefined}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(404);\r\n    expect(await eventService.getEvent(event1.id)).toBeDefined();\r\n    res = await req\r\n      .delete(`/api/events/${event1.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n    expect(await eventService.getEvent(event1.id)).toBeDefined();\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .delete(`/api/events/${event1.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(204);\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"update event route\", async () => {\r\n    const event = await eventService.createEvent(e, jane.id);\r\n    // user can not update event of another event creator\r\n    let res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .send(e1)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(404);\r\n    // no updated event data sent should still work\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.name).toBe(event.name);\r\n    // invalid id/token\r\n    res = await req\r\n      .put(`/api/events/${undefined}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(400);\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${undefined}`);\r\n    expect(res.status).toBe(401);\r\n    // event creator should update event correctly\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .send(e1)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    // eventresource returned correctly\r\n    expect(res.body.id).toBe(event.id);\r\n    expect(res.body.name).toBe(e1.name);\r\n    expect(res.body.creator).toBe(event.creator);\r\n    expect(res.body.description).toBe(e1.description);\r\n    expect(res.body.price).toBe(e1.price);\r\n    expect(res.body.date).toStrictEqual(e1.date.toISOString());\r\n    expect(res.body.address).toMatchObject(a);\r\n    expect(res.body.thumbnail).toBe(event.thumbnail);\r\n    expect(res.body.hashtags).toStrictEqual(event.hashtags);\r\n    expect(res.body.category.length).toBe(1);\r\n    expect(res.body.chat).toBe(event.chat);\r\n    expect(res.body.participants).toStrictEqual(event.participants);\r\n    // not event creator but admin should work\r\n    res = await req\r\n      .put(`/api/events/${event.id}`)\r\n      .send(e1)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    const newevent = await eventService.getEvent(event.id);\r\n    expect(newevent.id).toBe(event.id);\r\n    expect(newevent.name).toBe(\"Sample Event 1\");\r\n    expect(newevent.creator).toBe(event.creator);\r\n    expect(newevent.description).toBe(e1.description);\r\n    expect(newevent.price).toBe(e1.price);\r\n    expect(newevent.date).toStrictEqual(e1.date);\r\n    expect(newevent.address).toMatchObject(a);\r\n    expect(newevent.thumbnail).toBe(event.thumbnail);\r\n    expect(newevent.hashtags).toStrictEqual(event.hashtags);\r\n    expect(newevent.category.length).toBe(1);\r\n    expect(newevent.chat).toBe(event.chat);\r\n    expect(newevent.participants).toStrictEqual(event.participants);\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/server.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/createTestData.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/Comments.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\database\\db.ts",{"fileContent":"// Copyright: This script is taken from: https://codesandbox.io/s/typescript-forked-8vscow?file=/src/db.ts\r\nimport mongoose from \"mongoose\";\r\nimport { MongoMemoryServer } from \"mongodb-memory-server\";\r\n\r\nlet mongod: any;\r\n\r\nexport const connect = async () => {\r\n  mongod = await MongoMemoryServer.create();\r\n  const uri = mongod.getUri();\r\n  await mongoose\r\n    .connect(uri, { dbName: \"ConnectAndExplore\" })\r\n    .then((_result) => console.log(\"connected....\"))\r\n    .catch((err) => console.log(`Cannot connect => ${err}`));\r\n};\r\n\r\n/**\r\n * Close db connection\r\n */\r\nexport const closeDatabase = async () => {\r\n  await mongoose.connection.dropDatabase();\r\n  await mongoose.connection.close();\r\n  await mongod.stop();\r\n};\r\n\r\n/**\r\n * Delete db collections\r\n */\r\nexport const clearDatabase = async () => {\r\n  const collections = mongoose.connection.collections;\r\n\r\n  for (const key in collections) {\r\n    const collection = collections[key];\r\n    await collection.deleteMany({});\r\n  }\r\n};\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\EventService.ts",{"fileContent":"import { Types } from \"mongoose\";\r\nimport { eventResource, eventsResource, usersResource } from \"../Resources\";\r\nimport { Chat, Event } from \"../model/EventModel\";\r\nimport { User } from \"../model/UserModel\";\r\nimport { CommentService } from \"../../src/services/CommentService\";\r\n\r\nconst commentService: CommentService = new CommentService();\r\n\r\nexport class EventService {\r\n  /**\r\n   * Event erstellen\r\n   */\r\n  async createEvent(\r\n    eventResource: eventResource,\r\n    creatorID: string\r\n  ): Promise<eventResource> {\r\n    try {\r\n      const creator = await User.findById(creatorID);\r\n      const chat = await Chat.create({ messages: [] });\r\n      const event = await Event.create({\r\n        name: eventResource.name,\r\n        creator: creator.id,\r\n        description: eventResource.description,\r\n        price: eventResource.price,\r\n        date: eventResource.date,\r\n        address: eventResource.address,\r\n        thumbnail: eventResource.thumbnail,\r\n        hashtags: eventResource.hashtags,\r\n        category: eventResource.category,\r\n        chat: chat.id,\r\n        participants: [creatorID],\r\n      });\r\n\r\n      chat.event = event._id;\r\n      await chat.save();\r\n\r\n      return {\r\n        id: event.id,\r\n        name: event.name,\r\n        creator: event.creator.toString(),\r\n        description: event.description,\r\n        price: event.price,\r\n        date: event.date,\r\n        address: event.address,\r\n        thumbnail: event.thumbnail,\r\n        hashtags: event.hashtags,\r\n        category: event.category,\r\n        chat: event.chat.toString(),\r\n        participants: event.participants.map((participantId) =>\r\n          participantId.toString()\r\n        ),\r\n      };\r\n    } catch (err) {\r\n      console.log(err);\r\n      throw new Error(\"Event creation failed\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ein bestimmtes Event abrufen\r\n   */\r\n  async getEvent(eventID: string): Promise<eventResource> {\r\n    try {\r\n      const event = await Event.findById(eventID).exec();\r\n      if (!event) {\r\n        throw new Error(\"Event not found\");\r\n      }\r\n      return {\r\n        id: event.id,\r\n        name: event.name,\r\n        creator: event.creator.toString(),\r\n        description: event.description,\r\n        price: event.price,\r\n        date: event.date,\r\n        address: event.address,\r\n        thumbnail: event.thumbnail,\r\n        hashtags: event.hashtags,\r\n        category: event.category,\r\n        chat: event.chat.toString(),\r\n        participants: event.participants.map((participantId) =>\r\n          participantId.toString()\r\n        ),\r\n      };\r\n    } catch (error) {\r\n      throw new Error(\"Error getting event\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle erstellten Events abrufen ( Event Manager / Admin )\r\n   */\r\n  async getEvents(userID: string): Promise<eventsResource> {\r\n    if (!userID) {\r\n      throw new Error(\"Can not get creator, userID is invalid\");\r\n    }\r\n    try {\r\n      const events = await Event.find({ creator: userID }).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString()\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle Events abrufen\r\n   */\r\n  async getAllEvents(): Promise<eventsResource> {\r\n    try {\r\n      const events = await Event.find({}).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString()\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Events filtern / Event suchen\r\n   */\r\n  async searchEvents(query: string): Promise<eventsResource> {\r\n    if (!query || query.trim().length === 0) return this.getAllEvents();\r\n    try {\r\n      const events = await Event.find({\r\n        $or: [\r\n          { name: { $regex: new RegExp(query, \"i\") } },\r\n          { description: { $regex: new RegExp(query, \"i\") } },\r\n          { hashtags: { $in: [new RegExp(query, \"i\")] } },\r\n        ],\r\n      }).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString()\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error searching events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Am Event teilnehmen ( Event Teilnehmer )\r\n   */\r\n  async joinEvent(userID: string, eventID: string): Promise<boolean> {\r\n    if (!userID) throw new Error(`User ID: ${userID} is invalid.`);\r\n    if (!eventID) throw new Error(`Event ID: ${eventID} is invalid.`);\r\n    const user = await User.findById(userID).exec();\r\n    const event = await Event.findById(eventID).exec();\r\n    if (!user) throw new Error(\"User not found\");\r\n    if (!event) throw new Error(\"Event not found\");\r\n    if (event.participants.includes(user._id)) {\r\n      throw new Error(\"User is already participating in the event\");\r\n    }\r\n    try {\r\n      event.participants.push(user._id);\r\n      await event.save();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle teilgenommenen Events abrufen ( Event Teilnehmer )\r\n   */\r\n  async getJoinedEvents(userID: string): Promise<eventsResource> {\r\n    try {\r\n      const events = await Event.find({ participants: userID }).exec();\r\n      const eventsResult: eventsResource = {\r\n        events: events.map((event) => ({\r\n          id: event.id,\r\n          name: event.name,\r\n          creator: event.creator.toString(),\r\n          description: event.description,\r\n          price: event.price,\r\n          date: event.date,\r\n          address: event.address,\r\n          thumbnail: event.thumbnail,\r\n          hashtags: event.hashtags,\r\n          category: event.category,\r\n          chat: event.chat.toString(),\r\n          participants: event.participants.map((participantId) =>\r\n            participantId.toString()\r\n          ),\r\n        })),\r\n      };\r\n      return eventsResult;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting events\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Teilnahme am Event absagen ( Event Teilnehmer )\r\n   */\r\n  async cancelEvent(userID: string, eventID: string): Promise<boolean> {\r\n    if (!userID) throw new Error(`User ID: ${userID} is invalid.`);\r\n    if (!eventID) throw new Error(`Event ID: ${eventID} is invalid.`);\r\n    const event = await Event.findById(eventID).exec();\r\n    if (!event) throw new Error(\"Event not found\");\r\n    if (event.creator && event.creator.toString() === userID)\r\n      throw new Error(\"Can not cancel participation as event manager\");\r\n    const index = event.participants.findIndex((participant) => {\r\n      return participant.equals(new Types.ObjectId(userID));\r\n    });\r\n    if (index === -1) {\r\n      throw new Error(\"User is not participating in the event\");\r\n    }\r\n    try {\r\n      event.participants.splice(index, 1);\r\n      await event.save();\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Alle Teilnehmer vom Event abrufen ( Event Manager / Admin )\r\n   */\r\n  async getParticipants(\r\n    eventID: string,\r\n    creatorID: string\r\n  ): Promise<usersResource> {\r\n    try {\r\n      const event = await Event.findById(eventID).exec();\r\n      if (!event) throw new Error(\"Event not found\");\r\n      const creator = await User.findById(event.creator).exec();\r\n      const user = await User.findById(creatorID);\r\n      if (\r\n        !creator ||\r\n        !user ||\r\n        (creator.id !== creatorID && !user.isAdministrator)\r\n      ) {\r\n        throw new Error(\"Invalid authorization\");\r\n      }\r\n      const participantIDs = event.participants;\r\n      const participants = await User.find({\r\n        _id: { $in: participantIDs },\r\n      }).exec();\r\n      const result: usersResource = {\r\n        users: participants.map((user) => ({\r\n          id: user.id,\r\n          name: user.name,\r\n          email: user.email,\r\n          isAdministrator: user.isAdministrator,\r\n          address: user.address,\r\n          profilePicture: user.profilePicture,\r\n          birthDate: user.birthDate,\r\n          gender: user.gender,\r\n          socialMediaUrls: user.socialMediaUrls,\r\n          isActive: user.isActive,\r\n        })),\r\n      };\r\n      return result;\r\n    } catch (error) {\r\n      throw new Error(\"Error getting participants\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event bearbeiten ( Event Manager / Admin )\r\n   */\r\n  async updateEvent(\r\n    eventID: string,\r\n    eventResource: eventResource,\r\n    userID: string\r\n  ): Promise<eventResource> {\r\n    const event = await Event.findById(eventID).exec();\r\n    if (!event) throw new Error(\"Event not found\");\r\n    const creator = await User.findById(event.creator).exec();\r\n    const user = await User.findById(userID).exec();\r\n    if (\r\n      !creator ||\r\n      !user ||\r\n      (creator._id.toString() !== userID && !user.isAdministrator)\r\n    ) {\r\n      throw new Error(\"Invalid authorization\");\r\n    }\r\n    if (eventResource.name) event.name = eventResource.name;\r\n    if (eventResource.description)\r\n      event.description = eventResource.description;\r\n    if (eventResource.price !== undefined) {\r\n      if (eventResource.price < 0) {\r\n        throw new Error(\"Event price cannot be less than 0\");\r\n      } else if (eventResource.price === 0) {\r\n        event.price = 0;\r\n      } else {\r\n        event.price = eventResource.price;\r\n      }\r\n    }\r\n    if (eventResource.date) event.date = eventResource.date;\r\n    if (eventResource.address) event.address = eventResource.address;\r\n    if (eventResource.thumbnail) event.thumbnail = eventResource.thumbnail;\r\n    if (eventResource.hashtags) event.hashtags = eventResource.hashtags;\r\n    if (eventResource.category) event.category = eventResource.category;\r\n    const savedEvent = await event.save();\r\n    return {\r\n      id: savedEvent.id,\r\n      name: savedEvent.name,\r\n      creator: savedEvent.creator.toString(),\r\n      description: savedEvent.description,\r\n      price: savedEvent.price,\r\n      date: savedEvent.date,\r\n      address: savedEvent.address,\r\n      thumbnail: savedEvent.thumbnail,\r\n      hashtags: savedEvent.hashtags,\r\n      category: savedEvent.category,\r\n      chat: savedEvent.chat.toString(),\r\n      participants: savedEvent.participants.map((participantId) =>\r\n        participantId.toString()\r\n      ),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Event löschen ( Event Manager / Admin )\r\n   */\r\n  async deleteEvent(eventID: string, userID: string): Promise<boolean> {\r\n    try {\r\n      const event = await Event.findById(eventID).exec();\r\n      if (!event) throw new Error(\"Event not found\");\r\n      const creator = await User.findById(event.creator).exec();\r\n      const user = await User.findById(userID).exec();\r\n      if (\r\n        !creator ||\r\n        !user ||\r\n        (creator._id.toString() !== userID && !user.isAdministrator)\r\n      ) {\r\n        throw new Error(\"Invalid authorization\");\r\n      }\r\n      await Chat.deleteOne({ _id: event.chat }).exec();\r\n      const result = await Event.deleteOne({ _id: eventID }).exec();\r\n      if (result.deletedCount === 1) {\r\n        await commentService.deleteCommentsOfevent(eventID);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      throw new Error(\"Error deleting event\");\r\n    }\r\n  }\r\n}\r\n\r\nexport default new EventService();\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\model\\EventModel.ts",{"fileContent":"import { Model, Schema, Types, model } from \"mongoose\";\r\n\r\nexport interface IEAddress {\r\n  street: String;\r\n  houseNumber: String;\r\n  apartmentNumber?: String;\r\n  postalCode: String;\r\n  city: String;\r\n  stateOrRegion?: String;\r\n  country: String;\r\n}\r\nexport interface IEvent {\r\n  name: string;\r\n  creator: Types.ObjectId;\r\n  description: string;\r\n  price: number;\r\n  date: Date;\r\n  address: IEAddress;\r\n  thumbnail?: string;\r\n  hashtags?: string[];\r\n  category: ICategory[];\r\n  chat: Types.ObjectId;\r\n  participants: Types.ObjectId[];\r\n}\r\n\r\nexport interface ICategory {\r\n  name: string;\r\n  description: string;\r\n}\r\n\r\nexport interface IChat {\r\n  event: Types.ObjectId;\r\n  messages: { user: Types.ObjectId; message: String, time: Date }[];\r\n}\r\n\r\n/**\r\n * Adressen werden später in das EventSchema eingefügt und als teil eines Users in mongoDB gespeichert\r\n */\r\nexport const addressESchema = new Schema({\r\n  street: { type: String, required: true },\r\n  houseNumber: { type: String, required: true },\r\n  apartmentNumber: String,\r\n  postalCode: { type: String, required: true },\r\n  city: { type: String, required: true },\r\n  stateOrRegion: String,\r\n  country: { type: String, required: true },\r\n});\r\nconst categorySchema = new Schema<ICategory>({\r\n  name: { type: String, required: true /* , unique: true */ },\r\n  description: { type: String },\r\n});\r\n\r\nconst chatSchema = new Schema<IChat>({\r\n  event: { type: Schema.Types.ObjectId, ref: \"Event\" },\r\n  messages: [\r\n    { user: { type: Schema.Types.ObjectId, ref: \"User\" }, message: String, time: Date }\r\n  ],\r\n});\r\n\r\ntype EventModel = Model<IEvent, {}>;\r\ntype CategoryModel = Model<ICategory, {}>;\r\ntype ChatModel = Model<IChat, {}>;\r\n\r\nconst eventSchema = new Schema<IEvent>({\r\n  name: { type: String, required: true },\r\n  creator: { type: Schema.Types.ObjectId, ref: \"User\", required: true },\r\n  description: { type: String, required: true },\r\n  price: { type: Number, required: true, min: 0 },\r\n  date: { type: Date, required: true },\r\n  address: addressESchema,\r\n  thumbnail: { type: String },\r\n  hashtags: [{ type: String }],\r\n  category: [categorySchema],\r\n  chat: { type: Schema.Types.ObjectId, ref: \"Chat\", required: true },\r\n  participants: [{ type: Schema.Types.ObjectId, ref: \"User\", required: true }],\r\n});\r\n\r\n/* \r\nZu implementieren?:\r\nMiddleware-Methode, die sicherstellt, dass nach Bearbeitung eines Events, alle Teilnehmer benachrichtigt werden\r\n\r\neventSchema.post('updateOne', async function (result, next) {\r\n    try {\r\n        //Funktion zur Benachrichtigung aller Teilnehmer\r\n    } catch (error) {\r\n        //throw new Error()\r\n    }\r\n    next();\r\n}); */\r\n\r\nexport const Event = model<IEvent, EventModel>(\"Event\", eventSchema);\r\nexport const Categoty = model<ICategory, CategoryModel>(\r\n  \"Category\",\r\n  categorySchema\r\n);\r\nexport const Chat = model<IChat, ChatModel>(\"Chat\", chatSchema);\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\model\\UserModel.ts",{"fileContent":"import mongoose, { Model, model, Schema, Query } from \"mongoose\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nexport interface IUser {\r\n  email: string;\r\n  name: {\r\n    first: string;\r\n    last: string;\r\n  };\r\n  password: string;\r\n  isAdministrator: Boolean;\r\n  address: IAddress;\r\n  profilePicture?: string;\r\n  birthDate: Date;\r\n  gender: string;\r\n  socialMediaUrls?: {\r\n    facebook?: string;\r\n    instagram?: string;\r\n  };\r\n  isActive: boolean;\r\n}\r\n\r\nexport interface IAddress {\r\n  postalCode: String;\r\n  city: String;\r\n}\r\n\r\nexport enum userRole {\r\n  User = \"u\",\r\n  Admin = \"a\",\r\n}\r\ninterface IUserMethods {\r\n  isCorrectPassword(password: string): Promise<boolean>;\r\n}\r\ntype UserModel = Model<IUser, {}, IUserMethods>;\r\n\r\n/**\r\n * Adressen werden später in das UserSchema eingefügt und als teil eines Users in mongoDB gespeichert\r\n */\r\nexport const addressSchema = new Schema({\r\n  postalCode: { type: String, required: true },\r\n  city: { type: String, required: true },\r\n});\r\n\r\nconst userSchema = new Schema<IUser, UserModel>({\r\n  email: { type: String, required: true, unique: true },\r\n  name: {\r\n    first: { type: String, required: true },\r\n    last: { type: String, required: true },\r\n  },\r\n  password: { type: String, required: true },\r\n  isAdministrator: { type: Boolean, default: false },\r\n  address: addressSchema,\r\n  profilePicture: String,\r\n  birthDate: { type: Date, required: true },\r\n  gender: { type: String, required: true },\r\n  socialMediaUrls: {\r\n    facebook: String,\r\n    instagram: String,\r\n  },\r\n  isActive: { type: Boolean, default: true },\r\n});\r\n\r\nuserSchema.pre(\"save\", async function () {\r\n  if (this.isModified(\"password\")) {\r\n    const hashedPassword = await bcrypt.hash(this.password, 10);\r\n    this.password = hashedPassword;\r\n  }\r\n});\r\n\r\nuserSchema.pre(\r\n  \"updateOne\",\r\n  { document: false, query: true },\r\n  async function () {\r\n    const update = this.getUpdate() as\r\n      | (Query<any, IUser> & { password?: string })\r\n      | null;\r\n    if (update?.password != null) {\r\n      const hashedPassword = await bcrypt.hash(update.password, 10);\r\n      update.password = hashedPassword;\r\n    }\r\n  }\r\n);\r\n\r\nuserSchema.method(\r\n  \"isCorrectPassword\",\r\n  async function (password: string): Promise<boolean> {\r\n    const isPW = await bcrypt.compare(password, this.password);\r\n    return isPW;\r\n  }\r\n);\r\n\r\nexport const User = model<IUser, UserModel>(\"User\", userSchema);\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\server.ts",{"fileContent":"import express, { Express } from \"express\";\r\nconst bodyParser = require(\"body-parser\");\r\nconst fs = require(\"fs\");\r\nconst cors = require(\"cors\");\r\nconst key = fs.readFileSync(\"./certificates/key.pem\");\r\nconst cert = fs.readFileSync(\"./certificates/cert.pem\");\r\nimport { connect } from \"./database/db\";\r\nimport createAdminUser from \"./src/utils/CreateAdminUser\";\r\nimport https from \"https\";\r\nconst http = require(\"http\");\r\nimport swaggerDocs from \"./src/utils/swagger\";\r\nimport UserRoute from \"./src/routes/UserRoute\";\r\nimport UsersRouter from \"./src/routes/UsersRouter\";\r\nimport loginRouter from \"./src/routes/login\";\r\nimport EventRouter from \"./src/routes/EventRoute\";\r\nimport createTestData from \"./src/utils/createTestData\";\r\nimport commentsRouter from \"./src/routes/Comments\";\r\nimport ChatRouter from \"./src/routes/ChatRoute\";\r\n\r\nconst app: Express = express();\r\nconst port = process.env.PORT || 443;\r\n/* Routes */\r\napp.use(\"*\", cors());\r\n\r\napp.use(function (req, res, next) {\r\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\r\n  res.header(\r\n    \"Access-Control-Allow-Headers\",\r\n    \"Origin, X-Requested-With, Content-Type, Accept\"\r\n  );\r\n  res.header(\"Access-Control-Expose-Headers\", \"Authorization\");\r\n  next();\r\n});\r\n\r\nexport const server = https.createServer({ key, cert }, app);\r\nconst io = require(\"socket.io\")(server, {\r\n  cors: {\r\n    origin: \"http://localhost:3000\",\r\n    methods: [\"GET\", \"POST\"],\r\n  },\r\n});\r\n\r\nio.on(\"connection\", (socket) => {\r\n  //console.log(\"socket connected\");\r\n\r\n  socket.on(\"disconnect\", () => {\r\n    //console.log(\"socket disconnected\")\r\n  });\r\n\r\n  socket.on(\"join_room\", ({ roomId }) => {\r\n    socket.join(roomId);\r\n  });\r\n\r\n  socket.on(\"send_message\", ({ user, message, roomId, time }) => {\r\n    //console.log(`(${roomId})> (${time}) ${user}: ${message}`);\r\n    socket.to(roomId).emit(\"receive_message\", { user, message, time });\r\n  });\r\n});\r\n\r\napp.use(bodyParser.json());\r\napp.use(express.urlencoded({ extended: true }));\r\napp.use(express.static(__dirname));\r\n\r\napp.use(\"/api/users\", UserRoute);\r\napp.use(\"/api\", UsersRouter);\r\napp.use(\"/api/login\", loginRouter);\r\napp.use(\"/api/events\", EventRouter);\r\napp.use(\"/api/comments\", commentsRouter);\r\napp.use(\"/api/chat\", ChatRouter);\r\napp.use(\"/images/users\", express.static(\"uploads/users\"));\r\napp.use(\"/images/events\", express.static(\"uploads/events\"));\r\nswaggerDocs(app, +port);\r\napp.use((req, res, next) => {\r\n  res.status(404).json(\"Not Found\");\r\n});\r\n\r\nconnect()\r\n  .then(async () => {\r\n    // Create admin user after connecting to the database\r\n    await createAdminUser();\r\n    await createTestData();\r\n    //let server = https.createServer({ key, cert }, app);\r\n    //let server = http.createServer(app);\r\n    if (process.env.NODE_ENV !== \"test\") {\r\n      server.listen(port, () => {\r\n        console.log(\"Listening on port \", port);\r\n      });\r\n    }\r\n  })\r\n  .catch((err) => {\r\n    console.error(\"Failed to connect to the database:\", err);\r\n  });\r\n\r\nexport default app;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/createTestData.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/Comments.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/ChatRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/package.json","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/FileUpload.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/Helpers.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/RatingService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ChatService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\CreateAdminUser.ts",{"fileContent":"import { User, IAddress, IUser } from \"../model/UserModel\";\r\n\r\nconst createAdminUser = async () => {\r\n  const a: IAddress = {\r\n    postalCode: \"12345\",\r\n    city: \"Berlin\",\r\n  };\r\n\r\n  let u: IUser = {\r\n    email: \"admin.team@connectandexplore.com\",\r\n    name: {\r\n      first: \"admin\",\r\n      last: \"team\",\r\n    },\r\n    password: \"k.9MSn#JJh+§3F3a\",\r\n    isAdministrator: true,\r\n    address: a,\r\n    birthDate: new Date(),\r\n    gender: \"male\",\r\n    isActive: true,\r\n    socialMediaUrls: {\r\n      facebook: \"facebook.com\",\r\n      instagram: \"instagram.com\",\r\n    },\r\n  };\r\n\r\n  try {\r\n    const user = await User.create(u);\r\n  } catch (error) {\r\n    console.error(\"Error creating admin user:\", error);\r\n  }\r\n};\r\nexport default createAdminUser;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\swagger.ts",{"fileContent":"// Copyrights Code: https://github.com/TomDoesTech/REST-API-Tutorial-Updated/blob/main/src/utils/swagger.ts\r\n\r\nimport { Express, Request, Response } from \"express\";\r\nimport swaggerJsdoc from \"swagger-jsdoc\";\r\nimport swaggerUi from \"swagger-ui-express\";\r\nimport { version } from \"../../package.json\";\r\n\r\nconst options: swaggerJsdoc.Options = {\r\n  definition: {\r\n    openapi: \"3.1.0\",\r\n    info: {\r\n      title: \"Explore and Connect REST API Docs\",\r\n      version,\r\n    },\r\n    components: {\r\n      securitySchemes: {\r\n        bearerAuth: {\r\n          type: \"http\",\r\n          scheme: \"bearer\",\r\n          bearerFormat: \"JWT\",\r\n        },\r\n      },\r\n      schemas: {\r\n        IAddress: {\r\n          type: \"object\",\r\n          properties: {\r\n            postalCode: {\r\n              type: \"string\",\r\n            },\r\n            city: {\r\n              type: \"string\",\r\n            },\r\n          },\r\n        },\r\n        IEAddress: {\r\n          type: \"object\",\r\n          properties: {\r\n            street: {\r\n              type: \"string\",\r\n            },\r\n            houseNumber: {\r\n              type: \"string\",\r\n            },\r\n            apartmentNumber: {\r\n              type: \"string\",\r\n            },\r\n            postalCode: {\r\n              type: \"string\",\r\n            },\r\n            city: {\r\n              type: \"string\",\r\n            },\r\n            stateOrRegion: {\r\n              type: \"string\",\r\n            },\r\n            country: {\r\n              type: \"string\",\r\n            },\r\n          },\r\n        },\r\n        ICategory: {\r\n          type: \"object\",\r\n          properties: {\r\n            name: {\r\n              type: \"string\",\r\n            },\r\n            description: {\r\n              type: \"string\",\r\n            },\r\n          },\r\n        },\r\n        IChat: {\r\n          type: \"object\",\r\n          properties: {\r\n            // Define IChat properties\r\n          },\r\n        },\r\n        IUser: {\r\n          type: \"object\",\r\n          properties: {\r\n            email: {\r\n              type: \"string\",\r\n            },\r\n            name: {\r\n              type: \"object\",\r\n              properties: {\r\n                first: {\r\n                  type: \"string\",\r\n                },\r\n                last: {\r\n                  type: \"string\",\r\n                },\r\n              },\r\n            },\r\n            password: {\r\n              type: \"string\",\r\n            },\r\n            isAdministrator: {\r\n              type: \"boolean\",\r\n            },\r\n            address: {\r\n              $ref: \"#/components/schemas/IAddress\",\r\n            },\r\n            profilePicture: {\r\n              type: \"string\",\r\n            },\r\n            birthDate: {\r\n              type: \"date\",\r\n              format: \"date\",\r\n            },\r\n            gender: {\r\n              type: \"string\",\r\n            },\r\n            socialMediaUrls: {\r\n              type: \"object\",\r\n              properties: {\r\n                facebook: {\r\n                  type: \"string\",\r\n                },\r\n                instagram: {\r\n                  type: \"string\",\r\n                },\r\n              },\r\n            },\r\n            isActive: {\r\n              type: \"boolean\",\r\n            },\r\n          },\r\n        },\r\n        IEvent: {\r\n          type: \"object\",\r\n          properties: {\r\n            name: {\r\n              type: \"string\",\r\n            },\r\n            creator: {\r\n              $ref: \"#/components/schemas/IUser\", // Reference to IUser schema\r\n            },\r\n            description: {\r\n              type: \"string\",\r\n            },\r\n            price: {\r\n              type: \"number\",\r\n              minimum: 0,\r\n            },\r\n            date: {\r\n              type: \"string\", // Date represented as string in ISO 8601 format\r\n              format: \"date-time\",\r\n            },\r\n            address: {\r\n              $ref: \"#/components/schemas/IEAddress\",\r\n            },\r\n            thumbnail: {\r\n              type: \"string\",\r\n            },\r\n            hashtags: {\r\n              type: \"array\",\r\n              items: {\r\n                type: \"string\",\r\n              },\r\n            },\r\n            category: {\r\n              type: \"array\",\r\n              items: {\r\n                $ref: \"#/components/schemas/ICategory\",\r\n              },\r\n            },\r\n            chat: {\r\n              $ref: \"#/components/schemas/IChat\", // Reference to IChat schema\r\n            },\r\n            participants: {\r\n              type: \"array\",\r\n              items: {\r\n                type: \"string\",\r\n              },\r\n            },\r\n          },\r\n        },\r\n        IComment: {\r\n          type: \"object\",\r\n          properties: {\r\n            title: {\r\n              type: \"string\",\r\n            },\r\n            stars: {\r\n              type: \"number\",\r\n              minimum: 1,\r\n              maximum: 5,\r\n            },\r\n            content: {\r\n              type: \"string\",\r\n            },\r\n            edited: {\r\n              type: \"boolean\",\r\n            },\r\n            creator: {\r\n              $ref: \"#/components/schemas/IUser\",\r\n            },\r\n            event: {\r\n              $ref: \"#/components/schemas/IEvent\",\r\n            },\r\n            createdAt: {\r\n              type: \"string\",\r\n              format: \"date-time\",\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n    security: [\r\n      {\r\n        bearerAuth: [],\r\n      },\r\n    ],\r\n  },\r\n  apis: [\"./src/routes/*.ts\", \"./src/model/*.ts\"],\r\n};\r\n\r\nconst swaggerSpec = swaggerJsdoc(options);\r\n\r\nfunction swaggerDocs(app: Express, port: number) {\r\n  // Swagger page\r\n  app.use(\"/swagger/docs\", swaggerUi.serve, swaggerUi.setup(swaggerSpec));\r\n\r\n  // Docs in JSON format\r\n  app.get(\"/docs.json\", (req: Request, res: Response) => {\r\n    res.setHeader(\"Content-Type\", \"application/json\");\r\n    res.send(swaggerSpec);\r\n  });\r\n\r\n  console.log(`Docs available at https://localhost:${port}/swagger/docs`);\r\n}\r\n\r\nexport default swaggerDocs;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/package.json"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\UserRoute.ts",{"fileContent":"import express from \"express\";\r\nimport fs from \"fs\";\r\nimport {\r\n  body,\r\n  check,\r\n  matchedData,\r\n  param,\r\n  validationResult,\r\n} from \"express-validator\";\r\nimport { UserService } from \"../services/UserService\";\r\nimport { upload, deleteProfilePicture } from \"../utils/FileUpload\";\r\nimport { validate } from \"../utils/Helpers\";\r\nimport { requiresAuthentication } from \"./authentication\";\r\nimport { userResource } from \"../Resources\";\r\nconst UserRouter = express.Router();\r\nconst userService = new UserService();\r\n\r\n/**\r\n * @swagger\r\n * /api/users/register:\r\n *   post:\r\n *     summary: Register a new user\r\n *     description: Register a new user with user data and an optional profile picture.\r\n *     tags:\r\n *       - User\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         multipart/form-data:\r\n *           schema:\r\n *              type: object\r\n *              properties:\r\n *                profilePicture:\r\n *                  type: string\r\n *                  example: []\r\n *                  format: binary\r\n *                email:\r\n *                  type: string\r\n *                  example: \"John@doe.com\"\r\n *                name[first]:\r\n *                  type: string\r\n *                  example: \"Test\"\r\n *                name[last]:\r\n *                  type: string\r\n *                  example: \"User\"\r\n *                password:\r\n *                  type: string\r\n *                  example: \"12abcAB!\"\r\n *                birthDate:\r\n *                  type: string\r\n *                  example: \"2000-01-01\"\r\n *                gender:\r\n *                  type: string\r\n *                  example: \"Male\"\r\n *                address[postalCode]:\r\n *                  type: string\r\n *                  example: \"12345\"\r\n *                address[city]:\r\n *                  type: string\r\n *                  example: \"Berlin\"\r\n *              required:\r\n *                - email\r\n *                - password\r\n *                - gender\r\n *                - birthDate\r\n *                - name[first]\r\n *                - name[last]\r\n *                - address[postalCode]\r\n *                - address[city]\r\n *     responses:\r\n *       201:\r\n *         description: User registered successfully\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IUser'\r\n *       409:\r\n *         description: User already exists\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: User already exists\r\n *       500:\r\n *         description: Registration failed\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Registration failed\r\n */\r\nUserRouter.post(\r\n  \"/register\",\r\n  upload.single(\"profilePicture\"),\r\n  [\r\n    body(\"email\").isEmail(),\r\n    body(\"name.first\")\r\n      .isString()\r\n      .isLength({ min: 3, max: 100 })\r\n      .withMessage(\"First name is required.\"),\r\n    body(\"name.last\")\r\n      .isString()\r\n      .isLength({ min: 3, max: 100 })\r\n      .withMessage(\"Last name is required.\"),\r\n    body(\"password\").isStrongPassword(),\r\n    body(\"isAdministrator\").optional().isBoolean(),\r\n    body(\"address.postalCode\")\r\n      .notEmpty()\r\n      .withMessage(\"Postal code is required.\"),\r\n    body(\"address.city\").notEmpty().withMessage(\"City is required.\"),\r\n    body(\"profilePicture\").optional().isString(),\r\n    body(\"birthDate\").isDate(),\r\n    body(\"gender\").isString().notEmpty(),\r\n    body(\"socialMediaUrls.facebook\").optional().isString(),\r\n    body(\"socialMediaUrls.instagram\").optional().isString(),\r\n  ],\r\n  async (req, res) => {\r\n    try {\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        if (req.file) {\r\n          // Delete the file\r\n          deleteProfilePicture(req.file.path);\r\n        }\r\n        return res.status(400).json({ errors: errors.array() });\r\n      } else {\r\n        if (req.file) {\r\n          req.body.profilePicture = `/${req.file.filename}`;\r\n        }\r\n        console.log(\"Req body user registration:\", req.body);\r\n        const newUser = await userService.registerUser(req.body);\r\n        return res.status(201).json(newUser);\r\n      }\r\n    } catch (error) {\r\n      if (error.message === \"User already exists\") {\r\n        return res.status(409).json({ Error: \"User already exists\" });\r\n      } else {\r\n        return res.status(500).json({ Error: \"Registration failed\" });\r\n      }\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/users/{userid}:\r\n *   get:\r\n *     summary: \"Get User\"\r\n *     deprecated: false\r\n *     description: \"Retrieve a user by ID\"\r\n *     tags:\r\n *       - \"User\"\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user to retrieve\"\r\n *     responses:\r\n *       \"200\":\r\n *         description: \"OK\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"403\":\r\n *         description: \"Forbidden - Invalid authorization\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Invalid authorization, cannot get User.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Invalid userID\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"No user with this ID exists.\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nUserRouter.get(\r\n  \"/:userid\",\r\n  requiresAuthentication,\r\n  param(\"userid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    const userid = req.params.userid;\r\n    if (req.role !== \"a\" && userid !== req.userId) {\r\n      res.status(403);\r\n      next(new Error(\"Invalid authorization, can not get User.\"));\r\n    } else {\r\n      try {\r\n        const user: userResource = await userService.getUser(userid);\r\n        res.status(200).json(user);\r\n      } catch (err) {\r\n        res.status(404);\r\n        next(err);\r\n      }\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/users/{userid}:\r\n *   put:\r\n *     summary: Update user details\r\n *     description: Update user details for a specific user.\r\n *     tags:\r\n *       - User\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user to update\"\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         multipart/form-data:\r\n *           schema:\r\n *             type: object\r\n *             properties:\r\n *               profilePicture:\r\n *                 type: string\r\n *                 example: []\r\n *                 format: binary\r\n *               email:\r\n *                 type: string\r\n *                 example: \"John@doe.com\"\r\n *               name[first]:\r\n *                     type: string\r\n *                     example: \"Test\"\r\n *               name[last]:\r\n *                     type: string\r\n *                     example: \"User\"\r\n *               password:\r\n *                 type: string\r\n *                 example: \"12abcAB!12abcAB!\"\r\n *               oldPassword:\r\n *                 type: string\r\n *                 example: \"12abcAB!\"\r\n *               birthDate:\r\n *                 type: string\r\n *                 example: \"2000-01-01\"\r\n *               gender:\r\n *                 type: string\r\n *                 example: \"Male\"\r\n *               address[postalCode]:\r\n *                 type: string\r\n *                 example: \"12345\"\r\n *               address[city]:\r\n *                 type: string\r\n *                 example: \"Berlin\"\r\n *     responses:\r\n *       200:\r\n *         description: User details updated successfully\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IUser'\r\n *       403:\r\n *         description: Invalid authorization\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Invalid authorization, cannot update user\r\n *       404:\r\n *         description: User not found\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: User not found\r\n *       500:\r\n *         description: Update failed\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Update failed\r\n */\r\nUserRouter.put(\r\n  \"/:userid\",\r\n  requiresAuthentication,\r\n  upload.single(\"profilePicture\"),\r\n  [param(\"userid\").isMongoId()],\r\n  // validate,\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      if (req.file) {\r\n        // Delete the file\r\n        deleteProfilePicture(req.file.path);\r\n      }\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    const userid = req.params.userid;\r\n    if (req.role === \"a\" || userid === req.userId) {\r\n      const user: userResource = await userService.getUser(userid);\r\n      try {\r\n        if (req.file) {\r\n          req.body.profilePicture = `/${req.file.filename}`;\r\n          if (user.profilePicture) {\r\n            deleteProfilePicture(user.profilePicture);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        deleteProfilePicture(req.body.profilePicture);\r\n        res.status(404).json({\r\n          Error: \"Can not delete Profile picture - no such file or directory\",\r\n        });\r\n      }\r\n    }\r\n    //req.body.name = JSON.parse(req.body.name);\r\n    const userResource = req.body as userResource; //matchedData(req) as userResource;\r\n    userResource.id = userid;\r\n    if (req.role === \"a\") {\r\n      try {\r\n        const updatedUser: userResource =\r\n          await userService.updateUserWithAdmin(userResource);\r\n        res.status(200).send(updatedUser);\r\n      } catch (err) {\r\n        res.status(404);\r\n        next(err);\r\n      }\r\n    } else {\r\n      if (req.userId !== userid) {\r\n        res.status(403);\r\n        next(new Error(\"Invalid authorization, can not update user.\"));\r\n      } else {\r\n        try {\r\n          let oldPw!: string;\r\n          if (req.body.oldPassword) {\r\n            oldPw = req.body.oldPassword;\r\n          }\r\n          console.log(\"oldPw:\", oldPw);\r\n          const updatedUser = await userService.updateUserWithPw(\r\n            userResource,\r\n            oldPw\r\n          );\r\n          res.status(200).send(updatedUser);\r\n        } catch (err) {\r\n          res.status(403);\r\n          next(new Error(\"Invalid authorization, probably invalid password.\"));\r\n        }\r\n      }\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/users/{userid}:\r\n *   delete:\r\n *     summary: \"Delete User\"\r\n *     deprecated: false\r\n *     description: \"Delete a user by ID\"\r\n *     tags:\r\n *       - \"User\"\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user to delete\"\r\n *     responses:\r\n *       \"204\":\r\n *         description: \"OK\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"403\":\r\n *         description: \"Forbidden - Invalid authorization\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Invalid authorization, cannot delete user.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Probably invalid userid\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Probably invalid userid, cannot delete user.\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\n\r\nUserRouter.delete(\r\n  \"/:userid\",\r\n  requiresAuthentication,\r\n  param(\"userid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const userid = req.params.userid;\r\n    try {\r\n      if (req.role === \"a\") {\r\n        const user: userResource = await userService.getUser(userid);\r\n        const isDeleted: boolean = await userService.deleteUser(userid, false);\r\n        try {\r\n          if (user.profilePicture) {\r\n            deleteProfilePicture(user.profilePicture);\r\n          }\r\n        } catch (err) {\r\n          res.status(404).json({\r\n            Error: \"Can not delete Profile picture - no such file or directory\",\r\n          });\r\n        }\r\n        res.status(204).send(isDeleted);\r\n      } else {\r\n        if (req.userId === userid) {\r\n          const user: userResource = await userService.getUser(userid);\r\n          const isDeleted: boolean = await userService.deleteUser(userid, true);\r\n          try {\r\n            if (user.profilePicture) {\r\n              deleteProfilePicture(user.profilePicture);\r\n            }\r\n          } catch (err) {\r\n            res.status(404).json({\r\n              Error:\r\n                \"Can not delete Profile picture - no such file or directory\",\r\n            });\r\n          }\r\n          res.status(204).send(isDeleted);\r\n        } else {\r\n          res.send(403);\r\n          next(new Error(\"Invalid authorization, can not delete user.\"));\r\n        }\r\n      }\r\n    } catch (err) {\r\n      res.send(404);\r\n      next(new Error(\"Probably invalid userid, can not delete user.\"));\r\n    }\r\n  }\r\n);\r\nexport default UserRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/FileUpload.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/Helpers.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\UserService.ts",{"fileContent":"import { User } from \"../model/UserModel\";\r\nimport { usersResource, userResource } from \"../Resources\";\r\nimport { CommentService } from \"../../src/services/CommentService\";\r\n\r\nconst commentService: CommentService = new CommentService();\r\n\r\nexport class UserService {\r\n  async registerUser(user: any) {\r\n    if (!user || typeof user !== \"object\") {\r\n      throw new Error(\"Invalid user data\");\r\n    }\r\n    // Check if the user already exists in the database\r\n    const { email } = user;\r\n    const existingUser = await User.findOne({ email });\r\n\r\n    if (existingUser) {\r\n      throw new Error(\"User already exists\");\r\n    }\r\n    // Create a new user\r\n    try {\r\n      const newUser = await User.create(user);\r\n      return newUser;\r\n    } catch (error) {\r\n      throw new Error(\"Registration failed\");\r\n    }\r\n  }\r\n\r\n  async getUsers(): Promise<usersResource> {\r\n    const users = await User.find({}).exec();\r\n    const usersResource: usersResource = {\r\n      users: users.map((user) => ({\r\n        id: user.id,\r\n        name: user.name,\r\n        email: user.email,\r\n        isAdministrator: user.isAdministrator,\r\n        address: user.address,\r\n        profilePicture: user.profilePicture,\r\n        birthDate: user.birthDate,\r\n        gender: user.gender,\r\n        socialMediaUrls: user.socialMediaUrls,\r\n        isActive: user.isActive,\r\n      })),\r\n    };\r\n    return usersResource;\r\n  }\r\n\r\n  async getUser(userID: string): Promise<userResource> {\r\n    if (!userID) {\r\n      throw new Error(\"Can not get user, userID is invalid\");\r\n    }\r\n    const user = await User.findOne({ _id: userID, isActive: true }).exec();\r\n    if (!user) {\r\n      throw new Error(`No user with id: ${userID} exists.`);\r\n    }\r\n    return {\r\n      id: user.id,\r\n      name: user.name,\r\n      email: user.email,\r\n      isAdministrator: user.isAdministrator,\r\n      address: user.address,\r\n      profilePicture: user.profilePicture,\r\n      birthDate: user.birthDate,\r\n      gender: user.gender,\r\n      socialMediaUrls: user.socialMediaUrls,\r\n      isActive: user.isActive,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * used to prefill db with standard admin user. Therefore this servicemethod does not need an endpoint.\r\n   * @param userResource\r\n   * @returns userResource\r\n   */\r\n  async createUser(userResource: userResource): Promise<userResource> {\r\n    const user = await User.create({\r\n      name: userResource.name,\r\n      email: userResource.email,\r\n      isAdministrator: userResource.isAdministrator,\r\n      address: userResource.address,\r\n      password: userResource.password,\r\n      profilePicture: userResource.profilePicture,\r\n      birthDate: userResource.birthDate,\r\n      gender: userResource.gender,\r\n      socialMediaUrls: userResource.socialMediaUrls,\r\n    });\r\n\r\n    return {\r\n      id: user.id,\r\n      name: user.name,\r\n      email: user.email,\r\n      isAdministrator: user.isAdministrator,\r\n      address: user.address,\r\n      profilePicture: user.profilePicture,\r\n      birthDate: user.birthDate,\r\n      gender: user.gender,\r\n      socialMediaUrls: user.socialMediaUrls,\r\n      isActive: user.isActive,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Admin function to update userdata. can update password & isAdministrator.\r\n   * @param userResource\r\n   * @returns userResource of updated user.\r\n   */\r\n  async updateUserWithAdmin(userResource: userResource): Promise<userResource> {\r\n    if (!userResource.id) {\r\n      throw new Error(\"User id is missing, cannot update User.\");\r\n    }\r\n\r\n    const user = await User.findById(userResource.id).exec();\r\n    if (!user) {\r\n      throw new Error(\r\n        `No user with id: ${userResource.id} found, cannot update`\r\n      );\r\n    }\r\n\r\n    for (const property in userResource) {\r\n      if (userResource.hasOwnProperty(property)) {\r\n        if (property === \"oldPassword\") {\r\n          continue;\r\n        }\r\n\r\n        if (property === \"name\") {\r\n          user.name.first = userResource.name.first;\r\n          user.name.last = userResource.name.last;\r\n        } else {\r\n          user[property] = userResource[property];\r\n        }\r\n        if (property === \"address\") {\r\n          user.address.postalCode = userResource.address.postalCode;\r\n          user.address.city = userResource.address.city;\r\n        } else {\r\n          user[property] = userResource[property];\r\n        }\r\n      }\r\n    }\r\n\r\n    const savedUser = await user.save();\r\n    return savedUser;\r\n  }\r\n\r\n  async updateUserWithPw(\r\n    userResource: userResource,\r\n    oldPw?: string\r\n  ): Promise<userResource> {\r\n    if (!userResource.id) {\r\n      throw new Error(\"User id is missing, cannot update User.\");\r\n    }\r\n\r\n    const user = await User.findById(userResource.id).exec();\r\n    if (!user) {\r\n      throw new Error(\r\n        `No user with id: ${userResource.id} found, cannot update`\r\n      );\r\n    }\r\n    console.log(\"user:\", user);\r\n    if (oldPw) {\r\n      console.log(\"oldPw\");\r\n      const res = await user.isCorrectPassword(oldPw);\r\n      if (!res) {\r\n        throw new Error(\"Invalid oldPassword, cannot update User!\");\r\n      }\r\n    }\r\n    console.log(\"userResource:\", userResource);\r\n    for (const property in userResource) {\r\n      console.log(\"property:\", property);\r\n      if (property === \"oldPassword\") continue;\r\n      if (property === \"Password\") {\r\n        console.log(\"userResource.password:\", userResource[property]);\r\n        user.password = userResource[property];\r\n        console.log(\"user.password:\", user.password);\r\n      } else {\r\n        user[property] = userResource[property];\r\n      }\r\n    }\r\n\r\n    const savedUser = await user.save();\r\n    return savedUser;\r\n  }\r\n\r\n  /**\r\n   * This function is used to either disable a user account or to delete the account from the database.\r\n   * If the logged-in user is an admin (role in req.role === \"a\") and performs the \"delete\" endpoint request,\r\n   * inactivateAccount is set to false, and the user is deleted from the database.\r\n   * Otherwise, the user himself deactivates his account, and inactivateAccount is set to true.\r\n   * @param userID The ID of the user to be deactivated or deleted.\r\n   * @param inactivateAccount If true, user.isActive is set to false and the user object remains in the database; otherwise, the admin deletes the user from the database.\r\n   * @returns true if the user was deleted or inactivated, false if no user was deleted.\r\n   */\r\n  async deleteUser(\r\n    userID: string,\r\n    inactivateAccount: boolean\r\n  ): Promise<boolean> {\r\n    if (!userID) {\r\n      throw new Error(\"invalid userID, can not delete/inactivate account\");\r\n    }\r\n    const u = await User.findOne({ _id: userID }).exec();\r\n    if (!u) {\r\n      throw new Error(\r\n        \"User not found, probably invalid userID or user is already deleted\"\r\n      );\r\n    }\r\n    if (inactivateAccount) {\r\n      u.isActive = false;\r\n      const user = await u.save();\r\n      return !user.isActive;\r\n    } else {\r\n      const res = await User.deleteOne({ _id: userID });\r\n      if (res.deletedCount === 1) {\r\n        await commentService.deleteCommentsOfUser(userID);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default new UserService();\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\FileUpload.ts",{"fileContent":"import multer from \"multer\";\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\n//Copyright of script: https://medium.com/@bviveksingh96/uploading-images-files-with-multer-in-node-js-f942e9319600\r\n\r\nconst storage = multer.diskStorage({\r\n  destination: function (req, file, cb) {\r\n    const uploadFolderPath = getUploadFolderPath(file.fieldname);\r\n\r\n    // Check if the folder exists, create it if it doesn't\r\n    if (!fs.existsSync(uploadFolderPath)) {\r\n      fs.mkdirSync(uploadFolderPath, { recursive: true });\r\n    }\r\n\r\n    cb(null, uploadFolderPath);\r\n  },\r\n\r\n  filename: function (req, file, cb) {\r\n    const uniqueFilename = `${uuidv4()}-${file.originalname}`;\r\n    cb(null, uniqueFilename);\r\n  },\r\n});\r\nconst fileFilter = (req: any, file: any, cb: any) => {\r\n  if (\r\n    file.mimetype === \"image/jpg\" ||\r\n    file.mimetype === \"image/jpeg\" ||\r\n    file.mimetype === \"image/png\"\r\n  ) {\r\n    cb(null, true);\r\n  } else {\r\n    cb(new Error(\"Image uploaded is not of type jpg/jpeg or png\"), false);\r\n  }\r\n};\r\n// This function is created with chatgpt\r\nfunction getUploadFolderPath(fieldName: string): string {\r\n  //const uploadPath = process.env.UPLOAD_PATH || \"uploads\"; // Get upload path from .env file or use default 'uploads'\r\n  const uploadPath = \"uploads\";\r\n  const backendPath = path.join(__dirname, \"../../Backend\"); // Assuming 'FileUpload.ts' is in the 'utils' directory\r\n\r\n  if (fieldName === \"profilePicture\") {\r\n    return path.join(backendPath, uploadPath, \"users\");\r\n  } else if (fieldName === \"thumbnail\") {\r\n    return path.join(backendPath, uploadPath, \"events\");\r\n  } else {\r\n    return path.join(backendPath, uploadPath); // Default upload folder for other cases\r\n  }\r\n}\r\n\r\nexport function deleteProfilePicture(filePath: string): void {\r\n  try {\r\n    const fullPath = path.join(\r\n      __dirname,\r\n      \"../../Backend\",\r\n      \"uploads/users\",\r\n      filePath\r\n    ); // Assuming 'FileUpload.ts' is in the 'utils' directory\r\n    console.log(\"fullPath:\", fullPath);\r\n    fs.unlinkSync(fullPath);\r\n    console.log(\"file deleted\", fullPath);\r\n  } catch (error) {\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport function deleteEventThumbnail(filePath: string): void {\r\n  try {\r\n    const fullPath = path.join(filePath); // Assuming 'FileUpload.ts' is in the 'utils' directory\r\n    console.log(\"fullpath image:\", fullPath);\r\n    fs.unlinkSync(fullPath);\r\n  } catch (error) {\r\n    throw error;\r\n  }\r\n}\r\n\r\n// file size : 10 MB limit\r\nexport const upload = multer({\r\n  storage: storage,\r\n  fileFilter: fileFilter,\r\n  limits: { fileSize: 10 * 1024 * 1024 },\r\n});\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\Helpers.ts",{"fileContent":"import { IUser } from \"../model/UserModel\";\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport { validationResult, body } from \"express-validator\";\r\n\r\nconst validateIfPresent = (field: string, validators: any) => {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    // Check if the field exists in the request body and has a value\r\n    // && req.body[field] !== \"\"\r\n    if (req.body[field] !== undefined) {\r\n      return validators(req, res, next);\r\n    }\r\n    // If the field is absent or empty, skip the validation\r\n    return next();\r\n  };\r\n};\r\n\r\n// Validation middleware\r\nexport const validate = [\r\n  validateIfPresent(\"email\", body(\"email\").isEmail()),\r\n  validateIfPresent(\"name.first\", body(\"name.first\").isString()),\r\n  validateIfPresent(\"name.last\", body(\"name.last\").isString()),\r\n  validateIfPresent(\"password\", body(\"password\").isStrongPassword()),\r\n  validateIfPresent(\"isAdministrator\", body(\"isAdministrator\").isBoolean()),\r\n\r\n  //validateIfPresent(\"oldPassword\", body(\"oldPassword\").isStrongPassword()),\r\n  validateIfPresent(\r\n    \"address.postalCode\",\r\n    body(\"address.postalCode\")\r\n      .isNumeric()\r\n      .withMessage(\"Postal code is required.\")\r\n  ),\r\n  validateIfPresent(\r\n    \"address.city\",\r\n    body(\"address.city\").isString().withMessage(\"City is required.\")\r\n  ),\r\n  validateIfPresent(\r\n    \"address.country\",\r\n    body(\"address.country\").isString().withMessage(\"Country is required.\")\r\n  ),\r\n  validateIfPresent(\"profilePicture\", body(\"profilePicture\").isString()),\r\n  validateIfPresent(\"birthDate\", body(\"birthDate\").isString()),\r\n  validateIfPresent(\"gender\", body(\"gender\").isString()),\r\n  validateIfPresent(\r\n    \"socialMediaUrls.facebook\",\r\n    body(\"socialMediaUrls.facebook\").isString()\r\n  ),\r\n  validateIfPresent(\r\n    'socialMediaUrls.instagram\"',\r\n    body(\"socialMediaUrls.instagram\").isString()\r\n  ),\r\n];\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\authentication.ts",{"fileContent":"import { NextFunction, Request, Response } from \"express\";\r\nimport { verifyJWT } from \"../services/JWTService\";\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    /**\r\n     * Wir erweitern das Interface `Request` um die Felder `userId` und `role`.\r\n     */\r\n    export interface Request {\r\n      /**\r\n       * Mongo-ID of currently logged in user; or undefined, if user is a guest.\r\n       */\r\n      userId?: string;\r\n      role: \"u\" | \"a\";\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Prüft Authentifizierung und schreibt `userId` mit Mongo-ID des Users und `role` mit Kürzel der Rolle in den Request.\r\n * Falls Authentifizierung fehlschlägt, wird ein Fehler (401) erzeugt.\r\n */\r\nexport async function requiresAuthentication(\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction,\r\n) {\r\n  try {\r\n    const authorization = req.headers.authorization;\r\n    if (authorization && authorization.startsWith(\"Bearer \")) {\r\n      const token = authorization.substring(\"Bearer \".length);\r\n      const { userId, role } = verifyJWT(token);\r\n      if (!userId || !role) {\r\n        res.status(401);\r\n        return next(new Error(\"Authentication Failed\"));\r\n      }\r\n      req.userId = userId;\r\n      req.role = role;\r\n      next();\r\n    } else {\r\n      res.status(401);\r\n      res.setHeader(\"WWW-Authenticate\", [\"Bearer\", 'realm=\"app\"']);\r\n      next(new Error(\"authentication required!\"));\r\n    }\r\n  } catch (err) {\r\n    res.status(401);\r\n    res.setHeader(\"WWW-Authenticate\", [\r\n      \"Bearer\",\r\n      'realm=\"app\"',\r\n      'error=\"invalid_token\"',\r\n    ]);\r\n    next(err);\r\n  }\r\n}\r\n\r\n/**\r\n * Prüft Authentifizierung und schreibt `userId` mit Mongo-ID des Users und `role` mit Kürzel der Rolle in den Request.\r\n * Falls kein JSON-Web-Token im Request-Header vorhanden ist, wird kein Fehler erzeugt (und auch nichts in den Request geschrieben).\r\n * Falls Authentifizierung fehlschlägt, wird ein Fehler (401) erzeugt.\r\n */\r\nexport async function optionalAuthentication(\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction,\r\n) {\r\n  const authorization = req.headers.authorization;\r\n  if (authorization) {\r\n    try {\r\n      const token = authorization.split(\" \")[1];\r\n      const { userId, role } = verifyJWT(token);\r\n      if (!userId || !role) {\r\n        res.status(401);\r\n        return next(new Error(\"Authentication Failed\"));\r\n      }\r\n      req.userId = userId;\r\n      req.role = role;\r\n      next();\r\n    } catch (err) {\r\n      res.status(401);\r\n      next(err);\r\n    }\r\n  } else {\r\n    next();\r\n  }\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\JWTService.ts",{"fileContent":"import { JwtPayload, sign, verify } from \"jsonwebtoken\";\r\nimport { User } from \"../model/UserModel\";\r\nimport dotenv from \"dotenv\";\r\ndotenv.config();\r\n/**\r\n * @param email E-Mail-Adresse des Users\r\n * @param password Das Passwort des Users\r\n * @returns JWT als String, im JWT ist sub gesetzt mit der Mongo-ID des Users als String sowie role mit \"u\" oder \"a\" (User oder Admin);\r\n *      oder undefined wenn Authentifizierung fehlschlägt.\r\n */\r\nexport async function verifyPasswordAndCreateJWT(\r\n  email: string,\r\n  password: string,\r\n): Promise<string | undefined> {\r\n  const users = await User.find({ email: email, isActive: true }).exec();\r\n  if (!users || users.length != 1) {\r\n    return undefined;\r\n  }\r\n  const user = users[0];\r\n  if (!(await user.isCorrectPassword(password))) {\r\n    return undefined;\r\n  }\r\n\r\n  const secret = process.env.JWT_SECRET;\r\n  if (!secret) {\r\n    throw new Error(\"JWT_SECRET not set\");\r\n  }\r\n  const timeInSec = Math.floor(Date.now() / 1000);\r\n\r\n  const ttl = process.env.JWT_TTL;\r\n  if (!ttl) {\r\n    throw new Error(\"TTL not set\");\r\n  }\r\n\r\n  const exp = timeInSec + (24 * 60 * 60);\r\n  const role = user.isAdministrator ? \"a\" : \"u\";\r\n\r\n  const payload: JwtPayload = {\r\n    sub: user.id,\r\n    iat: timeInSec,\r\n    exp: exp,\r\n    role: role,\r\n  };\r\n  const jwtString = sign(payload, secret, { algorithm: \"HS256\" });\r\n  return jwtString;\r\n}\r\n\r\n/**\r\n * Gibt user id (Mongo-ID) und ein Kürzel der Rolle zurück, falls Verifizierung erfolgreich, sonst wird ein Error geworfen.\r\n *\r\n * Die zur Prüfung der Signatur notwendige Passphrase wird aus der Umgebungsvariable `JWT_SECRET` gelesen,\r\n * falls diese nicht gesetzt ist, wird ein Fehler geworfen.\r\n *\r\n * @param jwtString das JWT\r\n * @return user id des Users (Mongo ID als String) und Rolle (u oder a) des Benutzers;\r\n *      niemals undefined (bei Fehler wird ein Error geworfen)\r\n */\r\nexport function verifyJWT(jwtString: string | undefined): {\r\n  userId: string;\r\n  role: \"u\" | \"a\";\r\n} {\r\n  if (!jwtString) {\r\n    throw new Error(\"No JWT-string\");\r\n  }\r\n  const secret = process.env.JWT_SECRET;\r\n  if (!secret) {\r\n    throw new Error(\"JWT_SECRET not set\");\r\n  }\r\n  try {\r\n    const payload = verify(jwtString, secret);\r\n    if (typeof payload === \"object\" && \"sub\" in payload && payload.sub) {\r\n      const result = { userId: payload.sub?.toString()!, role: payload.role };\r\n      return result;\r\n    }\r\n  } catch (err) {\r\n    throw new Error(\"verify_error\");\r\n  }\r\n  throw new Error(\"invalid_token\");\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\UsersRouter.ts",{"fileContent":"import express from \"express\";\r\nimport { UserService } from \"../services/UserService\";\r\nimport { requiresAuthentication } from \"./authentication\";\r\nimport { usersResource } from \"../Resources\";\r\n\r\nconst UsersRouter = express.Router();\r\nconst userService = new UserService();\r\n/**\r\n * @swagger\r\n * /api/users/:\r\n *   get:\r\n *     summary: \"Get Users\"\r\n *     deprecated: false\r\n *     description: \"Retrieve all users\"\r\n *     tags:\r\n *       - \"User\"\r\n *     responses:\r\n *       \"200\":\r\n *         description: \"OK\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"403\":\r\n *         description: \"Forbidden - Invalid authorization\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Invalid authorization.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Users not found\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Users not found.\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nUsersRouter.get(\"/users\", requiresAuthentication, async (req, res, next) => {\r\n  if (req.role !== \"a\") {\r\n    res.status(403);\r\n    next(new Error(\"Invalid authorization\"));\r\n  } else {\r\n    try {\r\n      const users: usersResource = await userService.getUsers();\r\n      res.status(200).send(users);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n});\r\n\r\nexport default UsersRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\login.ts",{"fileContent":"import express from \"express\";\r\nimport { body, matchedData, validationResult } from \"express-validator\";\r\nimport { LoginResource } from \"../Resources\";\r\nimport { verifyPasswordAndCreateJWT } from \"../services/JWTService\";\r\n\r\nconst loginRouter = express.Router();\r\n/**\r\n * @swagger\r\n * /api/login/:\r\n *  \"post\":\r\n *    \"summary\": \"Login user\"\r\n *    \"description\": \"Endpoint to log in a user\"\r\n *    \"tags\": [\r\n *      \"User\"\r\n *    ]\r\n *    \"parameters\": []\r\n *    \"requestBody\":\r\n *      \"content\":\r\n *        \"application/json\":\r\n *          \"schema\":\r\n *            \"type\": \"object\"\r\n *            \"properties\":\r\n *              \"email\":\r\n *                \"type\": \"string\"\r\n *              \"password\":\r\n *                \"type\": \"string\"\r\n *            \"required\":\r\n *              - \"email\"\r\n *              - \"password\"\r\n *          \"example\":\r\n *            \"email\": \"John@doe.com\"\r\n *            \"password\": \"12abcAB!\"\r\n *    \"responses\":\r\n *      \"200\":\r\n *        \"description\": \"OK\"\r\n *        \"content\":\r\n *          \"application/json\":\r\n *            \"schema\":\r\n *              \"type\": \"object\"\r\n *              \"properties\": {}\r\n *      \"400\":\r\n *        \"description\": \"Bad Request - Validation Error\"\r\n *        \"content\":\r\n *          \"application/json\":\r\n *            \"schema\":\r\n *              \"type\": \"object\"\r\n *              \"properties\":\r\n *                \"error\":\r\n *                  \"type\": \"string\"\r\n *                  \"example\": \"Validation failed: Please provide a valid email and password.\"\r\n *      \"401\":\r\n *        \"description\": \"Unauthorized - Missing JWT\"\r\n *        \"content\":\r\n *          \"application/json\":\r\n *            \"schema\":\r\n *              \"type\": \"object\"\r\n *              \"properties\":\r\n *                \"error\":\r\n *                  \"type\": \"string\"\r\n *                  \"example\": \"Unauthorized: No JWT token provided.\"\r\n *    \"security\":\r\n *      - \"bearerAuth\": []\r\n */\r\n/**\r\n * Diese Funktion bitte noch nicht implementieren, sie steht hier als Platzhalter.\r\n * Wir benötigen dafür Authentifizierungsinformationen, die wir später in einem JSW speichern.\r\n */\r\nloginRouter.post(\r\n  \"/\",\r\n  body(\"email\").isEmail(),\r\n  body(\"password\").isStrongPassword(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    //const loginResource = matchedData(req) as LoginResource;\r\n    const resource = matchedData(req);\r\n    const jwtstring = await verifyPasswordAndCreateJWT(\r\n      resource.email,\r\n      resource.password,\r\n    );\r\n    if (!jwtstring) {\r\n      res.status(401);\r\n      next(new Error(\"no jwtstring\"));\r\n    }\r\n    const result: LoginResource = {\r\n      access_token: jwtstring!,\r\n      token_type: \"Bearer\",\r\n    };\r\n    res.send(result);\r\n  },\r\n);\r\n\r\nexport default loginRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\EventRoute.ts",{"fileContent":"import express from \"express\";\r\nimport { EventService } from \"../services/EventService\";\r\nimport {\r\n  optionalAuthentication,\r\n  requiresAuthentication,\r\n} from \"./authentication\";\r\nimport { eventResource, eventsResource } from \"../Resources\";\r\nimport {\r\n  body,\r\n  matchedData,\r\n  param,\r\n  query,\r\n  validationResult,\r\n} from \"express-validator\";\r\nimport { deleteEventThumbnail, upload } from \"../utils/FileUpload\";\r\n\r\nconst EventRouter = express.Router();\r\nconst eventService = new EventService();\r\n\r\n/**\r\n * @swagger\r\n * /api/events/search:\r\n *   get:\r\n *     summary: \"Search for events\"\r\n *     description: \"Search events based on a query string\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"query\"\r\n *         in: \"query\"\r\n *         required: true\r\n *         schema:\r\n *           type: \"string\"\r\n *         description: \"The query string to search for events\"\r\n *     responses:\r\n *       200:\r\n *         description: \"Successful response\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: \"#/components/schemas/IEvent\"\r\n *       204:\r\n *         description: \"No events found matching the query\"\r\n *       400:\r\n *         description: \"Bad request. Validation error in the query string\"\r\n *       404:\r\n *         description: \"Not found. The requested resource does not exist\"\r\n *       500:\r\n *         description: \"Internal server error\"\r\n */\r\nEventRouter.get(\r\n  \"/search\",\r\n  optionalAuthentication,\r\n  [query(\"query\").isString().notEmpty()],\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    try {\r\n      //console.log(query)\r\n      const term = req.query.query as string;\r\n      const events: eventsResource = await eventService.searchEvents(term);\r\n      if (events.events.length === 0) {\r\n        return res\r\n          .status(204)\r\n          .json({ message: \"No events found matching the query.\" });\r\n      }\r\n      res.status(200).send(events);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n\r\n/**\r\n * @swagger\r\n * /api/events/create:\r\n *   post:\r\n *     summary: Create a new event.\r\n *     description: Endpoint to create a new event.\r\n *     tags:\r\n *       - \"Event\"\r\n *     security:\r\n *       - bearerAuth: []\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         multipart/form-data:\r\n *           schema:\r\n *             type: object\r\n *             properties:\r\n *               name:\r\n *                 type: string\r\n *                 description: Name of the event.\r\n *                 example: Test Event\r\n *               price:\r\n *                 type: number\r\n *                 description: Price of the event.\r\n *                 example: 10\r\n *               description:\r\n *                 type: string\r\n *                 description: Description of the event.\r\n *                 example: This is a test event description.\r\n *               date:\r\n *                 type: string\r\n *                 format: date-time\r\n *                 description: Date of the event.\r\n *                 example: \"2024-01-01T12:00:00Z\"\r\n *               address:\r\n *                 type: object\r\n *                 properties:\r\n *                   street:\r\n *                     type: string\r\n *                     description: Street address.\r\n *                     example: 123 Test Street\r\n *                   houseNumber:\r\n *                     type: string\r\n *                     description: House number.\r\n *                     example: 1A\r\n *                   postalCode:\r\n *                     type: string\r\n *                     description: Postal code.\r\n *                     example: \"12345\"\r\n *                   city:\r\n *                     type: string\r\n *                     description: City.\r\n *                     example: Test City\r\n *                   country:\r\n *                     type: string\r\n *                     description: Country.\r\n *                     example: Test Country\r\n *               thumbnail:\r\n *                 type: string\r\n *                 format: binary\r\n *                 description: Event thumbnail file (image).\r\n *               hashtags:\r\n *                 type: array\r\n *                 items:\r\n *                   type: string\r\n *                 description: Array of event hashtags (optional).\r\n *                 example: [\"test\", \"event\"]\r\n *               category:\r\n *                 type: array\r\n *                 items:\r\n *                   type: object\r\n *                   properties:\r\n *                     name:\r\n *                       type: string\r\n *                       description: Category name.\r\n *                       example: Test Category\r\n *                     description:\r\n *                       type: string\r\n *                       description: Category description.\r\n *                       example: This is a test category.\r\n *                 description: Array of event categories.\r\n *                 example: [{ \"name\": \"Test Category\", \"description\": \"This is a test category.\" }]\r\n *     responses:\r\n *       '201':\r\n *         description: Event created successfully.\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IEvent'\r\n *       '400':\r\n *         description: Bad request. Invalid input parameters.\r\n *       '401':\r\n *         description: Unauthorized. Missing or invalid authentication token.\r\n *       '500':\r\n *         description: Internal server error. Failed to create an event.\r\n */\r\n\r\nEventRouter.post(\r\n  \"/create\",\r\n  requiresAuthentication,\r\n  upload.single(\"thumbnail\"),\r\n  [\r\n    body(\"name\").isString().notEmpty().withMessage(\"Event name is required.\"),\r\n    //body(\"creator\").isString().notEmpty(),\r\n    // body(\"price\").isNumeric().notEmpty(),\r\n    body(\"description\")\r\n      .isString()\r\n      .notEmpty()\r\n      .withMessage(\"Description is required.\"),\r\n    body(\"date\") /* .isDate() */\r\n      .notEmpty(),\r\n    body(\"address.street\")\r\n      .notEmpty()\r\n      .withMessage(\"Street address is required.\"),\r\n    body(\"address.houseNumber\")\r\n      .notEmpty()\r\n      .withMessage(\"House number is required.\"),\r\n    body(\"address.postalCode\")\r\n      .notEmpty()\r\n      .withMessage(\"Postal code is required.\"),\r\n    body(\"address.city\").notEmpty().withMessage(\"City is required.\"),\r\n    body(\"address.country\").notEmpty().withMessage(\"Country is required.\"),\r\n    body(\"address.stateOrRegion\")\r\n      .optional()\r\n      .isString()\r\n      .withMessage(\"Invalid State or Region.\"),\r\n    body(\"address.apartmentNumber\")\r\n      .optional()\r\n      .isString()\r\n      .withMessage(\"Invalid Apartment number.\"),\r\n    //body(\"hashtags\").optional().isArray(),\r\n    //body(\"category\").isArray().notEmpty().withMessage(\"Categories are required.\"),\r\n    //body(\"chat\").isString().notEmpty(),\r\n  ],\r\n  async (req, res) => {\r\n    try {\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        if (req.file) {\r\n          // Delete the file\r\n          console.log(\"errors:\", errors);\r\n          deleteEventThumbnail(req.file.path);\r\n        }\r\n        return res.status(400).json({ errors: errors.array() });\r\n      } else {\r\n        if (req.file) {\r\n          console.log(\"req.file\", req.file);\r\n          req.body.thumbnail = `/${req.file.filename}`;\r\n          console.log(\"Event bild uploaded\");\r\n        }\r\n\r\n        req.body.category = JSON.parse(req.body.category);\r\n        req.body.hashtags = JSON.parse(req.body.hashtags);\r\n        req.body.price = Number(req.body.price);\r\n        req.body.address = JSON.parse(req.body.address);\r\n        console.log(\"Event data \", req.body);\r\n        const newEvent = await eventService.createEvent(req.body, req.userId);\r\n        return res.status(201).send(newEvent);\r\n      }\r\n    } catch (err) {\r\n      return res.status(500).json({ Error: \"Event creation failed\" });\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}/join:\r\n *   post:\r\n *     summary: \"Join an event\"\r\n *     deprecated: false\r\n *     description: \"The User can join event\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to join\"\r\n *     responses:\r\n *       \"200\":\r\n *         description: \"User joined the event successfully\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"409\":\r\n *         description: \"User is already participating in the event\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"User is already participating in the event.\"\r\n *       \"404\":\r\n *         description: \"Not Found - Invalid userID\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"No user or event with this ID exists.\"\r\n *       \"500\":\r\n *         description: \"Joining event failed\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Joining event failed\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.post(\r\n  \"/:eventid/join\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      await eventService.joinEvent(req.userId, req.params.eventid);\r\n      res.status(200).json({ message: \"User joined the event successfully\" });\r\n    } catch (err) {\r\n      if (err.message === \"User not found\") {\r\n        return res.status(404).json({ Error: err.message });\r\n      } else if (err.message === \"Event not found\") {\r\n        return res.status(404).json({ Error: err.message });\r\n      } else if (err.message === \"User is already participating in the event\") {\r\n        return res.status(409).json({ Error: err.message });\r\n      } else {\r\n        return res.status(500).json({ Error: \"Joining event failed\" });\r\n      }\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}/cancel:\r\n *   delete:\r\n *     summary: \"Cancel participating in event\"\r\n *     deprecated: false\r\n *     description: \"Canceling of participating in event\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to cancel participating in\"\r\n *     responses:\r\n *       \"204\":\r\n *         description: \"User canceled the participating in the event successfully\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"409\":\r\n *         description: \"User is not participating in the event or Can not cancel participation as event manager\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"User is not participating in the event or Can not cancel participation as event manager\"\r\n *       \"500\":\r\n *         description: \"Canceling event failed\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties:\r\n *                 error:\r\n *                   type: \"string\"\r\n *                   example: \"Canceling event failed\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.delete(\r\n  \"/:eventid/cancel\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      await eventService.cancelEvent(req.userId, req.params.eventid);\r\n      res.status(204).send();\r\n    } catch (err) {\r\n      if (\r\n        err.message === \"User is not participating in the event\" ||\r\n        err.message === \"Can not cancel participation as event manager\"\r\n      ) {\r\n        return res.status(409).json({ Error: err.message });\r\n      } else {\r\n        return res.status(500).json({ Error: \"Canceling event failed\" });\r\n      }\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/joined:\r\n *   get:\r\n *     summary: \"Get all joined events\"\r\n *     deprecated: false\r\n *     description: \"Retrieve all participated events ( Event participant )\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     responses:\r\n *       '200':\r\n *         description: Returns all joined events\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 events:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/IEvent'\r\n *       '204':\r\n *         description: No events found\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 message:\r\n *                   type: string\r\n *       '404':\r\n *         description: Not found\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.get(\"/joined\", requiresAuthentication, async (req, res, next) => {\r\n  try {\r\n    const events: eventsResource = await eventService.getJoinedEvents(\r\n      req.userId\r\n    );\r\n    if (events.events.length === 0) {\r\n      return res.status(204).json({ message: \"No events found.\" });\r\n    }\r\n    res.status(200).send(events);\r\n  } catch (err) {\r\n    res.status(404);\r\n    next(err);\r\n  }\r\n});\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}/participants:\r\n *   get:\r\n *     summary: \"Retrieve all participants in event\"\r\n *     deprecated: false\r\n *     description: \"Retrieve a list of all participants in event\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to cancel participating in\"\r\n *     responses:\r\n *       200:\r\n *         description: \"Successful response\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"array\"\r\n *               items:\r\n *                 type: \"string\"\r\n *                 description: \"User ID of a participant\"\r\n *       404:\r\n *         description: \"Event not found or no participants found for the specified event\"\r\n *       500:\r\n *         description: \"Internal server error\"\r\n */\r\nEventRouter.get(\r\n  \"/:eventid/participants\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const participants = await eventService.getParticipants(\r\n        req.params.eventid,\r\n        req.userId\r\n      );\r\n      res.status(200).send(participants);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}:\r\n *   get:\r\n *     summary: \"Retrieve information of an event\"\r\n *     deprecated: false\r\n *     description: \"Retrieve all data of Event with eventid\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to retrieve the event data\"\r\n *     responses:\r\n *       200:\r\n *         description: \"Successful response\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *               $ref: '#/components/schemas/IEvent'\r\n *       400:\r\n *         description: \"Validation error\"\r\n *       404:\r\n *         description: \"Event not found for the specified event\"\r\n *       500:\r\n *         description: \"Internal server error\"\r\n */\r\nEventRouter.get(\r\n  \"/:eventid\",\r\n  optionalAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    try {\r\n      const event = await eventService.getEvent(req.params.eventid);\r\n      res.status(200).send(event);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n\r\nEventRouter.put(\r\n  \"/:eventid\",\r\n  requiresAuthentication,\r\n  upload.single(\"thumbnail\"),\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      if (req.file) {\r\n        // Delete the file\r\n        deleteEventThumbnail(req.file.path);\r\n      }\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    try {\r\n      const event = await eventService.getEvent(req.params.eventid);\r\n      if (req.file) {\r\n        req.body.thumbnail = `/uploads/${req.file.filename}`;\r\n        if (event.thumbnail) deleteEventThumbnail(event.thumbnail);\r\n      }\r\n      const eventResource = req.body as eventResource;\r\n      const updatedEvent = await eventService.updateEvent(\r\n        req.params.eventid,\r\n        eventResource,\r\n        req.userId\r\n      );\r\n      res.status(200).send(updatedEvent);\r\n    } catch (err) {\r\n      deleteEventThumbnail(req.body.thumbnail);\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/{eventid}:\r\n *   delete:\r\n *     summary: \"Delete event\"\r\n *     deprecated: false\r\n *     description: \"Deleting event with eventID as an event manager or admin\"\r\n *     tags:\r\n *       - \"Event\"\r\n *     parameters:\r\n *       - name: \"eventid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the event to delete\"\r\n *     responses:\r\n *       \"204\":\r\n *         description: \"Event successfully deleted\"\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: \"object\"\r\n *               properties: {}\r\n *       \"405\":\r\n *         description: \"Event could not be deleted\"\r\n *       \"404\":\r\n *         description: \"Event not found\"\r\n *     security:\r\n *       - bearerAuth: []\r\n */\r\nEventRouter.delete(\r\n  \"/:eventid\",\r\n  requiresAuthentication,\r\n  param(\"eventid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const event = await eventService.getEvent(req.params.eventid);\r\n      const deleted = await eventService.deleteEvent(\r\n        req.params.eventid,\r\n        req.userId\r\n      );\r\n      if (event.thumbnail) deleteEventThumbnail(event.thumbnail);\r\n      if (deleted) {\r\n        res.status(204).json({ message: \"Event successfully deleted\" });\r\n      } else {\r\n        res.status(405).json({ error: \"Event could not be deleted\" });\r\n      }\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/creator/{userid}:\r\n *   get:\r\n *     summary: Get all created events of a user\r\n *     deprecated: false\r\n *     description: \"Retrieve all events created by a user where the user is an admin or retrieve events associated with the authenticated user.\"\r\n *     tags:\r\n *       - Event\r\n *     parameters:\r\n *       - name: \"userid\"\r\n *         in: \"path\"\r\n *         required: true\r\n *         type: \"string\"\r\n *         description: \"The ID of the user\"\r\n *     security:\r\n *       - bearerAuth: []\r\n *     responses:\r\n *       '200':\r\n *         description: Returns all created events\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 events:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/IEvent'\r\n *       '204':\r\n *         description: No events found\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 message:\r\n *                   type: string\r\n *       '403':\r\n *         description: Invalid authorization\r\n *       '404':\r\n *         description: Not found\r\n */\r\nEventRouter.get(\r\n  \"/creator/:userid\",\r\n  requiresAuthentication,\r\n  param(\"userid\").isMongoId(),\r\n  async (req, res, next) => {\r\n    if (req.role === \"a\" || req.params.userid === req.userId) {\r\n      try {\r\n        const userID = req.params.userid;\r\n        const events: eventsResource = await eventService.getEvents(userID);\r\n        if (events.events.length === 0) {\r\n          return res.status(204).json({ message: \"No events found.\" });\r\n        }\r\n        res.status(200).send(events);\r\n      } catch (err) {\r\n        res.status(404);\r\n        next(err);\r\n      }\r\n    } else {\r\n      res.status(403);\r\n      next(new Error(\"Invalid authorization\"));\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/events/:\r\n *   get:\r\n *     summary: Get all events\r\n *     tags:\r\n *       - Event\r\n *     security:\r\n *       - bearerAuth: []\r\n *     responses:\r\n *       '200':\r\n *         description: Returns all events\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 events:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/IEvent'\r\n *       '204':\r\n *         description: No events found\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 message:\r\n *                   type: string\r\n *       '404':\r\n *         description: Not found\r\n */\r\nEventRouter.get(\"/\", optionalAuthentication, async (req, res, next) => {\r\n  try {\r\n    const events: eventsResource = await eventService.getAllEvents();\r\n    if (events.events.length === 0) {\r\n      return res.status(204).json({ message: \"No events found.\" });\r\n    }\r\n    res.status(200).send(events);\r\n  } catch (err) {\r\n    res.status(404);\r\n    next(err);\r\n  }\r\n});\r\n\r\nexport default EventRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/FileUpload.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\routes\\UserRoute.test.ts",{"fileContent":"import mongoose from \"mongoose\";\r\nimport { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport app from \"../../server\";\r\n//import { req } from \"../jest.setup\";\r\nimport { IAddress, User } from \"../../src/model/UserModel\";\r\nimport {\r\n  LoginResource,\r\n  userResource,\r\n  usersResource,\r\n} from \"../../src/Resources\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\nimport request from \"supertest\";\r\nconst a: IAddress = {\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n};\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  //profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst JaneData: userResource = {\r\n  email: \"Jane@doe.com\",\r\n  name: {\r\n    first: \"Jane\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  // profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\nlet admin: userResource;\r\nlet AdminToken: string;\r\nlet jane: userResource;\r\nlet token: string;\r\nlet req = request(app);\r\ndescribe(\"userRoute test\", () => {\r\n  beforeAll(async () => await connect());\r\n  beforeEach(async () => {\r\n    admin = await userService.createUser(u);\r\n    jane = await userService.createUser(JaneData);\r\n    //const req = request(app);\r\n    const adminloginData = { email: \"John@doe.com\", password: \"12abcAB!\" };\r\n    const adminRes = await req.post(`/api/login`).send(adminloginData);\r\n    const AdminLoginResource = adminRes.body as LoginResource;\r\n    AdminToken = AdminLoginResource.access_token;\r\n\r\n    const janeLoginData = { email: \"Jane@doe.com\", password: \"12abcAB!\" };\r\n    const janeRes = await req.post(`/api/login`).send(janeLoginData);\r\n    const janeLoginResource = janeRes.body as LoginResource;\r\n    token = janeLoginResource.access_token;\r\n  });\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => {\r\n    await mongoose.connection.close(); // Perform final cleanup after all tests\r\n  });\r\n\r\n  /* test(\"getUsers\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(\"/api/users\")\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(200);\r\n    const users: usersResource = response.body;\r\n    expect(users.users.length).toBe(3);\r\n    let userPos: number;\r\n    if (users.users[0].name.first === u.name.first) {\r\n      userPos = 0;\r\n    } else if (users.users[1].name.first === u.name.first) {\r\n      userPos = 1;\r\n    } else if (users.users[2].name.first === u.name.first) {\r\n      userPos = 2;\r\n    }\r\n    expect(users.users[userPos].id).toBeDefined();\r\n    expect(users.users[userPos].name.first).toBe(u.name.first);\r\n    expect(users.users[userPos].name.last).toBe(u.name.last);\r\n    expect(users.users[userPos].email).toBe(u.email);\r\n    expect(users.users[userPos].password).toBeUndefined();\r\n    expect(users.users[userPos].address).toMatchObject(a);\r\n    //expect(users.users[0].birthDate).toBe(u.birthDate);\r\n    expect(users.users[userPos].gender).toBe(u.gender);\r\n    expect(users.users[userPos].isActive).toBeTruthy();\r\n    //expect(users.users[0].profilePicture).toBe(u.profilePicture);\r\n    expect(users.users[userPos].socialMediaUrls).toMatchObject(\r\n      u.socialMediaUrls\r\n    );\r\n  }); */\r\n\r\n  test(\"getUsers fails on request by non-admin\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(\"/api/users\")\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(response.statusCode).toBe(403);\r\n  });\r\n\r\n  test(\"get User request responses with 404 on invalid userID\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(`/api/users/${NON_EXISTING_ID}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n\r\n    expect(response.statusCode).toBe(404);\r\n  });\r\n\r\n  test(\"get User request responses with 400 on undefined userID\", async () => {\r\n    //const req = request(app);\r\n    const response = await req\r\n      .get(`/api/users/invalidID`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n\r\n    expect(response.statusCode).toBe(400);\r\n    expect(response.body.errors).toBeDefined();\r\n  });\r\n\r\n  test(\"get User returns any user when performed by an admin and returns user when performed by non-admin\", async () => {\r\n    const response = await req\r\n      .get(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(200);\r\n    expect(response.body.name.first).toBe(jane.name.first);\r\n\r\n    const res = await req\r\n      .get(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(200);\r\n    expect(res.body.name.first).toBe(jane.name.first);\r\n  });\r\n\r\n  test(\"put user successfully updates user in db and returns updated user information\", async () => {\r\n    const newName = \"newName\";\r\n    jane.name.last = newName;\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(jane)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(200);\r\n    expect(res.body.name.last).toBe(newName);\r\n\r\n    const janeDataFromDB = await User.findById(jane.id).exec();\r\n    expect(janeDataFromDB.name.last).toBe(newName);\r\n\r\n    const updatedName = \"newName-adminUpdate\";\r\n    jane.name.last = updatedName;\r\n    const response = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(jane)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.body.name.last).toBe(updatedName);\r\n\r\n    const janeDataFromDBAdminUpdate = await User.findById(jane.id).exec();\r\n    expect(janeDataFromDBAdminUpdate.name.last).toBe(updatedName);\r\n  });\r\n\r\n  test(\"should return error on updating email to duplicate email\", async () => {\r\n    jane.email = admin.email;\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(jane)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.statusCode).toBe(404);\r\n  });\r\n\r\n  test(\"should return error on trying to update other users as non-admin\", async () => {\r\n    admin.name.first = \"newName\";\r\n    const res = await req\r\n      .put(`/api/users/${admin.id}`)\r\n      .send(admin)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(403);\r\n  });\r\n\r\n  test(\"testing for validation errors on put user route\", async () => {\r\n    const invalidUserResource: userResource = {\r\n      email: \"\",\r\n      name: {\r\n        first: \"\",\r\n        last: \"\",\r\n      },\r\n      isAdministrator: false,\r\n      address: a,\r\n      birthDate: jane.birthDate,\r\n      gender: \"\",\r\n      isActive: true,\r\n    };\r\n\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(invalidUserResource)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(400);\r\n    expect(res.body.errors).toBeDefined();\r\n  });\r\n\r\n  test(\"put user with invalid old password returns error\", async () => {\r\n    const requestData = jane;\r\n    requestData.oldPassword = \"invalidPW123!\";\r\n    requestData.password = \"newStrongPassword123!\";\r\n\r\n    const res = await req\r\n      .put(`/api/users/${jane.id}`)\r\n      .send(requestData)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.statusCode).toBe(403);\r\n\r\n    const dbJane = await User.findById(jane.id).exec();\r\n    expect(await dbJane.isCorrectPassword(\"newPassowrd\")).toBeFalsy();\r\n  });\r\n\r\n  test(\"should allow an admin to delete any user\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(204);\r\n  });\r\n\r\n  test(\"should allow a user to inactivate their own account\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${jane.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(response.statusCode).toBe(204);\r\n  });\r\n\r\n  test(\"should prevent a non-admin user from deleting another user\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${admin.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(response.statusCode).toBe(403);\r\n  });\r\n\r\n  test(\"should return an error for an invalid user ID\", async () => {\r\n    const response = await req\r\n      .delete(`/api/users/${NON_EXISTING_ID}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(response.statusCode).toBe(404);\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/server.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/createTestData.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/Comments.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\services\\EventService.test.ts",{"fileContent":"import { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  addressEResource,\r\n  categoryResource,\r\n  eventResource,\r\n  eventsResource,\r\n  userResource,\r\n  usersResource,\r\n} from \"../../src/Resources\";\r\nimport { Event } from \"../../src/model/EventModel\";\r\nimport { User } from \"../../src/model/UserModel\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\n\r\nconst a: addressEResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst eventService: EventService = new EventService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\n\r\ndescribe(\"EventService Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create event\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    expect(event.id).toBeDefined();\r\n    expect(event.name).toBe(e.name);\r\n    expect(event.creator).toBeDefined;\r\n    expect(event.description).toBe(e.description);\r\n    expect(event.price).toBe(e.price);\r\n    expect(event.date).toBe(e.date);\r\n    expect(event.address).toMatchObject(a);\r\n    expect(event.thumbnail).toBe(e.thumbnail);\r\n    expect(event.hashtags).toStrictEqual(e.hashtags);\r\n    expect(event.category.map((c) => c.name)).toContain(\"Hobbys\");\r\n    expect(event.chat).toBeDefined();\r\n    expect(event.participants.length).toBe(1);\r\n    // identical event data should still work\r\n    const event1 = await eventService.createEvent(e, user.id);\r\n    expect(event1).toBeDefined();\r\n    expect(event1.id).not.toBe(event.id);\r\n    expect(event1.name).toBe(event.name);\r\n    expect(event1.creator).toBe(event.creator);\r\n    expect(event1.description).toBe(event.description);\r\n    expect(event1.price).toBe(event.price);\r\n    expect(event1.date).toBe(event.date);\r\n    expect(event1.thumbnail).toBe(event.thumbnail);\r\n    expect(event1.hashtags).toStrictEqual(event.hashtags);\r\n    expect(event1.chat).not.toBe(event.chat);\r\n    expect(event.participants.length).toBe(event.participants.length);\r\n  });\r\n\r\n  test(\"get event\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    await expect(eventService.getEvent(undefined)).rejects.toThrow();\r\n    await expect(eventService.getEvent(NON_EXISTING_ID)).rejects.toThrow();\r\n    const er = await eventService.getEvent(event.id);\r\n    const em = await Event.findById(event.id);\r\n    expect(er.id).toBe(em.id);\r\n    expect(er.name).toBe(em.name);\r\n    expect(er.creator).toBeDefined();\r\n    expect(er.description).toBe(em.description);\r\n    expect(er.price).toBe(em.price);\r\n    expect(er.date).toStrictEqual(em.date);\r\n    expect(er.address).toMatchObject(a);\r\n    expect(er.thumbnail).toBe(em.thumbnail);\r\n    expect(er.hashtags).toStrictEqual(em.hashtags);\r\n    expect(er.category.map((c) => c.name)).toContain(\"Hobbys\");\r\n    expect(er.chat).toBeDefined;\r\n    expect(er.participants.length).toBe(1);\r\n  });\r\n\r\n  test(\"get created events\", async () => {\r\n    await expect(eventService.getEvents(undefined)).rejects.toThrow();\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    await eventService.createEvent(e, user1.id);\r\n    await eventService.createEvent(e1, user1.id);\r\n    await eventService.createEvent(e2, user2.id);\r\n    const events = await eventService.getEvents(user1.id);\r\n    expect(events.events.length).toBe(2);\r\n    expect(events.events[0].name).toBe(\"Sample Event\");\r\n    expect(events.events[1].name).toBe(\"Sample Event 1\");\r\n  });\r\n\r\n  test(\"get all events\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    await eventService.createEvent(e, user1.id);\r\n    await eventService.createEvent(e1, user1.id);\r\n    await eventService.createEvent(e2, user2.id);\r\n    const events = await eventService.getAllEvents();\r\n    expect(events.events.length).toBe(3);\r\n    expect(events.events[0].name).toBe(\"Sample Event\");\r\n    expect(events.events[1].name).toBe(\"Sample Event 1\");\r\n    expect(events.events[2].name).toBe(\"Sample Event 2\");\r\n  });\r\n\r\n  test(\"search events\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    await eventService.createEvent(e, user1.id);\r\n    await eventService.createEvent(e1, user1.id);\r\n    await eventService.createEvent(e2, user2.id);\r\n    let events: eventsResource;\r\n    // search events by name\r\n    events = await eventService.searchEvents(\"sample event\");\r\n    expect(events.events.length).toBe(3);\r\n    expect(events.events[0].name).toBe(\"Sample Event\");\r\n    expect(events.events[1].name).toBe(\"Sample Event 1\");\r\n    expect(events.events[2].name).toBe(\"Sample Event 2\");\r\n    events = await eventService.searchEvents(\"Sample Event 2\");\r\n    expect(events.events.length).toBe(1);\r\n    expect(events.events[0].name).toBe(\"Sample Event 2\");\r\n    events = await eventService.searchEvents(\"event sample\");\r\n    expect(events.events.length).toBe(0);\r\n    events = await eventService.searchEvents(\"\");\r\n    expect(events.events.length).toBe(3);\r\n    events = await eventService.searchEvents(undefined);\r\n    expect(events.events.length).toBe(3);\r\n    // search events by description\r\n    events = await eventService.searchEvents(\"this is my\");\r\n    expect(events.events.length).toBe(2);\r\n    expect(events.events[0].description).toBe(\"This is my first event\");\r\n    expect(events.events[1].description).toBe(\"this is my second gym party\");\r\n    events = await eventService.searchEvents(\"for anyone\");\r\n    expect(events.events.length).toBe(1);\r\n    expect(events.events[0].description).toBe(\"for anyone interested\");\r\n    events = await eventService.searchEvents(\"this is my third event\");\r\n    expect(events.events.length).toBe(0);\r\n    // search events by hashtags\r\n    events = await eventService.searchEvents(\"sport\");\r\n    expect(events.events.length).toBe(1);\r\n    expect(events.events[0].hashtags[0]).toBe(\"sport\");\r\n    events = await eventService.searchEvents(\"freizeit\");\r\n    expect(events.events.length).toBe(2);\r\n    expect(events.events[0].hashtags[1]).toBe(\"freizeit\");\r\n    expect(events.events[1].hashtags[0]).toBe(\"freizeit\");\r\n    events = await eventService.searchEvents(\"sport freizeit\");\r\n    expect(events.events.length).toBe(0);\r\n  });\r\n\r\n  test(\"join event\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const event2 = await eventService.createEvent(e2, user2.id);\r\n    let result: eventResource;\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(1);\r\n    expect(result.participants[0]).toBe(user2.id);\r\n    expect(await eventService.joinEvent(user1.id, event2.id)).toBeTruthy();\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    expect(result.participants[0]).toBe(user2.id);\r\n    expect(result.participants[1]).toBe(user1.id);\r\n    expect(await eventService.joinEvent(user2.id, event1.id)).toBeTruthy();\r\n    result = await eventService.getEvent(event1.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    // invalid/no id\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.joinEvent(user1.id, id)).rejects.toThrow(\r\n      \"Event not found\"\r\n    );\r\n    await expect(eventService.joinEvent(id, event1.id)).rejects.toThrow(\r\n      \"User not found\"\r\n    );\r\n    result = await eventService.getEvent(event1.id);\r\n    await expect(result.participants).toHaveLength(2);\r\n    await expect(\r\n      eventService.joinEvent(undefined, undefined)\r\n    ).rejects.toThrow();\r\n    // user already participating\r\n    await expect(eventService.joinEvent(user1.id, event2.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    await expect(eventService.joinEvent(user1.id, event1.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    await expect(eventService.joinEvent(user2.id, event1.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    await expect(eventService.joinEvent(user2.id, event2.id)).rejects.toThrow(\r\n      \"User is already participating in the event\"\r\n    );\r\n    result = await eventService.getEvent(event1.id);\r\n    expect(result.participants).toHaveLength(2);\r\n  });\r\n\r\n  test(\"get joined events\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    const user3 = await User.create(u2);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const event2 = await eventService.createEvent(e2, user1.id);\r\n    await eventService.joinEvent(user2.id, event1.id);\r\n    await eventService.joinEvent(user2.id, event2.id);\r\n    let result: eventsResource;\r\n    result = await eventService.getJoinedEvents(user2.id);\r\n    expect(result.events).toHaveLength(2);\r\n    expect(result.events[0].name).toBe(\"Sample Event 1\");\r\n    expect(result.events[1].name).toBe(\"Sample Event 2\");\r\n    result = await eventService.getJoinedEvents(user3.id);\r\n    expect(result.events).toHaveLength(0);\r\n  });\r\n\r\n  test(\"cancel event\", async () => {\r\n    const user1 = await User.create(u);\r\n    const user2 = await User.create(u1);\r\n    const user3 = await User.create(u2);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const event2 = await eventService.createEvent(e2, user2.id);\r\n    let result: eventResource;\r\n    await eventService.joinEvent(user1.id, event2.id);\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(2);\r\n    // invalid/no id\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.cancelEvent(user1.id, id)).rejects.toThrow(\r\n      \"Event not found\"\r\n    );\r\n    await expect(eventService.cancelEvent(id, event1.id)).rejects.toThrow();\r\n    await expect(\r\n      eventService.cancelEvent(undefined, undefined)\r\n    ).rejects.toThrow();\r\n    // user not participating\r\n    await expect(eventService.cancelEvent(user3.id, event2.id)).rejects.toThrow(\r\n      \"User is not participating in the event\"\r\n    );\r\n    // cancel participation works correctly\r\n    expect(await eventService.cancelEvent(user1.id, event2.id)).toBeTruthy();\r\n    result = await eventService.getEvent(event2.id);\r\n    expect(result.participants).toHaveLength(1);\r\n    // cancel participation as event creator should not work\r\n    await expect(eventService.cancelEvent(user1.id, event1.id)).rejects.toThrow(\r\n      \"Can not cancel participation as event manager\"\r\n    );\r\n    result = await eventService.getEvent(event1.id);\r\n    expect(result.participants).toHaveLength(1);\r\n    expect(result.creator).toBe(user1.id);\r\n  });\r\n\r\n  test(\"get participants of event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    let participants: usersResource;\r\n    // as event creator\r\n    participants = await eventService.getParticipants(event.id, user.id);\r\n    expect(participants.users).toHaveLength(1);\r\n    expect(participants.users[0].id).toBe(user.id);\r\n    await eventService.joinEvent(user1.id, event.id);\r\n    await eventService.joinEvent(user2.id, event.id);\r\n    participants = await eventService.getParticipants(event.id, user.id);\r\n    expect(participants.users).toHaveLength(3);\r\n    expect(participants.users[1].id).toBe(user1.id);\r\n    expect(participants.users[2].id).toBe(user2.id);\r\n    // not event creator but admin should work\r\n    participants = await eventService.getParticipants(event.id, user1.id);\r\n    expect(participants.users).toHaveLength(3);\r\n    // invalid authorization\r\n    await expect(\r\n      eventService.getParticipants(event.id, user2.id)\r\n    ).rejects.toThrow();\r\n    // participant count decreases after cancel participation\r\n    await eventService.cancelEvent(user1.id, event.id);\r\n    await eventService.cancelEvent(user2.id, event.id);\r\n    participants = await eventService.getParticipants(event.id, user.id);\r\n    expect(participants.users).toHaveLength(1);\r\n    expect(participants.users[0].id).toBe(user.id);\r\n  });\r\n\r\n  test(\"delete event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    let event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    let result: boolean;\r\n    result = await eventService.deleteEvent(event.id, user.id);\r\n    expect(result).toBeTruthy();\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n    // invalid/no id\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.deleteEvent(id, undefined)).rejects.toThrow();\r\n    await expect(eventService.deleteEvent(undefined, id)).rejects.toThrow();\r\n    // not event creator but admin should work\r\n    event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    result = await eventService.deleteEvent(event.id, user1.id);\r\n    expect(result).toBeTruthy();\r\n    await expect(eventService.getEvent(event.id)).rejects.toThrow();\r\n    // invalid authorization\r\n    event = await eventService.createEvent(e, user.id);\r\n    expect(event).toBeDefined();\r\n    await expect(\r\n      eventService.deleteEvent(event.id, user2.id)\r\n    ).rejects.toThrow();\r\n    expect(await eventService.getEvent(event.id)).toBeDefined();\r\n  });\r\n\r\n  test(\"update event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    expect(event.name).toBe(\"Sample Event\");\r\n    await eventService.updateEvent(event.id, e1, user.id);\r\n    const newevent = await eventService.getEvent(event.id);\r\n    // event updated correctly\r\n    expect(newevent).toBeDefined();\r\n    expect(newevent.id).toBe(event.id);\r\n    expect(newevent.name).toBe(\"Sample Event 1\");\r\n    expect(newevent.creator).toBe(event.creator);\r\n    expect(newevent.description).toBe(e1.description);\r\n    expect(newevent.price).toBe(e1.price);\r\n    expect(newevent.date).toStrictEqual(e1.date);\r\n    expect(newevent.address).toMatchObject(a);\r\n    expect(newevent.thumbnail).toBe(event.thumbnail);\r\n    expect(newevent.hashtags).toStrictEqual(event.hashtags);\r\n    expect(newevent.category.length).toBe(1);\r\n    expect(newevent.chat).toBe(event.chat);\r\n    expect(newevent.participants).toStrictEqual(event.participants);\r\n    // invalid/no data/ids\r\n    const id = NON_EXISTING_ID;\r\n    await expect(eventService.updateEvent(id, e1, user.id)).rejects.toThrow();\r\n    await expect(eventService.updateEvent(event.id, e1, id)).rejects.toThrow();\r\n    await expect(\r\n      eventService.updateEvent(event.id, undefined, user.id)\r\n    ).rejects.toThrow();\r\n    await expect(\r\n      eventService.updateEvent(undefined, undefined, undefined)\r\n    ).rejects.toThrow();\r\n    // not event creator but admin should work\r\n    const result = await eventService.updateEvent(event.id, e2, user1.id);\r\n    // eventresource returned correctly\r\n    expect(result).toBeDefined();\r\n    expect(result.id).toBe(event.id);\r\n    expect(result.name).toBe(\"Sample Event 2\");\r\n    expect(result.creator).toBe(event.creator);\r\n    expect(result.description).toBe(e2.description);\r\n    expect(result.price).toBe(e2.price);\r\n    expect(result.date).toStrictEqual(e2.date);\r\n    expect(result.address).toMatchObject(a);\r\n    expect(result.thumbnail).toBe(event.thumbnail);\r\n    expect(result.hashtags[0]).toBe(\"freizeit\");\r\n    expect(result.category.length).toBe(1);\r\n    expect(result.chat).toBe(event.chat);\r\n    expect(result.participants).toStrictEqual(event.participants);\r\n    // invalid authorization\r\n    await expect(\r\n      eventService.updateEvent(event.id, e2, user2.id)\r\n    ).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\services\\UserService.test.ts",{"fileContent":"import { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport { userResource } from \"../../src/Resources\";\r\nimport { IAddress, IUser, User } from \"../../src/model/UserModel\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\n\r\nconst a: IAddress = {\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n};\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\ndescribe(\"UserService test\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"createUser function\", async () => {\r\n    const user = await userService.createUser(u);\r\n    expect(user.id).toBeDefined();\r\n    expect(user.name.first).toBe(u.name.first);\r\n    expect(user.name.last).toBe(u.name.last);\r\n    expect(user.email).toBe(u.email);\r\n    expect(user.password).toBeUndefined();\r\n    const res = await User.findById(user.id);\r\n    expect(await res.isCorrectPassword(\"12abcAB!\")).toBeTruthy();\r\n    expect(user.address).toMatchObject(a);\r\n    expect(user.birthDate).toBe(u.birthDate);\r\n    expect(user.gender).toBe(u.gender);\r\n    expect(user.isActive).toBeTruthy();\r\n    expect(user.profilePicture).toBe(u.profilePicture);\r\n    expect(user.socialMediaUrls).toMatchObject(u.socialMediaUrls);\r\n  });\r\n\r\n  test(\"getUser works and returns user without password\", async () => {\r\n    const user = await userService.createUser(u);\r\n    await expect(userService.getUser(undefined)).rejects.toThrow(\r\n      \"Can not get user, userID is invalid\"\r\n    );\r\n    await expect(userService.getUser(NON_EXISTING_ID)).rejects.toThrow(\r\n      `No user with id: ${NON_EXISTING_ID} exists.`\r\n    );\r\n    const res: userResource = await userService.getUser(user.id);\r\n    expect(user.id).toBeDefined();\r\n    expect(user.name.first).toBe(u.name.first);\r\n    expect(user.name.last).toBe(u.name.last);\r\n    expect(user.email).toBe(u.email);\r\n    expect(user.password).toBeUndefined();\r\n    const r = await User.findById(user.id);\r\n    expect(await r.isCorrectPassword(\"12abcAB!\")).toBeTruthy();\r\n    expect(user.address).toMatchObject(a);\r\n    expect(user.birthDate).toBe(u.birthDate);\r\n    expect(user.gender).toBe(u.gender);\r\n    expect(user.isActive).toBeTruthy();\r\n    expect(user.profilePicture).toBe(u.profilePicture);\r\n    expect(user.socialMediaUrls).toMatchObject(u.socialMediaUrls);\r\n  });\r\n\r\n  test(\"get all users also returns inactive users, getUser(userID) throws error at inactive user.\", async () => {\r\n    const u1 = await userService.createUser(u);\r\n    const user1: userResource = {\r\n      id: u1.id,\r\n      email: u1.email,\r\n      name: {\r\n        first: u1.name.first,\r\n        last: u1.name.last,\r\n      },\r\n      isAdministrator: u1.isAdministrator,\r\n      address: u1.address,\r\n      birthDate: u1.birthDate,\r\n      gender: u1.gender,\r\n      isActive: u1.isActive,\r\n    };\r\n    u.isActive = false;\r\n    u.email = \"Jane@doe.com\";\r\n    u.name.first = \"Jane\";\r\n    const u2 = await User.create(u);\r\n    const user2: userResource = {\r\n      id: u2.id,\r\n      email: u2.email,\r\n      name: {\r\n        first: u2.name.first,\r\n        last: u2.name.last,\r\n      },\r\n      isAdministrator: u2.isAdministrator,\r\n      address: u2.address,\r\n      birthDate: u2.birthDate,\r\n      gender: u2.gender,\r\n      isActive: u2.isActive,\r\n    };\r\n    await expect(userService.getUser(u2.id)).rejects.toThrow(\r\n      `No user with id: ${u2.id} exists.`\r\n    );\r\n    const users = await userService.getUsers();\r\n    expect(users.users.length).toBe(2);\r\n    expect(users.users[0].isActive).toBe(user1.isActive);\r\n    expect(users.users[1].isActive).toBe(user2.isActive);\r\n  });\r\n\r\n  test(\"updateUserWithAdmin user update validations\", async () => {\r\n    const user = await userService.createUser(u);\r\n    const existingUserId = user.id;\r\n    const updatedUser = {\r\n      ...u,\r\n      id: existingUserId,\r\n      email: \"newemail@example.com\",\r\n    };\r\n    const result = await userService.updateUserWithAdmin(updatedUser);\r\n    expect(result.id).toBeDefined();\r\n    expect(result.name.first).toBe(updatedUser.name.first);\r\n    expect(result.name.last).toBe(updatedUser.name.last);\r\n    expect(result.email).toBe(updatedUser.email);\r\n    expect(result.password).toBeUndefined();\r\n    expect(result.address).toMatchObject(updatedUser.address);\r\n    expect(result.birthDate).toBe(updatedUser.birthDate);\r\n    expect(result.gender).toBe(updatedUser.gender);\r\n    expect(result.isActive).toBeTruthy();\r\n    expect(result.profilePicture).toBe(updatedUser.profilePicture);\r\n    expect(result.socialMediaUrls).toMatchObject(updatedUser.socialMediaUrls);\r\n\r\n    //Test for missing userID\r\n    const userWithNoId = { ...u, id: undefined };\r\n    await expect(userService.updateUserWithAdmin(userWithNoId)).rejects.toThrow(\r\n      \"User id is missing, cannot update User.\"\r\n    );\r\n\r\n    //Test for non-existing userID\r\n    const nonExistingUser = { ...u, id: NON_EXISTING_ID };\r\n    await expect(\r\n      userService.updateUserWithAdmin(nonExistingUser)\r\n    ).rejects.toThrow(\r\n      `No user with id: ${NON_EXISTING_ID} found, cannot update`\r\n    );\r\n  });\r\n\r\n  test(\"updateUserWithAdmin duplicate email check\", async () => {\r\n    const user = await userService.createUser(u);\r\n    await userService.createUser({ ...u, email: \"duplicate@example.com\" });\r\n    //Create another user with a different ID but same email for duplicate check\r\n    const userWithDuplicateEmail = { ...user, email: \"duplicate@example.com\" };\r\n    await expect(\r\n      userService.updateUserWithAdmin(userWithDuplicateEmail)\r\n    ).rejects.toThrow(\"Duplicate email\");\r\n  });\r\n\r\n  test(\"updateUserWithPw update with old password to update password\", async () => {\r\n    const oldPw: string = u.password;\r\n    const user: userResource = await userService.createUser(u);\r\n\r\n    user.name.first = \"Jane\";\r\n    user.password = \"newPassword123!\";\r\n    const updatedUser: userResource = await userService.updateUserWithPw(\r\n      user,\r\n      oldPw\r\n    );\r\n    expect(updatedUser.name.first).toBe(\"Jane\");\r\n    const Jane = await User.findById(user.id).exec();\r\n    expect(Jane.password).toBeDefined();\r\n    expect(await Jane.isCorrectPassword(\"newPassword123!\")).toBeTruthy();\r\n\r\n    //Test if user does not update Password on wrong old password.\r\n    await expect(\r\n      userService.updateUserWithPw(user, \"wrongPassword\")\r\n    ).rejects.toThrow(\"invalid oldPassword, can not update User!\");\r\n  });\r\n\r\n  test(\"updateUserWithPw throws errors on invalid userdata\", async () => {\r\n    const user: userResource = await userService.createUser(u);\r\n    user.id = undefined;\r\n    user.name.first = \"Jane\";\r\n    await expect(userService.updateUserWithPw(user)).rejects.toThrow(\r\n      \"User id is missing, cannot update User.\"\r\n    );\r\n    user.id = NON_EXISTING_ID;\r\n    await expect(userService.updateUserWithPw(user)).rejects.toThrow(\r\n      `No user with id: ${NON_EXISTING_ID} found, cannot update`\r\n    );\r\n  });\r\n\r\n  test(\"updateUserWithPw duplicate email check\", async () => {\r\n    const user = await userService.createUser(u);\r\n    await userService.createUser({ ...u, email: \"duplicate@example.com\" });\r\n    //Create another user with a different ID but same email for duplicate check\r\n    const userWithDuplicateEmail = { ...user, email: \"duplicate@example.com\" };\r\n    await expect(\r\n      userService.updateUserWithPw(userWithDuplicateEmail)\r\n    ).rejects.toThrow(\"Duplicate email\");\r\n  });\r\n\r\n  test(\"updateUserWithPw can not change isActive status of user\", async () => {\r\n    const user = await userService.createUser(u);\r\n    user.isActive = false;\r\n    user.name.first = \"Jane\";\r\n    const res = await userService.updateUserWithPw(user);\r\n    expect(res.isActive).toBeTruthy();\r\n    expect(res.name.first).toBe(\"Jane\");\r\n  });\r\n\r\n  test(\"deleteUser deletes user from database (when performed by an admin)\", async () => {\r\n    const user = await userService.createUser(u);\r\n    const res = await userService.deleteUser(user.id, false);\r\n    expect(res).toBeTruthy();\r\n    const noUserFound = await User.findById(user.id);\r\n    expect(noUserFound).toBeNull();\r\n\r\n    await expect(\r\n      userService.deleteUser(NON_EXISTING_ID, false)\r\n    ).rejects.toThrow(\r\n      \"User not found, probably invalid userID or user is already deleted\"\r\n    );\r\n    await expect(userService.deleteUser(\"\", false)).rejects.toThrow(\r\n      \"invalid userID, can not delete/inactivate account\"\r\n    );\r\n  });\r\n\r\n  test(\"deleteUser inactivates acc when inactivateAccount = true\", async () => {\r\n    const user = await userService.createUser(u);\r\n    const res = await userService.deleteUser(user.id, true);\r\n    expect(res).toBeTruthy();\r\n    const inactiveUser = await User.findById(user.id);\r\n    expect(inactiveUser.isActive).toBeFalsy();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\model\\UserModel.test.ts",{"fileContent":"import { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport { IAddress, IUser, User } from \"../../src/model/UserModel\";\r\n\r\nconst a: IAddress = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\nlet u: IUser = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"123\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\ndescribe(\"userModel test\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create User\", async () => {\r\n    const user = await User.create(u);\r\n    expect(user.id).toBeDefined();\r\n    expect(user.name.first).toBe(u.name.first);\r\n    expect(user.name.last).toBe(u.name.last);\r\n    expect(user.email).toBe(u.email);\r\n    expect(user.password).not.toBe(u.password);\r\n    expect(user.password).toBeDefined();\r\n    expect(await user.isCorrectPassword(\"123\")).toBeTruthy();\r\n    expect(user.address).toMatchObject(a);\r\n    expect(user.birthDate).toBe(u.birthDate);\r\n    expect(user.gender).toBe(u.gender);\r\n    expect(user.isActive).toBeTruthy();\r\n    expect(user.profilePicture).toBe(u.profilePicture);\r\n    expect(user.socialMediaUrls).toMatchObject(u.socialMediaUrls);\r\n  });\r\n\r\n  test(\"updated user password middleware\", async () => {\r\n    const user = await User.create(u);\r\n    user.password = \"456\";\r\n    user.email = \"John@some-host.de\";\r\n    await user.save();\r\n    const res = await User.findById(user.id);\r\n    expect(res.password).not.toBe(\"456\");\r\n    expect(res.password).not.toBe(\"123\");\r\n    expect(res.password).toBeDefined();\r\n    expect(await res.isCorrectPassword(\"456\")).toBeTruthy();\r\n    expect(res.email).toBe(\"John@some-host.de\");\r\n    expect(await User.findOne({ email: \"John@doe.com\" })).toBeNull();\r\n  });\r\n\r\n  test(\"rejects on duplicate email\", async () => {\r\n    await User.create(u);\r\n    u.name.first = \"Jane\";\r\n    await expect(User.create(u)).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\model\\EventModel.test.ts",{"fileContent":"import { Types } from \"mongoose\";\r\nimport { Event, ICategory, IEvent } from \"../../src/model/EventModel\";\r\nimport { clearDatabase, closeDatabase, connect } from \"../../database/db\";\r\nimport { IEAddress } from \"../../src/model/EventModel\";\r\n\r\nconst a: IEAddress = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: ICategory = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\ndescribe(\"Event Model Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create event\", async () => {\r\n    const eventData: IEvent = {\r\n      name: \"Test Event\",\r\n      creator: new Types.ObjectId(),\r\n      description: \"A test event\",\r\n      price: 10,\r\n      date: new Date(),\r\n      address: a,\r\n      category: [c],\r\n      chat: new Types.ObjectId(),\r\n      participants: [],\r\n    };\r\n    const createdEvent = await Event.create(eventData);\r\n    expect(createdEvent).toBeDefined();\r\n    expect(createdEvent.name).toBe(eventData.name);\r\n    expect(createdEvent.creator).toBe(eventData.creator);\r\n    expect(createdEvent.description).toBe(eventData.description);\r\n    expect(createdEvent.price).toBe(eventData.price);\r\n    expect(createdEvent.date).toBe(eventData.date);\r\n    expect(createdEvent.address).toMatchObject(a);\r\n    expect(createdEvent.category.map((c) => c.name)).toContain(\"Hobbys\");\r\n    expect(createdEvent.chat).toBe(eventData.chat);\r\n    expect(createdEvent.participants).toStrictEqual(eventData.participants);\r\n  });\r\n\r\n  test(\"empty eventdata\", async () => {\r\n    const eventData: IEvent = {\r\n      name: \"\",\r\n      creator: new Types.ObjectId(),\r\n      description: \"\",\r\n      price: 0,\r\n      date: undefined,\r\n      address: undefined,\r\n      category: [],\r\n      chat: new Types.ObjectId(),\r\n      participants: [],\r\n    };\r\n    await expect(Event.create(eventData)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"negative price\", async () => {\r\n    const eventData: IEvent = {\r\n      name: \"Test Event\",\r\n      creator: new Types.ObjectId(),\r\n      description: \"A test event\",\r\n      price: -1,\r\n      date: new Date(),\r\n      address: a,\r\n      category: [c],\r\n      chat: new Types.ObjectId(),\r\n      participants: [],\r\n    };\r\n    await expect(Event.create(eventData)).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\utils\\createTestData.ts",{"fileContent":"import { categoryResource, eventResource, userResource } from \"../Resources\";\r\nimport { IAddress } from \"../model/UserModel\";\r\nimport EventService from \"../services/EventService\";\r\nimport { UserService } from \"../services/UserService\";\r\n\r\nconst createTestData = async () => {\r\n  const a: IAddress = {\r\n    postalCode: \"54321\",\r\n    city: \"Berlin\",\r\n  };\r\n\r\n  const u: userResource = {\r\n    email: \"John@some-host.de\",\r\n    name: {\r\n      first: \"John\",\r\n      last: \"Doe\",\r\n    },\r\n    password: \"12abcAB!\",\r\n    isAdministrator: false,\r\n    address: a,\r\n    birthDate: new Date(\"2000-06-14\"),\r\n    gender: \"male\",\r\n    isActive: true,\r\n  };\r\n\r\n  const u2: userResource = {\r\n    email: \"Jane@some-host.de\",\r\n    name: {\r\n      first: \"Jane\",\r\n      last: \"Doe\",\r\n    },\r\n    password: \"12abcAB!\",\r\n    isAdministrator: false,\r\n    address: a,\r\n    birthDate: new Date(\"2000-04-10\"),\r\n    gender: \"female\",\r\n    isActive: true,\r\n  };\r\n\r\n  const userService: UserService = new UserService();\r\n  const john = await userService.createUser(u);\r\n  const jane = await userService.createUser(u2);\r\n\r\n  const category1: categoryResource = {\r\n    name: \"Music\",\r\n    description: \"Music Event\",\r\n  };\r\n  const category2: categoryResource = {\r\n    name: \"Art\",\r\n    description: \"Art Event\",\r\n  };\r\n\r\n  const event1: eventResource = {\r\n    name: \"Summer Music Festival\",\r\n    description:\r\n      \"Ein großes Festival mit verschiedenen Musikgenres und lokalen Künstlern.\",\r\n    price: 50,\r\n    date: new Date(\"2024-06-21\"),\r\n    address: {\r\n      street: \"Musikstraße\",\r\n      houseNumber: \"1\",\r\n      city: \"Berlin\",\r\n      postalCode: \"10115\",\r\n      country: \"Deutschland\",\r\n    },\r\n    category: [category1],\r\n    hashtags: [\"party\", \"Party\", \"food\", \"Food\"],\r\n  };\r\n\r\n  const event2: eventResource = {\r\n    name: \"Street Food Market\",\r\n    description:\r\n      \"Eine kulinarische Reise durch die Street Food Kulturen der Welt.\",\r\n    price: 10,\r\n    date: new Date(\"2024-07-10\"),\r\n    address: {\r\n      street: \"Gourmetplatz\",\r\n      houseNumber: \"5\",\r\n      city: \"Hamburg\",\r\n      postalCode: \"20095\",\r\n      country: \"Deutschland\",\r\n    },\r\n    hashtags: [\"Food\", \"food\"],\r\n  };\r\n\r\n  const event3: eventResource = {\r\n    name: \"Coding Workshop\",\r\n    description: \"Ein interaktiver Workshop für Anfänger im Programmieren.\",\r\n    price: 0,\r\n    date: new Date(\"2024-08-15\"),\r\n    address: {\r\n      street: \"Techweg\",\r\n      houseNumber: \"3\",\r\n      city: \"München\",\r\n      postalCode: \"80331\",\r\n      country: \"Deutschland\",\r\n    },\r\n  };\r\n\r\n  const event4: eventResource = {\r\n    name: \"Yoga im Park\",\r\n    description: \"Entspannende Yoga-Sessions im Freien für alle Niveaus.\",\r\n    price: 15,\r\n    date: new Date(\"2024-05-25\"),\r\n    address: {\r\n      street: \"Grünallee\",\r\n      houseNumber: \"2\",\r\n      city: \"Köln\",\r\n      postalCode: \"50678\",\r\n      country: \"Deutschland\",\r\n    },\r\n  };\r\n\r\n  const event5: eventResource = {\r\n    name: \"Kunstausstellung Modern Art\",\r\n    description: \"Entdecken Sie moderne Kunstwerke lokaler Künstler.\",\r\n    price: 20,\r\n    date: new Date(\"2024-09-30\"),\r\n    address: {\r\n      street: \"Künstlerstraße\",\r\n      houseNumber: \"4\",\r\n      city: \"Frankfurt\",\r\n      postalCode: \"60311\",\r\n      country: \"Deutschland\",\r\n    },\r\n    category: [category2],\r\n  };\r\n\r\n  await EventService.createEvent(event1, john.id);\r\n  await EventService.createEvent(event2, john.id);\r\n  await EventService.createEvent(event3, john.id);\r\n  await EventService.createEvent(event4, jane.id);\r\n  await EventService.createEvent(event5, jane.id);\r\n};\r\n\r\nexport default createTestData;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\CommentService.ts",{"fileContent":"import { Types } from \"mongoose\";\r\nimport { CommentResource, CommentsResource } from \"../Resources\";\r\nimport { Comment, IBaseComment, IComment } from \"../model/CommentModel\";\r\nimport { IUser, User } from \"../model/UserModel\";\r\nimport { dateToString } from \"./ServiceHelper\";\r\nimport { Event, IEvent } from \"../model/EventModel\";\r\n\r\ninterface PopulatedComment extends IBaseComment {\r\n  id: string;\r\n  creator: IUser & { _id: Types.ObjectId };\r\n  event: IEvent & { _id: Types.ObjectId };\r\n}\r\n\r\nexport class CommentService {\r\n  /**\r\n   * finds all existing comments,\r\n   * fills in creator and event name by populating documents.\r\n   * skip and delete invalid comments before returning all comments?\r\n   * (comments where event/creator is invalid/missing are invalid).\r\n   * @returns all existing comments\r\n   */\r\n  async getComments(): Promise<CommentsResource> {\r\n    const comments = (await Comment.find({})\r\n      .populate(\"creator\", \"name\")\r\n      .populate(\"event\", \"name\")\r\n      .exec()) as unknown as PopulatedComment[];\r\n\r\n    const commentsToDelete: any = [];\r\n    const filteredComments = comments.filter((comment) => {\r\n      if (!comment.event || !comment.creator) {\r\n        commentsToDelete.push(this.deleteComment(comment.id));\r\n        return false;\r\n      } else return true;\r\n    });\r\n\r\n    await Promise.all(commentsToDelete);\r\n\r\n    const commentsResource: CommentsResource = {\r\n      comments: filteredComments.map((comment: PopulatedComment) => {\r\n        /*\r\n            if (!comment.creator) {\r\n                throw new Error(`Comment with ID ${comment.id} has no creator.`);\r\n            }\r\n            if (!comment.event) {\r\n                throw new Error(`Comment with ID ${comment.id} has no event.`);\r\n            }\r\n            */\r\n        return {\r\n          id: comment.id,\r\n          title: comment.title,\r\n          stars: comment.stars,\r\n          content: comment.content,\r\n          createdAt: dateToString(comment.createdAt!),\r\n          creator: comment.creator._id.toString(),\r\n          creatorName: comment.creator.name,\r\n          event: comment.event._id.toString(),\r\n          eventName: comment.event.name,\r\n          edited: comment.edited,\r\n        };\r\n      }),\r\n    };\r\n    return commentsResource;\r\n  }\r\n\r\n  /**\r\n   * populates the name of the event and sets the creatorName of every comment of the user.\r\n   * @param userId specifies the user\r\n   * @returns array of all comments from a user\r\n   */\r\n  async getCommentsOfUser(userId: string): Promise<CommentsResource> {\r\n    const user = await User.findById(userId);\r\n    if (!user) {\r\n      throw new Error(`Invalid userId ${userId}, can not find Comment!`);\r\n    }\r\n    const comments = (await Comment.find({ creator: user.id })\r\n      .populate(\"event\", \"name\")\r\n      .exec()) as unknown as PopulatedComment[];\r\n\r\n    const commentsToDelete: any = [];\r\n    const filteredComments = comments.filter((comment) => {\r\n      if (!comment.event) {\r\n        commentsToDelete.push(this.deleteComment(comment.id));\r\n        return false;\r\n      } else return true;\r\n    });\r\n\r\n    await Promise.all(commentsToDelete);\r\n\r\n    const commentsResource: CommentsResource = {\r\n      comments: filteredComments.map((comment: PopulatedComment) => {\r\n        return {\r\n          id: comment.id,\r\n          title: comment.title,\r\n          stars: comment.stars,\r\n          content: comment.content,\r\n          createdAt: dateToString(comment.createdAt!),\r\n          creator: user.id,\r\n          creatorName: user.name,\r\n          event: comment.event._id.toString(),\r\n          eventName: comment.event.name,\r\n          edited: comment.edited,\r\n        };\r\n      }),\r\n    };\r\n    return commentsResource;\r\n  }\r\n\r\n  async getCommentsOfEvent(eventId: string): Promise<CommentsResource> {\r\n    const event = await Event.findById(eventId);\r\n    if (!event) {\r\n      throw new Error(`Invalid eventId ${eventId}, can not find Comment!`);\r\n    }\r\n    const comments = (await Comment.find({ event: event.id })\r\n      .populate(\"creator\", \"name\")\r\n      .exec()) as unknown as PopulatedComment[];\r\n\r\n    const commentsToDelete: any = [];\r\n    const filteredComments = comments.filter((comment) => {\r\n      if (!comment.creator) {\r\n        commentsToDelete.push(this.deleteComment(comment.id));\r\n        return false;\r\n      } else return true;\r\n    });\r\n\r\n    await Promise.all(commentsToDelete);\r\n\r\n    const commentsResource: CommentsResource = {\r\n      comments: filteredComments.map((comment: PopulatedComment) => {\r\n        return {\r\n          id: comment.id,\r\n          title: comment.title,\r\n          stars: comment.stars,\r\n          content: comment.content,\r\n          createdAt: dateToString(comment.createdAt!),\r\n          creator: comment.creator._id.toString(),\r\n          creatorName: comment.creator.name,\r\n          event: event.id,\r\n          eventName: event.name,\r\n          edited: comment.edited,\r\n        } as CommentResource;\r\n      }),\r\n    };\r\n    return commentsResource;\r\n  }\r\n\r\n  /**\r\n   * used to create comments.\r\n   * Every user can only post one comment for each event.\r\n   * @param comment describes the comment\r\n   * @returns the created comment with additional information (creatorName, eventName and date of creation).\r\n   */\r\n  async createComment(comment: CommentResource): Promise<CommentResource> {\r\n    const existingComment = await Comment.findOne({\r\n      creator: comment.creator,\r\n      event: comment.event,\r\n    });\r\n    if (existingComment) {\r\n      throw new Error(\"User has already submitted a comment for this event.\");\r\n    }\r\n\r\n    const user = await User.findById(comment.creator);\r\n    const event = await Event.findById(comment.event);\r\n    if (!user) {\r\n      throw new Error(\r\n        `No creator with id: ${comment.creator} exists, can not create comment.`\r\n      );\r\n    }\r\n    if (!event) {\r\n      throw new Error(\r\n        `No event with id: ${comment.event} exists, can not create comment.`\r\n      );\r\n    }\r\n    const createdComment = await Comment.create({\r\n      title: comment.title,\r\n      stars: comment.stars,\r\n      content: comment.content,\r\n      creator: user.id,\r\n      creatorName: user.name,\r\n      event: event.id,\r\n      eventName: event.name,\r\n    });\r\n\r\n    const commentResource: CommentResource = {\r\n      id: createdComment.id,\r\n      title: createdComment.title,\r\n      stars: createdComment.stars,\r\n      content: createdComment.content,\r\n      creator: user.id,\r\n      creatorName: user.name,\r\n      event: event.id,\r\n      eventName: event.name,\r\n      createdAt: dateToString(createdComment.createdAt!),\r\n      edited: createdComment.edited,\r\n    };\r\n    return commentResource;\r\n  }\r\n\r\n  /**\r\n   * Updated ein Kommentar. Es können nur title, stars und content aktualisiert werden.\r\n   * Edited wird auf true gesetzt.\r\n   */\r\n  async updateComment(comment: CommentResource): Promise<CommentResource> {\r\n    if (!comment.id) {\r\n      throw new Error(`CommentId missing, can not update.`);\r\n    }\r\n    const foundComment = await Comment.findById(comment.id).exec();\r\n    if (!foundComment) {\r\n      throw new Error(\r\n        `No comment with id: ${comment.id} exists, can not update comment.`\r\n      );\r\n    }\r\n    const foundUser = await User.findById(foundComment.creator).exec();\r\n    const foundEvent = await Event.findById(foundComment.event).exec();\r\n\r\n    const user = await User.findById(comment.creator);\r\n    const event = await Event.findById(comment.event);\r\n    if (!user) {\r\n      throw new Error(\r\n        `No creator with id: ${comment.creator} exists, can not update comment.`\r\n      );\r\n    }\r\n    if (!event) {\r\n      throw new Error(\r\n        `No event with id: ${comment.event} exists, can not update comment.`\r\n      );\r\n    }\r\n\r\n    if (comment.title && comment.title != foundComment.title) {\r\n      foundComment.title = comment.title;\r\n      foundComment.edited = true;\r\n    }\r\n    if (comment.stars && comment.stars != foundComment.stars) {\r\n      foundComment.stars = comment.stars;\r\n      foundComment.edited = true;\r\n    }\r\n    if (comment.content && comment.content != foundComment.content) {\r\n      foundComment.content = comment.content;\r\n      foundComment.edited = true;\r\n    }\r\n\r\n    const commentResource = await foundComment.save();\r\n    return {\r\n      id: commentResource.id,\r\n      title: commentResource.title,\r\n      stars: commentResource.stars,\r\n      content: commentResource.content,\r\n      edited: commentResource.edited,\r\n      createdAt: dateToString(commentResource.createdAt!),\r\n      creator: foundUser.id,\r\n      creatorName: foundUser.name,\r\n      event: foundEvent.id,\r\n      eventName: foundEvent.name,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Deletes comment and all ratings of said comment.\r\n   * @param id comment to be deleted.\r\n   */\r\n  async deleteComment(id: string): Promise<void> {\r\n    if (!id) {\r\n      throw new Error(`CommentId missing, can not delete.`);\r\n    }\r\n    const comment = await Comment.findById(id).exec();\r\n    if (!comment) {\r\n      throw new Error(`Comment ${id} does not exist, can not delete.`);\r\n    }\r\n    await Comment.deleteOne({ _id: new Types.ObjectId(id) }).exec();\r\n    /*const res = await Comment.deleteOne({ _id: new Types.ObjectId(id) }).exec();\r\n    if (res.deletedCount !== 1) {\r\n        throw new Error(`No comment with id ${id} deleted, probably id not valid`);\r\n    }\r\n    */\r\n  }\r\n\r\n  /**\r\n   * used to delete all comments of a user who gets deleted.\r\n   * comments of non exisiting users are not needed and are getting deleted.\r\n   * @param userId identifies creator of comments\r\n   */\r\n  async deleteCommentsOfUser(userId: string): Promise<void> {\r\n    /*\r\n    if (!userId) {\r\n        throw new Error(`UserId missing, can not delete comments of user.`);\r\n    }\r\n    const user = await User.findById(userId).exec();\r\n    if (!user) {\r\n        throw new Error(`User with id: ${userId} does not exist, can not delete comments of user`);\r\n    }\r\n    \r\n    await Comment.deleteMany({ creator:user._id }).exec();\r\n    */\r\n    await Comment.deleteMany({ creator: userId }).exec();\r\n  }\r\n  /**\r\n   * used to delete all Comments of a event that gets removed from database.\r\n   * comments of non existing events are not needed and are getting deleted.\r\n   * @param eventId specifies the event of which comments to be deleted.\r\n   */\r\n  async deleteCommentsOfevent(eventId: string): Promise<void> {\r\n    /*\r\n    if (!eventId) {\r\n        throw new Error(`eventId missing, can not delete comments of event.`);\r\n    }\r\n    const event = await event.findById(eventId).exec();\r\n    if (!event) {\r\n        throw new Error(`event with id: ${eventId} does not exist, can not delete comments of event`);\r\n    }\r\n    \r\n    await Comment.deleteMany({ event:event._id }).exec();\r\n    */\r\n    await Comment.deleteMany({ event: eventId }).exec();\r\n  }\r\n  /**\r\n   * used to calculate the average rate for Event.\r\n   * If no comments found, return 0 as the average rating\r\n   * @param eventId identifies Event\r\n   * @returns the Average rate of Event as a Number\r\n   */\r\n  async getAverageRatingForEvent(eventId: Types.ObjectId): Promise<number> {\r\n    const comments = await Comment.find({ event: eventId }).exec();\r\n    if (!comments || comments.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const totalStars = comments.reduce(\r\n      (acc, comment) => acc + comment.stars,\r\n      0\r\n    );\r\n    const averageRating = totalStars / comments.length;\r\n    return averageRating;\r\n  }\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\model\\CommentModel.ts",{"fileContent":"import { Schema, Types, model } from \"mongoose\";\r\n\r\nexport interface IBaseComment {\r\n  title: string;\r\n  stars: number;\r\n  content: string;\r\n  edited: boolean;\r\n  createdAt?: Date;\r\n}\r\n\r\nexport interface IComment extends IBaseComment {\r\n  creator: Types.ObjectId;\r\n  event: Types.ObjectId;\r\n}\r\n\r\nconst comentSchema = new Schema<IComment>(\r\n  {\r\n    title: { type: String, required: true },\r\n    stars: {\r\n      type: Number,\r\n      required: true,\r\n      validate: {\r\n        validator: (value: number) => value >= 1 && value <= 5,\r\n        message: \"Stars must be between 0 and 5.\",\r\n      },\r\n    },\r\n    content: { type: String, required: true },\r\n    edited: { type: Boolean, default: false },\r\n    creator: { type: Schema.Types.ObjectId, ref: \"User\", required: true },\r\n    event: { type: Schema.Types.ObjectId, ref: \"Event\", required: true },\r\n  },\r\n  { timestamps: true },\r\n);\r\n\r\nexport const Comment = model<IComment>(\"Comment\", comentSchema);\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\ServiceHelper.ts",{"fileContent":"export function dateToString(date: Date) {\r\n  return `${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear()}`;\r\n}\r\n\r\nexport function dateToStringWithTime(date: Date): string {\r\n  const day = date.getDate();\r\n  const month = date.getMonth() + 1; // Monate beginnen bei 0\r\n  const year = date.getFullYear();\r\n  const hours = date.getHours();\r\n  const minutes = date.getMinutes();\r\n\r\n  // führende Null bei einstelligen Zahlen\r\n  const formattedDay = day < 10 ? `0${day}` : `${day}`;\r\n  const formattedMonth = month < 10 ? `0${month}` : `${month}`;\r\n  const formattedHours = hours < 10 ? `0${hours}` : `${hours}`;\r\n  const formattedMinutes = minutes < 10 ? `0${minutes}` : `${minutes}`;\r\n\r\n  return `${formattedDay}.${formattedMonth}.${year} ${formattedHours}:${formattedMinutes}`;\r\n}","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\Comments.ts",{"fileContent":"import express from \"express\";\r\nimport {\r\n  optionalAuthentication,\r\n  requiresAuthentication,\r\n} from \"./authentication\";\r\nimport { body, matchedData, param, validationResult } from \"express-validator\";\r\nimport {\r\n  CommentResource,\r\n  CommentWithRatingsResource,\r\n  CommentsWithRatingsResource,\r\n} from \"../Resources\";\r\nimport { CommentService } from \"../services/CommentService\";\r\nimport { RatingService } from \"../services/RatingService\";\r\nimport { Comment } from \"../model/CommentModel\";\r\n\r\nconst commentsRouter = express.Router();\r\n\r\nconst commentService: CommentService = new CommentService();\r\nconst ratingService: RatingService = new RatingService();\r\n\r\ncommentsRouter.get(\"/\", requiresAuthentication, async (req, res, next) => {\r\n  if (req.role === \"a\") {\r\n    try {\r\n      const comments = await commentService.getComments();\r\n      res.status(200).send(comments);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  } else {\r\n    res.status(403);\r\n    next(new Error(\"Unauthorized for this resource!\"));\r\n  }\r\n});\r\n/**\r\n * @swagger\r\n * /api/comments/event/{id}:\r\n *   get:\r\n *     summary: Get all comments of an event\r\n *     description: Retrieve all comments associated with a specific event.\r\n *     tags:\r\n *       - Comments\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         description: ID of the event to retrieve comments for\r\n *         schema:\r\n *           type: string\r\n *           format: mongo-id\r\n *     responses:\r\n *       '200':\r\n *         description: Successful response with comments\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: array\r\n *               items:\r\n *                 $ref: '#/components/schemas/IComment'\r\n *       '404':\r\n *         description: Event not found or no comments exist for the event\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Event not found or no comments exist for the event\r\n */\r\n\r\ncommentsRouter.get(\r\n  \"/event/:id\",\r\n  optionalAuthentication,\r\n  param(\"id\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const id = req.params?.id;\r\n    try {\r\n      const comments = await commentService.getCommentsOfEvent(id);\r\n      const commentsWithRatings: CommentsWithRatingsResource = {\r\n        comments: [],\r\n      };\r\n      for (const comment of comments.comments) {\r\n        const ratings = await ratingService.getRatingsOfComment(comment.id!);\r\n        if (comment.creatorName) {\r\n          let commentWithRatings: CommentWithRatingsResource = {\r\n            ...comment,\r\n            ratings: ratings,\r\n          };\r\n          commentsWithRatings.comments.push(commentWithRatings);\r\n        }\r\n      }\r\n      res.send(commentsWithRatings);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n\r\ncommentsRouter.get(\r\n  \"/user/:id\",\r\n  requiresAuthentication,\r\n  param(\"id\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const comments = await commentService.getComments();\r\n      if (comments.comments.length < 1) {\r\n        res.send(comments);\r\n      }\r\n      if (req.role === \"a\" /* || req.userId !== comments.comments[0].id */) {\r\n        //admin dashboard for comments of an user and user dashbaord of comments\r\n        res.status(200).send(comments);\r\n      } else {\r\n        res.status(403);\r\n        next(new Error(\"Unauthorized for this resource!\"));\r\n      }\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/comments/post:\r\n *   post:\r\n *     summary: Create a new comment\r\n *     description: Endpoint to create a new comment.\r\n *     tags:\r\n *       - Comments\r\n *     security:\r\n *       - bearerAuth: []\r\n *     requestBody:\r\n *       required: true\r\n *       content:\r\n *         application/json:\r\n *           schema:\r\n *             type: object\r\n *             properties:\r\n *               title:\r\n *                 type: string\r\n *                 example: \"Amazing\"\r\n *                 description: \"Title of the comment (max length: 100)\"\r\n *               stars:\r\n *                 type: integer\r\n *                 example: 4\r\n *                 description: \"Number of stars (1-5)\"\r\n *               content:\r\n *                 type: string\r\n *                 example: \"The best Event that i have joined in my entire life\"\r\n *                 description: \"Content of the comment (max length: 1000)\"\r\n *               creator:\r\n *                 type: string\r\n *                 format: mongo-id\r\n *                 description: \"ID of the comment creator (User ID)\"\r\n *               edited:\r\n *                 type: boolean\r\n *                 default: false\r\n *                 description: \"Indicates if the comment has been edited\"\r\n *               event:\r\n *                 type: string\r\n *                 format: mongo-id\r\n *                 description: \"ID of the associated event\"\r\n *             required:\r\n *               - title\r\n *               - stars\r\n *               - content\r\n *               - creator\r\n *               - event\r\n *     responses:\r\n *       '201':\r\n *         description: Created\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IComment'\r\n *       '400':\r\n *         description: Bad request, validation error or other errors\r\n *         content:\r\n *           application/json:\r\n *             examples:\r\n *               BadRequestExample1:\r\n *                 summary: User has already submitted a comment for this event\r\n *                 value:\r\n *                   error: User has already submitted a comment for this event\r\n *               BadRequestExample2:\r\n *                 summary: No creator/event with the given ID exists\r\n *                 value:\r\n *                   error: No creator/event with the given ID exists\r\n *       '403':\r\n *         description: Forbidden\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Only users are authorized to create comments!\r\n */\r\ncommentsRouter.post(\r\n  \"/post\",\r\n  requiresAuthentication,\r\n  body(\"title\").isString().isLength({ min: 1, max: 100 }),\r\n  body(\"stars\")\r\n    .isInt()\r\n    .custom((stars) => stars >= 1 && stars <= 5),\r\n  body(\"content\").isString().isLength({ min: 0, max: 1000 }),\r\n  body(\"creator\").isMongoId(),\r\n  body(\"edited\").optional().isBoolean(),\r\n  body(\"event\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    if (req.role === \"u\" && req.body.creator !== req.userId) {\r\n      res.status(403);\r\n      return next(new Error(\"Not authorized to post comment.\"));\r\n    }\r\n    try {\r\n      const commentData = matchedData(req) as CommentResource;\r\n      const createdComment = await commentService.createComment(commentData);\r\n      res.status(201).send(createdComment);\r\n    } catch (err) {\r\n      res.status(400);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/comments/{id}:\r\n *   put:\r\n *     summary: Update a comment\r\n *     description: Update an existing comment by ID.\r\n *     tags:\r\n *       - Comments\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         description: ID of the comment to update\r\n *         schema:\r\n *           type: string\r\n *           format: mongo-id\r\n *     requestBody:\r\n *       content:\r\n *         application/json:\r\n *           schema:\r\n *             type: object\r\n *             properties:\r\n *               title:\r\n *                 type: string\r\n *                 example: \"Amazing\"\r\n *                 description: \"Title of the comment (max length: 100)\"\r\n *               stars:\r\n *                 type: integer\r\n *                 example: 4\r\n *                 description: \"Number of stars (1-5)\"\r\n *               content:\r\n *                 type: string\r\n *                 example: \"The best Event that i have joined in my entire life\"\r\n *                 description: \"Content of the comment (max length: 1000)\"\r\n *               creator:\r\n *                 type: string\r\n *                 format: mongo-id\r\n *                 description: \"ID of the comment creator (User ID)\"\r\n *               edited:\r\n *                 type: boolean\r\n *                 default: false\r\n *                 description: \"Indicates if the comment has been edited\"\r\n *               event:\r\n *                 type: string\r\n *                 format: mongo-id\r\n *                 description: \"ID of the associated event\"\r\n *     responses:\r\n *       '200':\r\n *         description: Successful update\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               $ref: '#/components/schemas/IComment'\r\n *       '400':\r\n *         description: Bad request, validation error or other errors\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Bad request, validation error or other errors\r\n *       '403':\r\n *         description: Forbidden\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Only admins or the creator are authorized to update comments!\r\n *       '404':\r\n *         description: Comment not found or unauthorized to update\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Comment not found or unauthorized to update\r\n */\r\ncommentsRouter.put(\r\n  \"/:id\",\r\n  requiresAuthentication,\r\n  param(\"id\").isMongoId(),\r\n  body(\"title\").isString().isLength({ min: 1, max: 100 }),\r\n  body(\"stars\")\r\n    .isInt()\r\n    .custom((stars) => stars >= 1 && stars <= 5),\r\n  body(\"content\").isString().isLength({ min: 0, max: 1000 }),\r\n  body(\"creator\").isMongoId(),\r\n  body(\"edited\").optional().isBoolean(),\r\n  body(\"event\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    if (req.role === \"u\" && req.body.creator !== req.userId) {\r\n      res.status(403);\r\n      next(\r\n        new Error(\r\n          \"Only admins or the creator are authorized to update comments!\"\r\n        )\r\n      );\r\n    }\r\n    try {\r\n      const commentData = matchedData(req) as CommentResource;\r\n      if (commentData.id === req.params.id) commentData.id = req.params.id;\r\n      const createdComment = await commentService.updateComment(commentData);\r\n      res.status(200).send(createdComment);\r\n    } catch (err) {\r\n      res.status(400);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/comments/{id}:\r\n *   delete:\r\n *     summary: Delete a comment\r\n *     description: Delete an existing comment by ID.\r\n *     tags:\r\n *       - Comments\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         description: ID of the comment to delete\r\n *         schema:\r\n *           type: string\r\n *           format: mongo-id\r\n *     responses:\r\n *       '204':\r\n *         description: Comment deleted successfully\r\n *       '403':\r\n *         description: Forbidden\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Only Admins and the creator of the comment are authorized to delete comments!\r\n *       '404':\r\n *         description: Comment not found or unauthorized to delete\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Comment not found or unauthorized to delete\r\n */\r\ncommentsRouter.delete(\r\n  \"/:id\",\r\n  requiresAuthentication,\r\n  param(\"id\").isMongoId(),\r\n  async (req, res, next) => {\r\n    const id = req.params.id;\r\n    const comment = await Comment.findById(id).exec();\r\n    if (req.role === \"u\" && comment.creator.toString() !== req.userId) {\r\n      res.status(403);\r\n      next(\r\n        new Error(\r\n          \"Only Admins and the creator of the comment are authorized to delete comments!\"\r\n        )\r\n      );\r\n      return;\r\n    }\r\n    try {\r\n      await ratingService.deleteRatingsOfComment(id);\r\n      await commentService.deleteComment(id);\r\n      res.sendStatus(204);\r\n    } catch (err) {\r\n      res.status(404);\r\n      next(err);\r\n    }\r\n  }\r\n);\r\n/**\r\n * @swagger\r\n * /api/comments/event/{id}/average-rating:\r\n *   get:\r\n *     summary: Calculate the average rating of an event based on comments\r\n *     description: Retrieves the average rating of an event by its ID using the comments associated with it.\r\n *     tags:\r\n *       - Comments\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         description: ID of the event to calculate the average rating for\r\n *         schema:\r\n *           type: string\r\n *           format: mongo-id\r\n *     responses:\r\n *       '200':\r\n *         description: Successful response with average rating\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 averageRating:\r\n *                   type: number\r\n *                   description: The calculated average rating of the event based on comments\r\n *                   example: 3.5\r\n *       '400':\r\n *         description: Bad request, invalid ID format\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Bad request, invalid ID format\r\n *       '500':\r\n *         description: Internal server error\r\n *         content:\r\n *           application/json:\r\n *             example:\r\n *               error: Internal Server Error\r\n */\r\ncommentsRouter.get(\r\n  \"/event/:id/average-rating\",\r\n  param(\"id\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const eventId = req.params.id;\r\n      const averageRating =\r\n        await commentService.getAverageRatingForEvent(eventId);\r\n\r\n      res.status(200).json({ averageRating });\r\n    } catch (error) {\r\n      res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n  }\r\n);\r\nexport default commentsRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/RatingService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\RatingService.ts",{"fileContent":"import { RatingResource, RatingsResource } from \"../Resources\";\r\nimport { User } from \"../model/UserModel\";\r\nimport { Comment } from \"../model/CommentModel\";\r\nimport { Rating } from \"../model/RatingModel\";\r\nimport { Types } from \"mongoose\";\r\n\r\nexport class RatingService {\r\n  async getRatingsOfComment(commentId: string): Promise<RatingsResource> {\r\n    const comment = await Comment.findById(commentId).exec();\r\n    if (!comment) {\r\n      throw new Error(`No comment with id: ${commentId} of rating found.`);\r\n    }\r\n    const ratings = await Rating.find({ comment: commentId }).exec();\r\n    const result: RatingsResource = {\r\n      ratings: ratings.map((rating) => {\r\n        const r: RatingResource = {\r\n          id: rating.id,\r\n          comment: comment.id,\r\n          creator: rating.creator.toString(),\r\n          ratingType: rating.ratingType,\r\n        };\r\n        return r;\r\n      }),\r\n    };\r\n    return result;\r\n  }\r\n\r\n  async createRating(rating: RatingResource): Promise<RatingResource> {\r\n    const user = await User.findById(rating.creator).exec();\r\n    if (!user) {\r\n      throw new Error(\r\n        `No creator with id: ${rating.creator} of rating found. Can not create Rating.`\r\n      );\r\n    }\r\n    const comment = await Comment.findById(rating.comment).exec();\r\n    if (!comment) {\r\n      throw new Error(\r\n        `No comment with id: ${rating.comment} of rating found. Can not create Rating.`\r\n      );\r\n    }\r\n    if (user.id == comment.creator) {\r\n      throw new Error(\"Users cannot rate their own comments.\");\r\n    }\r\n    const dupe = await Rating.find({\r\n      comment: comment.id,\r\n      creator: user.id,\r\n    }).exec();\r\n    if (dupe.length > 0) throw new Error(\"Already rated this comment.\");\r\n\r\n    const createdRating = await Rating.create(rating);\r\n\r\n    const res: RatingResource = {\r\n      ...rating,\r\n      id: createdRating.id,\r\n    };\r\n    return res;\r\n  }\r\n\r\n  async updateRating(rating: RatingResource): Promise<RatingResource> {\r\n    if (!rating.id) {\r\n      throw new Error(`No ratingId:${rating.id} found, can not update rating`);\r\n    }\r\n    const recievedRating = await Rating.findById(rating.id).exec();\r\n    if (!recievedRating) {\r\n      throw new Error(\r\n        `No rating with id:${rating.id} found, can not update rating`\r\n      );\r\n    }\r\n\r\n    const user = await User.findById({\r\n      _id: new Types.ObjectId(rating.creator),\r\n    }).exec();\r\n    if (!user) {\r\n      throw new Error(\r\n        `No creator with id: ${rating.creator} of rating found. Can not update rating.`\r\n      );\r\n    }\r\n    const comment = await Comment.findById({\r\n      _id: new Types.ObjectId(rating.comment),\r\n    }).exec();\r\n    if (!comment) {\r\n      throw new Error(\r\n        `No comment with id: ${rating.comment} of rating found. Can not update rating.`\r\n      );\r\n    }\r\n\r\n    if (\r\n      recievedRating.creator != user.id ||\r\n      recievedRating.comment != comment.id\r\n    )\r\n      throw new Error(\"userID or commentID does not match.\");\r\n\r\n    if (rating.ratingType) recievedRating.ratingType = rating.ratingType;\r\n\r\n    const res = await recievedRating.save();\r\n    return {\r\n      id: res.id,\r\n      comment: res.comment.toString(),\r\n      creator: res.creator.toString(),\r\n      ratingType: res.ratingType,\r\n    };\r\n  }\r\n\r\n  async deleteRating(id: string): Promise<void> {\r\n    if (!id) {\r\n      throw new Error(`RatingId missing, can not delete.`);\r\n    }\r\n    const res = await Rating.deleteOne({ _id: new Types.ObjectId(id) }).exec();\r\n    if (res.deletedCount !== 1) {\r\n      throw new Error(`No rating with id ${id} deleted, probably id not valid`);\r\n    }\r\n  }\r\n\r\n  async deleteRatingsOfUser(userId: string): Promise<void> {\r\n    if (!userId) {\r\n      throw new Error(`UserId missing, can not delete.`);\r\n    }\r\n    const user = await User.findById(userId).exec();\r\n    if (!user) {\r\n      throw new Error(`User with id: ${userId} missing, can not delete.`);\r\n    }\r\n    await Rating.deleteMany({ creator: userId }).exec();\r\n  }\r\n\r\n  async deleteRatingsOfComment(commentId: string): Promise<void> {\r\n    if (!commentId) {\r\n      throw new Error(`CommentId missing, can not delete.`);\r\n    }\r\n    const comment = await Comment.findById(commentId).exec();\r\n    if (!comment) {\r\n      throw new Error(`Comment with id: ${commentId} missing, can not delete.`);\r\n    }\r\n    await Rating.deleteMany({ comment: new Types.ObjectId(commentId) }).exec();\r\n  }\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\model\\RatingModel.ts",{"fileContent":"import { Schema, Types, model } from \"mongoose\";\r\n\r\nexport interface IRating {\r\n  comment: Types.ObjectId; //Referenz zum Kommentar\r\n  creator: Types.ObjectId; //Benutzer, der bewertet hat\r\n  ratingType: RatingType; //Bewertungstyp: hilfreich, nicht hilfreich, gemeldet\r\n}\r\n\r\nexport enum RatingType {\r\n  Helpful = \"helpful\",\r\n  Reported = \"reported\",\r\n}\r\n\r\nconst ratingSchema = new Schema<IRating>({\r\n  comment: { type: Schema.Types.ObjectId, ref: \"Comment\", required: true },\r\n  creator: { type: Schema.Types.ObjectId, ref: \"User\", required: true },\r\n  ratingType: { type: String, enum: Object.values(RatingType), required: true },\r\n});\r\n\r\nexport const Rating = model<IRating>(\"Rating\", ratingSchema);\r\n","resolvedModuleNames":[]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\services\\CommentService.test.ts",{"fileContent":"import { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  CommentResource,\r\n  addressEResource,\r\n  categoryResource,\r\n  eventResource,\r\n  userResource,\r\n} from \"../../src/Resources\";\r\nimport { User } from \"../../src/model/UserModel\";\r\nimport { Comment } from \"../../src/model/CommentModel\";\r\nimport { CommentService } from \"../../src/services/CommentService\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\nimport { dateToString } from \"../../src/services/ServiceHelper\";\r\n\r\nconst a: addressEResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst eventService: EventService = new EventService();\r\nconst commentService: CommentService = new CommentService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\n\r\ndescribe(\"CommentService Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"create comment\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const c: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: -1,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    // stars < 1 or stars > 5 should not work\r\n    await expect(commentService.createComment(c)).rejects.toThrow();\r\n    c.stars = 6;\r\n    await expect(commentService.createComment(c)).rejects.toThrow();\r\n\r\n    c.stars = 1;\r\n    const comment = await commentService.createComment(c);\r\n    expect(comment.id).toBeDefined();\r\n    expect(comment.title).toBe(c.title);\r\n    expect(comment.stars).toBe(c.stars);\r\n    expect(comment.content).toBe(c.content);\r\n    expect(comment.creator).toBe(user.id);\r\n    expect(comment.creatorName.first).toBe(user.name.first);\r\n    expect(comment.creatorName.last).toBe(user.name.last);\r\n    expect(comment.event).toBe(event.id);\r\n    expect(comment.eventName).toBe(event.name);\r\n    expect(typeof comment.createdAt).toBe(\"string\");\r\n    expect(comment.edited).toBeFalsy();\r\n    // same user commenting on same event should not work\r\n    await expect(commentService.createComment(c)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"get comments of user\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const event1 = await eventService.createEvent(e1, user.id);\r\n    const event2 = await eventService.createEvent(e2, user.id);\r\n    const c: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 1,\r\n      content: \"this is my first comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const c1: CommentResource = {\r\n      title: \"Sample Comment 1\",\r\n      stars: 1,\r\n      content: \"this is my second comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event1.id,\r\n    };\r\n    const c2: CommentResource = {\r\n      title: \"Sample Comment 2\",\r\n      stars: 2,\r\n      content: \"this is my third comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event2.id,\r\n    };\r\n    await commentService.createComment(c);\r\n    await commentService.createComment(c1);\r\n    await commentService.createComment(c2);\r\n    const result = await commentService.getCommentsOfUser(user.id);\r\n    expect(result.comments).toHaveLength(3);\r\n    expect(result.comments[0].title).toBe(\"Sample Comment\");\r\n    expect(result.comments[1].creator).toBe(user.id);\r\n    expect(result.comments[2].event).toBe(event2.id);\r\n    // invalid id\r\n    await expect(\r\n      commentService.getCommentsOfUser(NON_EXISTING_ID)\r\n    ).rejects.toThrow();\r\n    // user with no comments\r\n    const user1 = await User.create(u1);\r\n    const empty = await commentService.getCommentsOfUser(user1.id);\r\n    expect(empty.comments).toHaveLength(0);\r\n  });\r\n\r\n  test(\"get comments of event\", async () => {\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const c: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 1,\r\n      content: \"this is my first comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const c1: CommentResource = {\r\n      title: \"Sample Comment 1\",\r\n      stars: 1,\r\n      content: \"this is my second comment\",\r\n      edited: false,\r\n      creator: user1.id,\r\n      event: event.id,\r\n    };\r\n    const c2: CommentResource = {\r\n      title: \"Sample Comment 2\",\r\n      stars: 2,\r\n      content: \"this is my third comment\",\r\n      edited: false,\r\n      creator: user2.id,\r\n      event: event.id,\r\n    };\r\n    await commentService.createComment(c);\r\n    await commentService.createComment(c1);\r\n    await commentService.createComment(c2);\r\n    const result = await commentService.getCommentsOfEvent(event.id);\r\n    expect(result.comments).toHaveLength(3);\r\n    expect(result.comments[2].title).toBe(\"Sample Comment 2\");\r\n    expect(result.comments[1].event).toBe(event.id);\r\n    expect(result.comments[0].creator).toBe(user.id);\r\n    // invalid id\r\n    await expect(\r\n      commentService.getCommentsOfEvent(NON_EXISTING_ID)\r\n    ).rejects.toThrow();\r\n    // user with no comments\r\n    const event1 = await eventService.createEvent(e1, user.id);\r\n    const empty = await commentService.getCommentsOfEvent(event1.id);\r\n    expect(empty.comments).toHaveLength(0);\r\n  });\r\n\r\n  test(\"get all comments\", async () => {\r\n    // no comments\r\n    const empty = await commentService.getComments();\r\n    expect(empty.comments).toHaveLength(0);\r\n\r\n    const user = await User.create(u);\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const c: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 1,\r\n      content: \"this is my first comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const c1: CommentResource = {\r\n      title: \"Sample Comment 1\",\r\n      stars: 1,\r\n      content: \"this is my second comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event1.id,\r\n    };\r\n    const c2: CommentResource = {\r\n      title: \"Sample Comment 2\",\r\n      stars: 2,\r\n      content: \"this is my third comment\",\r\n      edited: false,\r\n      creator: user1.id,\r\n      event: event.id,\r\n    };\r\n    const c3: CommentResource = {\r\n      title: \"Sample Comment 3\",\r\n      stars: 3,\r\n      content: \"this is my fourth comment\",\r\n      edited: false,\r\n      creator: user1.id,\r\n      event: event1.id,\r\n    };\r\n    const c4: CommentResource = {\r\n      title: \"Sample Comment 4\",\r\n      stars: 4,\r\n      content: \"this is my fifth comment\",\r\n      edited: false,\r\n      creator: user2.id,\r\n      event: event.id,\r\n    };\r\n    const c5: CommentResource = {\r\n      title: \"Sample Comment 5\",\r\n      stars: 5,\r\n      content: \"this is my sixth comment\",\r\n      edited: false,\r\n      creator: user2.id,\r\n      event: event1.id,\r\n    };\r\n    await commentService.createComment(c);\r\n    await commentService.createComment(c1);\r\n    await commentService.createComment(c2);\r\n    await commentService.createComment(c3);\r\n    await commentService.createComment(c4);\r\n    await commentService.createComment(c5);\r\n    const result = await commentService.getComments();\r\n    expect(result.comments).toHaveLength(6);\r\n    expect(result.comments[0].title).toBe(\"Sample Comment\");\r\n    expect(result.comments[1].stars).toBe(1);\r\n    expect(result.comments[2].content).toBe(\"this is my third comment\");\r\n    expect(result.comments[3].creator).toBe(user1.id);\r\n    expect(result.comments[4].event).toBe(event.id);\r\n    expect(typeof result.comments[5].createdAt).toBe(\"string\");\r\n  });\r\n\r\n  test(\"edit comment\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const c: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 1,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const comment = await commentService.createComment(c);\r\n    expect(comment.id).toBeDefined();\r\n    expect(comment.title).toBe(c.title);\r\n    expect(comment.stars).toBe(1);\r\n    expect(comment.edited).toBeFalsy();\r\n\r\n    const c1: CommentResource = {\r\n      id: comment.id,\r\n      title: \"Updated Comment\",\r\n      stars: 5,\r\n      content: \"my edited comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const comment1 = await commentService.updateComment(c1);\r\n    expect(comment1.id).toBe(comment.id);\r\n    expect(comment1.title).toBe(c1.title);\r\n    expect(comment1.stars).toBe(5);\r\n    expect(comment1.edited).toBeTruthy();\r\n\r\n    // updating createdAt, creator, event should not work\r\n    const user1 = await User.create(u1);\r\n    const event1 = await eventService.createEvent(e1, user1.id);\r\n    const c2: CommentResource = {\r\n      id: comment.id,\r\n      title: \"New Comment\",\r\n      stars: 4,\r\n      content: \"my new comment\",\r\n      edited: true,\r\n      creator: user1.id,\r\n      event: event1.id,\r\n      createdAt: \"01.01.2001\"\r\n    };\r\n    const comment2 = await commentService.updateComment(c2);\r\n    expect(comment2.createdAt).not.toBe(c2.createdAt);\r\n    expect(comment2.createdAt).toBe(comment.createdAt);\r\n    expect(comment2.creator).not.toBe(c2.creator);\r\n    expect(comment2.creator).toBe(c.creator);\r\n    expect(comment2.event).not.toBe(c2.event);\r\n    expect(comment2.event).toBe(c.event);\r\n  });\r\n\r\n  test(\"delete one comment\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const c: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 1,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const comment = await commentService.createComment(c);\r\n    expect(await Comment.findById(comment.id)).not.toBeNull();\r\n\r\n    await commentService.deleteComment(comment.id);\r\n    expect(await Comment.findById(comment.id)).toBeNull();\r\n\r\n    // invalid id\r\n    await expect(\r\n      commentService.deleteComment(NON_EXISTING_ID)\r\n    ).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\routes\\CommentRoute.test.ts",{"fileContent":"import request from \"supertest\";\r\n//import { req } from \"../jest.setup\";\r\nimport { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  CommentResource,\r\n  CommentsResource,\r\n  LoginResource,\r\n  addressEResource,\r\n  categoryResource,\r\n  eventResource,\r\n  userResource,\r\n} from \"../../src/Resources\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\nimport app from \"../../server\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\nimport mongoose from \"mongoose\";\r\nimport { CommentService } from \"../../src/services/CommentService\";\r\n\r\nconst a: addressEResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst JaneData: userResource = {\r\n  email: \"Jane@doe.com\",\r\n  name: {\r\n    first: \"Jane\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst eventService: EventService = new EventService();\r\nconst commentService: CommentService = new CommentService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\nlet admin: userResource;\r\nlet AdminToken: string;\r\nlet jane: userResource;\r\nlet token: string;\r\nlet user: userResource;\r\nlet uToken: string;\r\nlet event: eventResource;\r\nlet event1: eventResource;\r\nlet event2: eventResource;\r\nlet comment: CommentResource;\r\nlet req = request(app);\r\n\r\ndescribe(\"CommentsRoute Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  beforeEach(async () => {\r\n    admin = await userService.createUser(u);\r\n    jane = await userService.createUser(JaneData);\r\n    user = await userService.createUser(u2);\r\n    const adminloginData = { email: \"John@doe.com\", password: \"12abcAB!\" };\r\n    const adminRes = await req.post(`/api/login`).send(adminloginData);\r\n    const AdminLoginResource = adminRes.body as LoginResource;\r\n    AdminToken = AdminLoginResource.access_token;\r\n\r\n    const janeLoginData = { email: \"Jane@doe.com\", password: \"12abcAB!\" };\r\n    const janeRes = await req.post(`/api/login`).send(janeLoginData);\r\n    const janeLoginResource = janeRes.body as LoginResource;\r\n    token = janeLoginResource.access_token;\r\n\r\n    const uLoginData = { email: \"test@mail.com\", password: \"12abcAB!\" };\r\n    const uRes = await req.post(`/api/login`).send(uLoginData);\r\n    const uLoginResource = uRes.body as LoginResource;\r\n    uToken = uLoginResource.access_token;\r\n\r\n    event = await eventService.createEvent(e, admin.id);\r\n    event1 = await eventService.createEvent(e1, jane.id);\r\n    event2 = await eventService.createEvent(e2, user.id);\r\n\r\n    comment = {\r\n      title: \"Sample Comment\",\r\n      stars: 1,\r\n      content: \"this is my comment\",\r\n      edited: true,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n  });\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => {\r\n    //closeServer(); // Close the server after all tests\r\n    await mongoose.connection.close(); // Perform final cleanup after all tests\r\n  });\r\n\r\n  test(\"post comment route\", async () => {\r\n    let res = await req\r\n      .post(\"/api/comments/post\")\r\n      .send(comment)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(201);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    const result: CommentResource = res.body;\r\n    expect(result.id).toBeDefined();\r\n    expect(result.title).toBe(comment.title);\r\n    expect(result.stars).toBe(comment.stars);\r\n    expect(result.content).toBe(comment.content);\r\n    expect(result.edited).toBeFalsy();\r\n    expect(result.creator).toBe(user.id);\r\n    expect(result.event).toBe(event.id);\r\n    // should not work if comment creator and comment poster are not matching\r\n    comment.creator = admin.id;\r\n    res = await req\r\n      .post(\"/api/comments/post\")\r\n      .send(comment)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(403);\r\n  });\r\n\r\n  test(\"get all comments route\", async () => {\r\n    await commentService.createComment(comment);\r\n    let res = await req\r\n      .get(\"/api/comments\")\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(403);\r\n    res = await req\r\n      .get(\"/api/comments\")\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    const result: CommentsResource = res.body;\r\n    expect(result.comments).toHaveLength(1);\r\n  });\r\n\r\n  test(\"get comments of user route\", async () => {\r\n    await commentService.createComment(comment);\r\n    let res = await req\r\n      .get(`/api/comments/user/${user.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(403);\r\n    res = await req\r\n      .get(`/api/comments/user/${user.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n    const result: CommentsResource = res.body;\r\n    expect(result.comments).toHaveLength(1);\r\n  });\r\n\r\n  test(\"get comments of event route\", async () => {\r\n    await commentService.createComment(comment);\r\n    let res = await req.get(`/api/comments/event/${event.id}`);\r\n    expect(res.status).toBe(200);\r\n    res = await req\r\n      .get(`/api/comments/event/${event.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(200);\r\n    const result: CommentsResource = res.body;\r\n    expect(result.comments).toHaveLength(1);\r\n  });\r\n\r\n  test(\"edit comment route\", async () => {\r\n    const oldComment = await commentService.createComment(comment);\r\n    const c: CommentResource = {\r\n      id: oldComment.id,\r\n      title: \"Updated Comment\",\r\n      stars: 5,\r\n      content: \"my edited comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    let res = await req\r\n      .put(`/api/comments/${oldComment.id}`)\r\n      .send(c)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(403);\r\n    res = await req\r\n      .put(`/api/comments/${oldComment.id}`)\r\n      .send(c)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    res = await req\r\n      .put(`/api/comments/${oldComment.id}`)\r\n      .send(c)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(200);\r\n  });\r\n\r\n  test(\"delete comment route\", async () => {\r\n    const c = await commentService.createComment(comment);\r\n    let res = await req\r\n      .delete(`/api/comments/${c.id}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n    expect(res.status).toBe(403);\r\n    res = await req\r\n      .delete(`/api/comments/${c.id}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(204);\r\n    res = await req\r\n      .delete(`/api/comments/${c.id}`)\r\n      .set(\"Authorization\", `Bearer ${AdminToken}`);\r\n    expect(res.status).toBe(404);\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/server.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/createTestData.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/Comments.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\services\\RatingService.test.ts",{"fileContent":"import { connect, closeDatabase, clearDatabase } from \"../../database/db\";\r\nimport {\r\n  CommentResource,\r\n  RatingResource,\r\n  addressEResource,\r\n  categoryResource,\r\n  eventResource,\r\n  userResource,\r\n} from \"../../src/Resources\";\r\nimport { User } from \"../../src/model/UserModel\";\r\nimport { Comment } from \"../../src/model/CommentModel\";\r\nimport { CommentService } from \"../../src/services/CommentService\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\nimport { dateToString } from \"../../src/services/ServiceHelper\";\r\nimport { Rating, RatingType } from \"../../src/model/RatingModel\";\r\nimport { RatingService } from \"../../src/services/RatingService\";\r\n\r\nconst a: addressEResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u1: userResource = {\r\n  email: \"Don@joe.com\",\r\n  name: {\r\n    first: \"Don\",\r\n    last: \"Joe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst u3: userResource = {\r\n  email: \"inactive@mail.com\",\r\n  name: {\r\n    first: \"in\",\r\n    last: \"active\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: false,\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst eventService: EventService = new EventService();\r\nconst commentService: CommentService = new CommentService();\r\nconst ratingService: RatingService = new RatingService();\r\nconst NON_EXISTING_ID = \"635d2e796ea2e8c9bde5787c\";\r\n\r\ndescribe(\"RatingService Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => await closeDatabase());\r\n\r\n  test(\"rate a comment\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const cr: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 5,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const user1 = await User.create(u1);\r\n    const comment = await commentService.createComment(cr);\r\n    const r: RatingResource = {\r\n      comment: comment.id,\r\n      creator: user1.id,\r\n      ratingType: RatingType.Helpful,\r\n    };\r\n    const rating = await ratingService.createRating(r);\r\n    expect(rating.id).toBeDefined();\r\n    expect(rating.comment).toBe(comment.id);\r\n    expect(rating.creator).toBe(user1.id);\r\n    expect(rating.ratingType).toBe(\"helpful\");\r\n    // same user rating same comment should not work\r\n    await expect(ratingService.createRating(r)).rejects.toThrow();\r\n    // user rating own comment should not work\r\n    r.creator = user.id;\r\n    await expect(ratingService.createRating(r)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"get ratings of comment\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const cr: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 5,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const user1 = await User.create(u1);\r\n    const user2 = await User.create(u2);\r\n    const comment = await commentService.createComment(cr);\r\n    const r: RatingResource = {\r\n      comment: comment.id,\r\n      creator: user1.id,\r\n      ratingType: RatingType.Helpful,\r\n    };\r\n    await ratingService.createRating(r);\r\n    r.creator = user2.id;\r\n    r.ratingType = RatingType.Reported;\r\n    await ratingService.createRating(r);\r\n    const result = await ratingService.getRatingsOfComment(comment.id);\r\n    expect(result.ratings).toHaveLength(2);\r\n    expect(result.ratings[0].ratingType).toBe(\"helpful\");\r\n    expect(result.ratings[1].ratingType).toBe(\"reported\");\r\n  });\r\n\r\n  test(\"update rating\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const cr: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 5,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const user1 = await User.create(u1);\r\n    const comment = await commentService.createComment(cr);\r\n    const cr1: CommentResource = {\r\n      title: \"Sample Comment 1\",\r\n      stars: 1,\r\n      content: \"this is my other comment\",\r\n      edited: false,\r\n      creator: user1.id,\r\n      event: event.id,\r\n    };\r\n    const user2 = await User.create(u2);\r\n    const comment1 = await commentService.createComment(cr1);\r\n    const r: RatingResource = {\r\n      comment: comment.id,\r\n      creator: user1.id,\r\n      ratingType: RatingType.Helpful,\r\n    };\r\n    const rating = await ratingService.createRating(r);\r\n    r.id = rating.id;\r\n    r.ratingType = RatingType.Reported;\r\n    const rating1 = await ratingService.updateRating(r);\r\n    expect(rating1.id).toBe(rating.id);\r\n    expect(rating1.comment).toBe(rating.comment);\r\n    expect(rating1.creator).toBe(rating.creator);\r\n    expect(rating1.ratingType).toBe(\"reported\");\r\n    // updating creatorId or commentId should not work\r\n    r.creator = user2.id;\r\n    await expect(ratingService.updateRating(r)).rejects.toThrow();\r\n    r.comment = comment1.id;\r\n    await expect(ratingService.updateRating(r)).rejects.toThrow();\r\n  });\r\n\r\n  test(\"delete rating\", async () => {\r\n    const user = await User.create(u);\r\n    const event = await eventService.createEvent(e, user.id);\r\n    const cr: CommentResource = {\r\n      title: \"Sample Comment\",\r\n      stars: 5,\r\n      content: \"this is my comment\",\r\n      edited: false,\r\n      creator: user.id,\r\n      event: event.id,\r\n    };\r\n    const user1 = await User.create(u1);\r\n    const comment = await commentService.createComment(cr);\r\n    const r: RatingResource = {\r\n      comment: comment.id,\r\n      creator: user1.id,\r\n      ratingType: RatingType.Helpful,\r\n    };\r\n    const rating = await ratingService.createRating(r);\r\n    expect(await Rating.findById(rating.id)).not.toBeNull();\r\n    await ratingService.deleteRating(rating.id);\r\n    expect(await Rating.findById(rating.id)).toBeNull();\r\n    await expect(ratingService.deleteRating(rating.id)).rejects.toThrow();\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/CommentModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/RatingService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\tests\\routes\\ChatRoute.test.ts",{"fileContent":"import request from \"supertest\";\r\n//import { req } from \"../jest.setup\";\r\nimport { connect, clearDatabase } from \"../../database/db\";\r\nimport {\r\n    ChatResource,\r\n  LoginResource,\r\n  addressEResource,\r\n  categoryResource,\r\n  eventResource,\r\n  userResource,\r\n} from \"../../src/Resources\";\r\nimport { EventService } from \"../../src/services/EventService\";\r\nimport app from \"../../server\";\r\nimport { UserService } from \"../../src/services/UserService\";\r\nimport mongoose from \"mongoose\";\r\nimport { ChatService } from \"../../src/services/ChatService\";\r\n\r\nconst a: addressEResource = {\r\n  street: \"Street\",\r\n  houseNumber: \"1\",\r\n  postalCode: \"12345\",\r\n  city: \"Berlin\",\r\n  country: \"Germany\",\r\n};\r\n\r\nconst c: categoryResource = {\r\n  name: \"Hobbys\",\r\n  description: \"persönliche Interessen, Freizeit\",\r\n};\r\n\r\nconst c1: categoryResource = {\r\n  name: \"Sport\",\r\n  description: \"sportliche Aktivitäten, Spiele, Fitness\",\r\n};\r\n\r\nconst u: userResource = {\r\n  email: \"John@doe.com\",\r\n  name: {\r\n    first: \"John\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: true,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst u2: userResource = {\r\n  email: \"test@mail.com\",\r\n  name: {\r\n    first: \"test\",\r\n    last: \"name\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"female\",\r\n  isActive: true,\r\n};\r\n\r\nconst JaneData: userResource = {\r\n  email: \"Jane@doe.com\",\r\n  name: {\r\n    first: \"Jane\",\r\n    last: \"Doe\",\r\n  },\r\n  password: \"12abcAB!\",\r\n  isAdministrator: false,\r\n  address: a,\r\n  birthDate: new Date(),\r\n  gender: \"male\",\r\n  isActive: true,\r\n  profilePicture: \"picture1\",\r\n  socialMediaUrls: {\r\n    facebook: \"facebook\",\r\n    instagram: \"instagram\",\r\n  },\r\n};\r\n\r\nconst e: eventResource = {\r\n  name: \"Sample Event\",\r\n  description: \"This is my first event\",\r\n  price: 10,\r\n  date: new Date(),\r\n  address: a,\r\n  thumbnail: \"sampleThumbnail\",\r\n  hashtags: [\"sport\", \"freizeit\"],\r\n  category: [c, c1],\r\n};\r\n\r\nconst e1: eventResource = {\r\n  name: \"Sample Event 1\",\r\n  description: \"for anyone interested\",\r\n  price: 0,\r\n  date: new Date(),\r\n  address: a,\r\n  category: [c],\r\n};\r\n\r\nconst e2: eventResource = {\r\n  name: \"Sample Event 2\",\r\n  description: \"this is my second gym party\",\r\n  price: 100,\r\n  date: new Date(),\r\n  address: a,\r\n  hashtags: [\"freizeit\"],\r\n  category: [c1],\r\n};\r\n\r\nconst userService: UserService = new UserService();\r\nconst eventService: EventService = new EventService();\r\nconst chatService: ChatService = new ChatService();\r\nlet admin: userResource;\r\nlet AdminToken: string;\r\nlet jane: userResource;\r\nlet token: string;\r\nlet user: userResource;\r\nlet uToken: string;\r\nlet event1: eventResource;\r\nlet event2: eventResource;\r\nlet req = request(app);\r\n\r\ndescribe(\"ChatRoute Tests\", () => {\r\n  beforeAll(async () => await connect());\r\n  beforeEach(async () => {\r\n    admin = await userService.createUser(u);\r\n    jane = await userService.createUser(JaneData);\r\n    user = await userService.createUser(u2);\r\n    const adminloginData = { email: \"John@doe.com\", password: \"12abcAB!\" };\r\n    const adminRes = await req.post(`/api/login`).send(adminloginData);\r\n    const AdminLoginResource = adminRes.body as LoginResource;\r\n    AdminToken = AdminLoginResource.access_token;\r\n\r\n    const janeLoginData = { email: \"Jane@doe.com\", password: \"12abcAB!\" };\r\n    const janeRes = await req.post(`/api/login`).send(janeLoginData);\r\n    const janeLoginResource = janeRes.body as LoginResource;\r\n    token = janeLoginResource.access_token;\r\n\r\n    const uLoginData = { email: \"test@mail.com\", password: \"12abcAB!\" };\r\n    const uRes = await req.post(`/api/login`).send(uLoginData);\r\n    const uLoginResource = uRes.body as LoginResource;\r\n    uToken = uLoginResource.access_token;\r\n\r\n    event1 = await eventService.createEvent(e1, jane.id);\r\n    event2 = await eventService.createEvent(e2, user.id);\r\n\r\n  });\r\n  afterEach(async () => await clearDatabase());\r\n  afterAll(async () => {\r\n    //closeServer(); // Close the server after all tests\r\n    await mongoose.connection.close(); // Perform final cleanup after all tests\r\n  });\r\n\r\n  test(\"send chat message\", async () => {\r\n    let res = await req\r\n      .post(`/api/chat/${event2.chat}`)\r\n      .send({ message: \"hallo\" })\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    const result: ChatResource = res.body;\r\n    expect(result.id).toBe(event2.chat);\r\n    expect(result.messages).toHaveLength(1);\r\n    expect(result.messages[0].user).toBe(user.id);\r\n    expect(result.messages[0].message).toBe(\"hallo\");\r\n    // invalid authorization\r\n    res = await req\r\n      .post(`/api/chat/${event2.chat}`)\r\n      .send({ message: \"hallo\" })\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n      expect(res.status).toBe(403);\r\n  });\r\n\r\n  test(\"get chat\", async () => {\r\n    await eventService.joinEvent(admin.id, event2.id);\r\n    await chatService.sendMessage(event2.chat, user.id, \"hallo\");\r\n    await chatService.sendMessage(event2.chat, admin.id, \"hey\");\r\n    let res = await req\r\n      .get(`/api/chat/${event2.chat}`)\r\n      .set(\"Authorization\", `Bearer ${uToken}`);\r\n    expect(res.status).toBe(200);\r\n    expect(res.body.errors).not.toBeDefined();\r\n    const result: ChatResource = res.body;\r\n    expect(result.id).toBe(event2.chat);\r\n    expect(result.messages).toHaveLength(2);\r\n    expect(result.messages[0].user).toBe(user.id);\r\n    expect(result.messages[0].message).toBe(\"hallo\");\r\n    expect(result.messages[1].user).toBe(admin.id);\r\n    expect(result.messages[1].message).toBe(\"hey\");\r\n    // invalid authorization\r\n    res = await req\r\n      .get(`/api/chat/${event2.chat}`)\r\n      .set(\"Authorization\", `Bearer ${token}`);\r\n      expect(res.status).toBe(403);\r\n  });\r\n});\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/database/db.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/EventService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/server.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/UserService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ChatService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/CommentService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/CreateAdminUser.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/swagger.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UserRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/UsersRouter.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/login.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/EventRoute.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/utils/createTestData.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/Comments.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\routes\\ChatRoute.ts",{"fileContent":"import express from \"express\";\r\nimport { ChatService } from \"../services/ChatService\";\r\nimport { requiresAuthentication } from \"./authentication\";\r\nimport { body, param } from \"express-validator\";\r\nimport { Event } from \"../model/EventModel\";\r\nimport { Types } from \"mongoose\";\r\n\r\nconst ChatRouter = express.Router();\r\nconst chatService = new ChatService();\r\n\r\nChatRouter.get(\r\n  \"/:id\",\r\n  requiresAuthentication,\r\n  param(\"id\").isMongoId(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const chat = await chatService.getChat(req.params.id);\r\n      const event = await Event.findById(chat.event).exec();\r\n      if (!event.participants.includes(new Types.ObjectId(req.userId))) {\r\n        return res.status(403).json(\"User is not participating in the event\");\r\n      }\r\n      res.status(200).send(chat);\r\n    } catch (error) {\r\n      res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n  }\r\n);\r\n\r\nChatRouter.post(\r\n  \"/:id\",\r\n  requiresAuthentication,\r\n  param(\"id\").isMongoId(),\r\n  body(\"message\").isString().notEmpty(),\r\n  async (req, res, next) => {\r\n    try {\r\n      const chat = await chatService.sendMessage(\r\n        req.params.id,\r\n        req.userId,\r\n        req.body.message\r\n      );\r\n      res.status(200).send(chat);\r\n    } catch (error) {\r\n      if (error.message === \"User is not participating in the event\") {\r\n        return res.status(403).json({ Error: error.message });\r\n      }\r\n      res.status(500).json({ error: \"Internal Server Error\" });\r\n    }\r\n  }\r\n);\r\n\r\nexport default ChatRouter;\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ChatService.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/routes/authentication.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/JWTService.ts"]}],["C:\\Users\\naceu\\OneDrive\\Desktop\\Studium\\5 Semester\\Projekt\\connectandexplore\\Backend\\src\\services\\ChatService.ts",{"fileContent":"import { ChatResource } from \"../Resources\";\r\nimport { Event, Chat } from \"../model/EventModel\";\r\nimport { User } from \"../model/UserModel\";\r\nimport { dateToString, dateToStringWithTime } from \"./ServiceHelper\";\r\n\r\nexport class ChatService {\r\n  async getChat(chatID: string): Promise<ChatResource> {\r\n    if (!chatID) throw new Error(`Chat ID: ${chatID} is invalid.`);\r\n    const chat = await Chat.findById(chatID).exec();\r\n    if (!chat) throw new Error(\"Chat not found\");\r\n    return {\r\n      id: chat.id,\r\n      event: chat.event.toString(),\r\n      messages: await Promise.all(\r\n        chat.messages.map(async (message) => {\r\n          const user = await User.findById(message.user);\r\n          return {\r\n            user: message.user.toString(),\r\n            username: `${user.name.first} ${user.name.last}`,\r\n            message: message.message.toString(),\r\n            time: dateToStringWithTime(message.time)\r\n          };\r\n        })\r\n      ),\r\n    };\r\n  }\r\n\r\n  async sendMessage(\r\n    chatID: string,\r\n    userID: string,\r\n    message: string\r\n  ): Promise<ChatResource> {\r\n    if (!chatID) throw new Error(`Chat ID: ${chatID} is invalid.`);\r\n    const chat = await Chat.findById(chatID).exec();\r\n    if (!chat) throw new Error(\"Chat not found\");\r\n    const user = await User.findById(userID).exec();\r\n    if (!user) throw new Error(\"User not found\");\r\n    const event = await Event.findById(chat.event).exec();\r\n    if (!event) throw new Error(\"Event not found\");\r\n    if (!event.participants.includes(user._id)) {\r\n      throw new Error(\"User is not participating in the event\");\r\n    }\r\n\r\n    chat.messages.push({ user: user._id, message: message, time: new Date() });\r\n    const newChat = await chat.save();\r\n    return {\r\n      id: newChat.id,\r\n      event: newChat.event.toString(),\r\n      messages: await Promise.all(\r\n        newChat.messages.map(async (message) => {\r\n          const user = await User.findById(message.user);\r\n          return {\r\n            user: message.user.toString(),\r\n            username: `${user.name.first} ${user.name.last}`,\r\n            message: message.message.toString(),\r\n            time: dateToStringWithTime(message.time)\r\n          };\r\n        })\r\n      ),\r\n    };\r\n  }\r\n}\r\n","resolvedModuleNames":["C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/Resources.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/EventModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/UserModel.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/services/ServiceHelper.ts","C:/Users/naceu/OneDrive/Desktop/Studium/5 Semester/Projekt/connectandexplore/Backend/src/model/RatingModel.ts"]}]]